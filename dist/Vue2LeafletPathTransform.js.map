{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///Vue2LeafletPathTransform.js","webpack:///webpack/bootstrap 518866cecc7ae8f13455","webpack:///./Vue2LeafletPathTransform.vue","webpack:///./L.Path.Transform-src.js","webpack:///Vue2LeafletPathTransform.vue","webpack:///./~/vue-loader/lib/component-normalizer.js","webpack:///./Vue2LeafletPathTransform.vue?2b03","webpack:///external \"vue2-leaflet\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_5__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Component","distance","a","b","dx","x","dy","y","Math","sqrt","TRUE_FN","L","Path","include","_transform","matrix","_renderer","transformPath","_resetTransformPath","_update","_onMouseClick","e","dragging","moved","_map","_fireMouseEvent","END","mousedown","touchstart","pointerdown","MSPointerDown","MOVE","Handler","PathDrag","extend","statics","DRAGGING_CLS","initialize","path","_path","_matrix","_startPoint","_dragStartPoint","_mapDraggingWasEnabled","addHooks","on","_onDragStart","options","className","DomUtil","addClass","removeHooks","off","replace","RegExp","removeClass","_dragMoved","evt","eventType","originalEvent","_simulated","type","containerPoint","clone","DomEvent","stop","_container","document","_onDrag","_onDragEnd","enabled","disable","_popup","_close","_replaceCoordGetters","first","touches","length","mouseEventToContainerPoint","distanceTo","tapTolerance","fire","bringToFront","_transformPoints","_updatePath","_project","_restoreCoordGetters","contains","_containsPoint","Util","falseFn","requestAnimFrame","skipped","fakeStop","enable","dest","len","latlng","px","point","crs","transformation","scale","getZoom","projection","diff","untransform","subtract","applyTransform","_bounds","LatLngBounds","_point","unproject","project","_latlng","_add","_rings","_parts","rings","latlngs","_latlngs","isArray","j","jj","getLatLng","getLatLng_","bind","getLatLngs","getLatLngs_","makeDraggable","layer","addInitHook","draggable","interactive","SVG","setAttributeNS","join","Browser","vml","_skew","removeChild","skew","create","appendChild","style","behavior","mt","toFixed","offset","floor","parseFloat","left","t","top","w","width","h","height","isNaN","origin","Canvas","_containerCopy","_containsPoint_","_requestRedraw","copyCtx","copy","ctx","_ctx","retina","bounds","size","getSize","pos","min","createElement","getContext","_removePath","_redraw","translate","drawImage","_initPath","save","clearRect","setTransform","restore","transform","apply","_drawing","PathTransform","pointOnLine","start","final","distPx","ratio","Point","merge","isObject","toString","key","val","obj","arguments","target","Matrix","f","undefined","translateX","translateY","scaleX","scaleY","rotate","angle","cos","sin","flip","result","src","other","k","Handle","CircleMarker","onAdd","map","setCursor","cursor","CursorsByType","index","RotateHandle","rotation","scaling","uniformScaling","maxZoom","handlerOptions","radius","fillColor","color","fillOpacity","weight","opacity","boundsOptions","dashArray","fill","rotateHandleOptions","handleLength","edgesCount","handleClass","rotateHandleClass","_activeMarker","_originMarker","_rotationMarker","_rotationOrigin","_scaleOrigin","_angle","_scale","_initialDist","_initialDistX","_initialDistY","_rotationStart","_rotationOriginPt","_projectedMatrix","_handlersGroup","_rect","_handlers","_handleLine","setOptions","_createHandlers","_hideHandlers","_enabled","rotationOrigin","scaleOrigin","center","getCenter","handler","_initialPoint","_applyTransform","_apply","_transformGeometries","layerPointToLatLng","redraw","_updateHandlers","reset","removeLayer","_getBoundingPolygon","addTo","handlersGroup","_rectShape","toGeoJSON","_origin","_getProjectedMatrix","zoom","getMaxZoom","_transformPoint","projectedMatrix","_reset","LayerGroup","push","_createHandler","_createRotationHandlers","bottom","LatLng","lat","lng","topPoint","handlerPosition","latLngToLayerPoint","Polyline","RotateHandleClass","_onRotateStart","_getRotationOrigin","lb","rt","layerPoint","_initialMatrix","_onRotate","_onRotateEnd","_cachePoints","previous","atan2","_onScaleStart","marker","_onScale","_onScaleEnd","ratioX","ratioY","originPoint","addLayer","eachLayer","GeoJSON","geometryToLayer","Rectangle","getBounds","HandleClass","rect","slice","_vue2Leaflet","props","latLngs","Array","default","Boolean","custom","handleOptions","mixins","Polygon","data","ready","mounted","optionsMerger","polygonOptions","mapObject","polygon","$listeners","propsBinder","$options","parentContainer","findRealParent","$parent","visible","methods","setDraggable","newVal","oldVal","setVisible","setLatLng","oldLatLng","newLatLng","rawScriptExports","compiledTemplate","scopeId","cssModules","esModule","scriptExports","render","staticRenderFns","_scopeId","computed","keys","forEach","_vm","_h","$createElement","_self","_c","staticStyle","display","_t","_e"],"mappings":"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","file":"Vue2LeafletPathTransform.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vue2-leaflet\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vue2-leaflet\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue2LeafletPathTransform\"] = factory(require(\"vue2-leaflet\"));\n\telse\n\t\troot[\"Vue2LeafletPathTransform\"] = factory(root[\"vue2-leaflet\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vue2-leaflet\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vue2-leaflet\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue2LeafletPathTransform\"] = factory(require(\"vue2-leaflet\"));\n\telse\n\t\troot[\"Vue2LeafletPathTransform\"] = factory(root[\"vue2-leaflet\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(3)(\n  /* script */\n  __webpack_require__(2),\n  /* template */\n  __webpack_require__(4),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Leaflet vector features drag functionality\n * @author Alexander Milevski <info@w8r.name>\n * @preserve\n */\n\nL.Path.include({\n  _transform: function _transform(matrix) {\n    if (this._renderer) {\n      if (matrix) {\n        this._renderer.transformPath(this, matrix);\n      } else {\n        this._renderer._resetTransformPath(this);\n        this._update();\n      }\n    }\n    return this;\n  },\n\n  _onMouseClick: function _onMouseClick(e) {\n    if (this.dragging && this.dragging.moved() || this._map.dragging && this._map.dragging.moved()) {\n      return;\n    }\n\n    this._fireMouseEvent(e);\n  }\n\n});\nvar END = {\n  mousedown: 'mouseup',\n  touchstart: 'touchend',\n  pointerdown: 'touchend',\n  MSPointerDown: 'touchend'\n};\n\nvar MOVE = {\n  mousedown: 'mousemove',\n  touchstart: 'touchmove',\n  pointerdown: 'touchmove',\n  MSPointerDown: 'touchmove'\n};\n\nfunction distance(a, b) {\n  var dx = a.x - b.x,\n      dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nL.Handler.PathDrag = L.Handler.extend({\n\n  statics: {\n    DRAGGING_CLS: 'leaflet-path-draggable'\n  },\n\n  initialize: function initialize(path) {\n    this._path = path;\n\n    this._matrix = null;\n\n    this._startPoint = null;\n\n    this._dragStartPoint = null;\n\n    this._mapDraggingWasEnabled = false;\n  },\n\n  addHooks: function addHooks() {\n    this._path.on('mousedown', this._onDragStart, this);\n\n    this._path.options.className = this._path.options.className ? this._path.options.className + ' ' + L.Handler.PathDrag.DRAGGING_CLS : L.Handler.PathDrag.DRAGGING_CLS;\n\n    if (this._path._path) {\n      L.DomUtil.addClass(this._path._path, L.Handler.PathDrag.DRAGGING_CLS);\n    }\n  },\n\n  removeHooks: function removeHooks() {\n    this._path.off('mousedown', this._onDragStart, this);\n\n    this._path.options.className = this._path.options.className.replace(new RegExp('\\\\s+' + L.Handler.PathDrag.DRAGGING_CLS), '');\n    if (this._path._path) {\n      L.DomUtil.removeClass(this._path._path, L.Handler.PathDrag.DRAGGING_CLS);\n    }\n  },\n\n  moved: function moved() {\n    return this._path._dragMoved;\n  },\n\n  _onDragStart: function _onDragStart(evt) {\n    var eventType = evt.originalEvent._simulated ? 'touchstart' : evt.originalEvent.type;\n\n    this._mapDraggingWasEnabled = false;\n    this._startPoint = evt.containerPoint.clone();\n    this._dragStartPoint = evt.containerPoint.clone();\n    this._matrix = [1, 0, 0, 1, 0, 0];\n    L.DomEvent.stop(evt.originalEvent);\n\n    L.DomUtil.addClass(this._path._renderer._container, 'leaflet-interactive');\n    L.DomEvent.on(document, MOVE[eventType], this._onDrag, this).on(document, END[eventType], this._onDragEnd, this);\n\n    if (this._path._map.dragging.enabled()) {\n\n      this._path._map.dragging.disable();\n      this._mapDraggingWasEnabled = true;\n    }\n    this._path._dragMoved = false;\n\n    if (this._path._popup) {\n      this._path._popup._close();\n    }\n\n    this._replaceCoordGetters(evt);\n  },\n\n  _onDrag: function _onDrag(evt) {\n    L.DomEvent.stop(evt);\n\n    var first = evt.touches && evt.touches.length >= 1 ? evt.touches[0] : evt;\n    var containerPoint = this._path._map.mouseEventToContainerPoint(first);\n\n    if (evt.type === 'touchmove' && !this._path._dragMoved) {\n      var totalMouseDragDistance = this._dragStartPoint.distanceTo(containerPoint);\n      if (totalMouseDragDistance <= this._path._map.options.tapTolerance) {\n        return;\n      }\n    }\n\n    var x = containerPoint.x;\n    var y = containerPoint.y;\n\n    var dx = x - this._startPoint.x;\n    var dy = y - this._startPoint.y;\n\n    if (dx || dy) {\n      if (!this._path._dragMoved) {\n        this._path._dragMoved = true;\n        this._path.fire('dragstart', evt);\n\n        this._path.bringToFront();\n      }\n\n      this._matrix[4] += dx;\n      this._matrix[5] += dy;\n\n      this._startPoint.x = x;\n      this._startPoint.y = y;\n\n      this._path.fire('predrag', evt);\n      this._path._transform(this._matrix);\n      this._path.fire('drag', evt);\n    }\n  },\n\n  _onDragEnd: function _onDragEnd(evt) {\n    var containerPoint = this._path._map.mouseEventToContainerPoint(evt);\n    var moved = this.moved();\n\n    if (moved) {\n      this._transformPoints(this._matrix);\n      this._path._updatePath();\n      this._path._project();\n      this._path._transform(null);\n\n      L.DomEvent.stop(evt);\n    }\n\n    L.DomEvent.off(document, 'mousemove touchmove', this._onDrag, this);\n    L.DomEvent.off(document, 'mouseup touchend', this._onDragEnd, this);\n\n    this._restoreCoordGetters();\n\n    if (moved) {\n      this._path.fire('dragend', {\n        distance: distance(this._dragStartPoint, containerPoint)\n      });\n\n      var contains = this._path._containsPoint;\n      this._path._containsPoint = L.Util.falseFn;\n      L.Util.requestAnimFrame(function () {\n        L.DomEvent.skipped({ type: 'click' });\n        this._path._containsPoint = contains;\n      }, this);\n    }\n\n    this._matrix = null;\n    this._startPoint = null;\n    this._dragStartPoint = null;\n    this._path._dragMoved = false;\n\n    if (this._mapDraggingWasEnabled) {\n      if (moved) L.DomEvent.fakeStop({ type: 'click' });\n      this._path._map.dragging.enable();\n    }\n  },\n\n  _transformPoints: function _transformPoints(matrix, dest) {\n    var path = this._path;\n    var i, len, latlng;\n\n    var px = L.point(matrix[4], matrix[5]);\n\n    var crs = path._map.options.crs;\n    var transformation = crs.transformation;\n    var scale = crs.scale(path._map.getZoom());\n    var projection = crs.projection;\n\n    var diff = transformation.untransform(px, scale).subtract(transformation.untransform(L.point(0, 0), scale));\n    var applyTransform = !dest;\n\n    path._bounds = new L.LatLngBounds();\n\n    if (path._point) {\n      dest = projection.unproject(projection.project(path._latlng)._add(diff));\n      if (applyTransform) {\n        path._latlng = dest;\n        path._point._add(px);\n      }\n    } else if (path._rings || path._parts) {\n      var rings = path._rings || path._parts;\n      var latlngs = path._latlngs;\n      dest = dest || latlngs;\n      if (!L.Util.isArray(latlngs[0])) {\n        latlngs = [latlngs];\n        dest = [dest];\n      }\n      for (i = 0, len = rings.length; i < len; i++) {\n        dest[i] = dest[i] || [];\n        for (var j = 0, jj = rings[i].length; j < jj; j++) {\n          latlng = latlngs[i][j];\n          dest[i][j] = projection.unproject(projection.project(latlng)._add(diff));\n          if (applyTransform) {\n            path._bounds.extend(latlngs[i][j]);\n            rings[i][j]._add(px);\n          }\n        }\n      }\n    }\n    return dest;\n  },\n\n  _replaceCoordGetters: function _replaceCoordGetters() {\n    if (this._path.getLatLng) {\n      this._path.getLatLng_ = this._path.getLatLng;\n      this._path.getLatLng = L.Util.bind(function () {\n        return this.dragging._transformPoints(this.dragging._matrix, {});\n      }, this._path);\n    } else if (this._path.getLatLngs) {\n      this._path.getLatLngs_ = this._path.getLatLngs;\n      this._path.getLatLngs = L.Util.bind(function () {\n        return this.dragging._transformPoints(this.dragging._matrix, []);\n      }, this._path);\n    }\n  },\n\n  _restoreCoordGetters: function _restoreCoordGetters() {\n    if (this._path.getLatLng_) {\n      this._path.getLatLng = this._path.getLatLng_;\n      delete this._path.getLatLng_;\n    } else if (this._path.getLatLngs_) {\n      this._path.getLatLngs = this._path.getLatLngs_;\n      delete this._path.getLatLngs_;\n    }\n  }\n\n});\n\nL.Handler.PathDrag.makeDraggable = function (layer) {\n  layer.dragging = new L.Handler.PathDrag(layer);\n  return layer;\n};\n\nL.Path.prototype.makeDraggable = function () {\n  return L.Handler.PathDrag.makeDraggable(this);\n};\n\nL.Path.addInitHook(function () {\n  if (this.options.draggable) {\n    this.options.interactive = true;\n\n    if (this.dragging) {\n      this.dragging.enable();\n    } else {\n      L.Handler.PathDrag.makeDraggable(this);\n      this.dragging.enable();\n    }\n  } else if (this.dragging) {\n    this.dragging.disable();\n  }\n});\nL.SVG.include({\n  _resetTransformPath: function _resetTransformPath(layer) {\n    layer._path.setAttributeNS(null, 'transform', '');\n  },\n\n  transformPath: function transformPath(layer, matrix) {\n    layer._path.setAttributeNS(null, 'transform', 'matrix(' + matrix.join(' ') + ')');\n  }\n\n});\nL.SVG.include(!L.Browser.vml ? {} : {\n  _resetTransformPath: function _resetTransformPath(layer) {\n    if (layer._skew) {\n      layer._skew.on = false;\n      layer._path.removeChild(layer._skew);\n      layer._skew = null;\n    }\n  },\n\n  transformPath: function transformPath(layer, matrix) {\n    var skew = layer._skew;\n\n    if (!skew) {\n      skew = L.SVG.create('skew');\n      layer._path.appendChild(skew);\n      skew.style.behavior = 'url(#default#VML)';\n      layer._skew = skew;\n    }\n\n    var mt = matrix[0].toFixed(8) + ' ' + matrix[1].toFixed(8) + ' ' + matrix[2].toFixed(8) + ' ' + matrix[3].toFixed(8) + ' 0 0';\n    var offset = Math.floor(matrix[4]).toFixed() + ', ' + Math.floor(matrix[5]).toFixed() + '';\n\n    var s = this._path.style;\n    var l = parseFloat(s.left);\n    var t = parseFloat(s.top);\n    var w = parseFloat(s.width);\n    var h = parseFloat(s.height);\n\n    if (isNaN(l)) l = 0;\n    if (isNaN(t)) t = 0;\n    if (isNaN(w) || !w) w = 1;\n    if (isNaN(h) || !h) h = 1;\n\n    var origin = (-l / w - 0.5).toFixed(8) + ' ' + (-t / h - 0.5).toFixed(8);\n\n    skew.on = 'f';\n    skew.matrix = mt;\n    skew.origin = origin;\n    skew.offset = offset;\n    skew.on = true;\n  }\n\n});\nfunction TRUE_FN() {\n  return true;\n}\n\nL.Canvas.include({\n  _resetTransformPath: function _resetTransformPath(layer) {\n    if (!this._containerCopy) return;\n\n    delete this._containerCopy;\n\n    if (layer._containsPoint_) {\n      layer._containsPoint = layer._containsPoint_;\n      delete layer._containsPoint_;\n\n      this._requestRedraw(layer);\n    }\n  },\n\n  transformPath: function transformPath(layer, matrix) {\n    var copy = this._containerCopy;\n    var ctx = this._ctx,\n        copyCtx;\n    var m = L.Browser.retina ? 2 : 1;\n    var bounds = this._bounds;\n    var size = bounds.getSize();\n    var pos = bounds.min;\n\n    if (!copy) {\n      copy = this._containerCopy = document.createElement('canvas');\n      copyCtx = copy.getContext('2d');\n\n\n      copy.width = m * size.x;\n      copy.height = m * size.y;\n\n      this._removePath(layer);\n      this._redraw();\n\n      copyCtx.translate(m * bounds.min.x, m * bounds.min.y);\n      copyCtx.drawImage(this._container, 0, 0);\n      this._initPath(layer);\n\n      layer._containsPoint_ = layer._containsPoint;\n      layer._containsPoint = TRUE_FN;\n    }\n\n    ctx.save();\n    ctx.clearRect(pos.x, pos.y, size.x * m, size.y * m);\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.restore();\n    ctx.save();\n\n    ctx.drawImage(this._containerCopy, 0, 0, size.x, size.y);\n    ctx.transform.apply(ctx, matrix);\n\n    this._drawing = true;\n    layer._updatePath();\n    this._drawing = false;\n\n    ctx.restore();\n  }\n\n});\n/**\n * Drag/rotate/resize handler for [leaflet](http://leafletjs.com) vector features.\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\nL.PathTransform = {};\n\nL.PathTransform.pointOnLine = function (start, final, distPx) {\n  var ratio = 1 + distPx / start.distanceTo(final);\n  return new L.Point(start.x + (final.x - start.x) * ratio, start.y + (final.y - start.y) * ratio);\n};\n\nL.PathTransform.merge = function () {\n  var i = 1;\n  var key, val;\n  var obj = arguments[i];\n\n  function isObject(object) {\n    return Object.prototype.toString.call(object) === '[object Object]';\n  }\n\n  var target = arguments[0];\n\n  while (obj) {\n    obj = arguments[i++];\n    for (key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      val = obj[key];\n\n      if (isObject(val) && isObject(target[key])) {\n        target[key] = L.Util.merge(target[key], val);\n      } else {\n        target[key] = val;\n      }\n    }\n  }\n  return target;\n};\n\nL.Matrix = function (a, b, c, d, e, f) {\n  this._matrix = [a, b, c, d, e, f];\n};\n\nL.Matrix.prototype = {\n  transform: function transform(point) {\n    return this._transform(point.clone());\n  },\n\n  _transform: function _transform(point) {\n    var matrix = this._matrix;\n    var x = point.x,\n        y = point.y;\n    point.x = matrix[0] * x + matrix[1] * y + matrix[4];\n    point.y = matrix[2] * x + matrix[3] * y + matrix[5];\n    return point;\n  },\n\n  untransform: function untransform(point) {\n    var matrix = this._matrix;\n    return new L.Point((point.x / matrix[0] - matrix[4]) / matrix[0], (point.y / matrix[2] - matrix[5]) / matrix[2]);\n  },\n\n  clone: function clone() {\n    var matrix = this._matrix;\n    return new L.Matrix(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n  },\n\n  translate: function translate(_translate) {\n    if (_translate === undefined) {\n      return new L.Point(this._matrix[4], this._matrix[5]);\n    }\n\n    var translateX, translateY;\n    if (typeof _translate === 'number') {\n      translateX = translateY = _translate;\n    } else {\n      translateX = _translate.x;\n      translateY = _translate.y;\n    }\n\n    return this._add(1, 0, 0, 1, translateX, translateY);\n  },\n\n  scale: function scale(_scale, origin) {\n    if (_scale === undefined) {\n      return new L.Point(this._matrix[0], this._matrix[3]);\n    }\n\n    var scaleX, scaleY;\n    origin = origin || L.point(0, 0);\n    if (typeof _scale === 'number') {\n      scaleX = scaleY = _scale;\n    } else {\n      scaleX = _scale.x;\n      scaleY = _scale.y;\n    }\n\n    return this._add(scaleX, 0, 0, scaleY, origin.x, origin.y)._add(1, 0, 0, 1, -origin.x, -origin.y);\n  },\n\n  rotate: function rotate(angle, origin) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n\n    origin = origin || new L.Point(0, 0);\n\n    return this._add(cos, sin, -sin, cos, origin.x, origin.y)._add(1, 0, 0, 1, -origin.x, -origin.y);\n  },\n\n  flip: function flip() {\n    this._matrix[1] *= -1;\n    this._matrix[2] *= -1;\n    return this;\n  },\n\n  _add: function _add(a, b, c, d, e, f) {\n    var result = [[], [], []];\n    var src = this._matrix;\n    var m = [[src[0], src[2], src[4]], [src[1], src[3], src[5]], [0, 0, 1]];\n    var other = [[a, c, e], [b, d, f], [0, 0, 1]],\n        val;\n\n    if (a && a instanceof L.Matrix) {\n      src = a._matrix;\n      other = [[src[0], src[2], src[4]], [src[1], src[3], src[5]], [0, 0, 1]];\n    }\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        val = 0;\n        for (var k = 0; k < 3; k++) {\n          val += m[i][k] * other[k][j];\n        }\n        result[i][j] = val;\n      }\n    }\n\n    this._matrix = [result[0][0], result[1][0], result[0][1], result[1][1], result[0][2], result[1][2]];\n    return this;\n  }\n\n};\n\nL.matrix = function (a, b, c, d, e, f) {\n  return new L.Matrix(a, b, c, d, e, f);\n};\n\nL.PathTransform.Handle = L.CircleMarker.extend({\n  options: {\n    className: 'leaflet-path-transform-handler'\n  },\n\n  onAdd: function onAdd(map) {\n    L.CircleMarker.prototype.onAdd.call(this, map);\n    if (this._path && this.options.setCursor) {\n      this._path.style.cursor = L.PathTransform.Handle.CursorsByType[this.options.index];\n    }\n  }\n});\n\nL.PathTransform.Handle.CursorsByType = ['nesw-resize', 'nwse-resize', 'nesw-resize', 'nwse-resize'];\n\nL.PathTransform.RotateHandle = L.PathTransform.Handle.extend({\n  options: {\n    className: 'leaflet-path-transform-handler transform-handler--rotate'\n  },\n\n  onAdd: function onAdd(map) {\n    L.CircleMarker.prototype.onAdd.call(this, map);\n    if (this._path && this.options.setCursor) {\n      this._path.style.cursor = 'all-scroll';\n    }\n  }\n});\n\nL.Handler.PathTransform = L.Handler.extend({\n\n  options: {\n    rotation: true,\n    scaling: true,\n    uniformScaling: true,\n    maxZoom: 22,\n\n    handlerOptions: {\n      radius: 5,\n      fillColor: '#ffffff',\n      color: '#202020',\n      fillOpacity: 1,\n      weight: 2,\n      opacity: 0.7,\n      setCursor: true\n    },\n\n    boundsOptions: {\n      weight: 1,\n      opacity: 1,\n      dashArray: [3, 3],\n      fill: false\n    },\n\n    rotateHandleOptions: {\n      weight: 1,\n      opacity: 1,\n      setCursor: true\n    },\n\n    handleLength: 20,\n\n    edgesCount: 4,\n\n    handleClass: L.PathTransform.Handle,\n    rotateHandleClass: L.PathTransform.RotateHandle\n  },\n\n  initialize: function initialize(path) {\n    this._path = path;\n    this._map = null;\n\n    this._activeMarker = null;\n    this._originMarker = null;\n    this._rotationMarker = null;\n\n    this._rotationOrigin = null;\n    this._scaleOrigin = null;\n    this._angle = 0;\n    this._scale = L.point(1, 1);\n    this._initialDist = 0;\n    this._initialDistX = 0;\n    this._initialDistY = 0;\n    this._rotationStart = null;\n    this._rotationOriginPt = null;\n\n    this._matrix = new L.Matrix(1, 0, 0, 1, 0, 0);\n    this._projectedMatrix = new L.Matrix(1, 0, 0, 1, 0, 0);\n\n    this._handlersGroup = null;\n    this._rect = null;\n    this._handlers = [];\n    this._handleLine = null;\n  },\n\n  enable: function enable(options) {\n    if (this._path._map) {\n      this._map = this._path._map;\n      if (options) {\n        this.setOptions(options);\n      }\n      L.Handler.prototype.enable.call(this);\n    }\n  },\n\n  addHooks: function addHooks() {\n    this._createHandlers();\n    this._path.on('dragstart', this._onDragStart, this).on('dragend', this._onDragEnd, this);\n  },\n\n  removeHooks: function removeHooks() {\n    this._hideHandlers();\n    this._path.off('dragstart', this._onDragStart, this).off('dragend', this._onDragEnd, this);\n    this._handlersGroup = null;\n    this._rect = null;\n    this._handlers = [];\n  },\n\n  setOptions: function setOptions(options) {\n    var enabled = this._enabled;\n    if (enabled) {\n      this.disable();\n    }\n\n    this.options = L.PathTransform.merge({}, L.Handler.PathTransform.prototype.options, options);\n\n    if (enabled) {\n      this.enable();\n    }\n\n    return this;\n  },\n\n  rotate: function rotate(angle, origin) {\n    return this.transform(angle, null, origin);\n  },\n\n  scale: function scale(_scale2, origin) {\n    if (typeof _scale2 === 'number') {\n      _scale2 = L.point(_scale2, _scale2);\n    }\n    return this.transform(0, _scale2, null, origin);\n  },\n\n  transform: function transform(angle, scale, rotationOrigin, scaleOrigin) {\n    var center = this._path.getCenter();\n    rotationOrigin = rotationOrigin || center;\n    scaleOrigin = scaleOrigin || center;\n    this._map = this._path._map;\n    this._transformPoints(this._path, angle, scale, rotationOrigin, scaleOrigin);\n    return this;\n  },\n\n  _update: function _update() {\n    var matrix = this._matrix;\n\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      if (handler !== this._originMarker) {\n        handler._point = matrix.transform(handler._initialPoint);\n        handler._updatePath();\n      }\n    }\n\n    matrix = matrix.clone().flip();\n\n    this._applyTransform(matrix);\n    this._path.fire('transform', { layer: this._path });\n  },\n\n  _applyTransform: function _applyTransform(matrix) {\n    this._path._transform(matrix._matrix);\n    this._rect._transform(matrix._matrix);\n\n    if (this.options.rotation) {\n      this._handleLine._transform(matrix._matrix);\n    }\n  },\n\n  _apply: function _apply() {\n    var map = this._map;\n    var matrix = this._matrix.clone();\n    var angle = this._angle;\n    var scale = this._scale.clone();\n\n    this._transformGeometries();\n\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      handler._latlng = map.layerPointToLatLng(handler._point);\n      delete handler._initialPoint;\n      handler.redraw();\n    }\n\n    this._matrix = L.matrix(1, 0, 0, 1, 0, 0);\n    this._scale = L.point(1, 1);\n    this._angle = 0;\n\n    this._updateHandlers();\n\n    map.dragging.enable();\n    this._path.fire('transformed', {\n      matrix: matrix,\n      scale: scale,\n      rotation: angle,\n\n      layer: this._path\n    });\n  },\n\n  reset: function reset() {\n    if (this._enabled) {\n      if (this._rect) {\n        this._handlersGroup.removeLayer(this._rect);\n        this._rect = this._getBoundingPolygon().addTo(this._handlersGroup);\n      }\n      this._updateHandlers();\n    }\n  },\n\n  _updateHandlers: function _updateHandlers() {\n    var handlersGroup = this._handlersGroup;\n\n    this._rectShape = this._rect.toGeoJSON();\n\n    if (this._handleLine) {\n      this._handlersGroup.removeLayer(this._handleLine);\n    }\n\n    if (this._rotationMarker) {\n      this._handlersGroup.removeLayer(this._rotationMarker);\n    }\n\n    this._handleLine = this._rotationMarker = null;\n\n    for (var i = this._handlers.length - 1; i >= 0; i--) {\n      handlersGroup.removeLayer(this._handlers[i]);\n    }\n\n    this._createHandlers();\n  },\n\n  _transformGeometries: function _transformGeometries() {\n    this._path._transform(null);\n    this._rect._transform(null);\n\n    this._transformPoints(this._path);\n    this._transformPoints(this._rect);\n\n    if (this.options.rotation) {\n      this._handleLine._transform(null);\n      this._transformPoints(this._handleLine, this._angle, null, this._origin);\n    }\n  },\n\n  _getProjectedMatrix: function _getProjectedMatrix(angle, scale, rotationOrigin, scaleOrigin) {\n    var map = this._map;\n    var zoom = map.getMaxZoom() || this.options.maxZoom;\n    var matrix = L.matrix(1, 0, 0, 1, 0, 0);\n    var origin;\n\n    angle = angle || this._angle || 0;\n    scale = scale || this._scale || L.point(1, 1);\n\n    if (!(scale.x === 1 && scale.y === 1)) {\n      scaleOrigin = scaleOrigin || this._scaleOrigin;\n      origin = map.project(scaleOrigin, zoom);\n      matrix = matrix._add(L.matrix(1, 0, 0, 1, origin.x, origin.y))._add(L.matrix(scale.x, 0, 0, scale.y, 0, 0))._add(L.matrix(1, 0, 0, 1, -origin.x, -origin.y));\n    }\n\n    if (angle) {\n      rotationOrigin = rotationOrigin || this._rotationOrigin;\n      origin = map.project(rotationOrigin, zoom);\n      matrix = matrix.rotate(angle, origin).flip();\n    }\n\n    return matrix;\n  },\n\n  _transformPoint: function _transformPoint(latlng, matrix, map, zoom) {\n    return map.unproject(matrix.transform(map.project(latlng, zoom)), zoom);\n  },\n\n  _transformPoints: function _transformPoints(path, angle, scale, rotationOrigin, scaleOrigin) {\n    var map = path._map;\n    var zoom = map.getMaxZoom() || this.options.maxZoom;\n    var i, len;\n\n    var projectedMatrix = this._projectedMatrix = this._getProjectedMatrix(angle, scale, rotationOrigin, scaleOrigin);\n\n    if (path._point) {\n      path._latlng = this._transformPoint(path._latlng, projectedMatrix, map, zoom);\n    } else if (path._rings || path._parts) {\n      var rings = path._rings;\n      var latlngs = path._latlngs;\n      path._bounds = new L.LatLngBounds();\n\n      if (!L.Util.isArray(latlngs[0])) {\n        latlngs = [latlngs];\n      }\n      for (i = 0, len = rings.length; i < len; i++) {\n        for (var j = 0, jj = rings[i].length; j < jj; j++) {\n          latlngs[i][j] = this._transformPoint(latlngs[i][j], projectedMatrix, map, zoom);\n          path._bounds.extend(latlngs[i][j]);\n        }\n      }\n    }\n\n    path._reset();\n  },\n\n  _createHandlers: function _createHandlers() {\n    var map = this._map;\n    this._handlersGroup = this._handlersGroup || new L.LayerGroup().addTo(map);\n    this._rect = this._rect || this._getBoundingPolygon().addTo(this._handlersGroup);\n\n    if (this.options.scaling) {\n      this._handlers = [];\n      for (var i = 0; i < this.options.edgesCount; i++) {\n        this._handlers.push(this._createHandler(this._rect._latlngs[0][i], i * 2, i).addTo(this._handlersGroup));\n      }\n    }\n\n    if (this.options.rotation) {\n      this._createRotationHandlers();\n    }\n  },\n\n  _createRotationHandlers: function _createRotationHandlers() {\n    var map = this._map;\n    var latlngs = this._rect._latlngs[0];\n\n    var bottom = new L.LatLng((latlngs[0].lat + latlngs[3].lat) / 2, (latlngs[0].lng + latlngs[3].lng) / 2);\n\n    var topPoint = new L.LatLng((latlngs[1].lat + latlngs[2].lat) / 2, (latlngs[1].lng + latlngs[2].lng) / 2);\n\n    var handlerPosition = map.layerPointToLatLng(L.PathTransform.pointOnLine(map.latLngToLayerPoint(bottom), map.latLngToLayerPoint(topPoint), this.options.handleLength));\n\n    this._handleLine = new L.Polyline([topPoint, handlerPosition], this.options.rotateHandleOptions).addTo(this._handlersGroup);\n    var RotateHandleClass = this.options.rotateHandleClass;\n    this._rotationMarker = new RotateHandleClass(handlerPosition, this.options.handlerOptions).addTo(this._handlersGroup).on('mousedown', this._onRotateStart, this);\n\n    this._rotationOrigin = new L.LatLng((topPoint.lat + bottom.lat) / 2, (topPoint.lng + bottom.lng) / 2);\n\n    this._handlers.push(this._rotationMarker);\n  },\n\n  _getRotationOrigin: function _getRotationOrigin() {\n    var latlngs = this._rect._latlngs[0];\n    var lb = latlngs[0];\n    var rt = latlngs[2];\n\n    return new L.LatLng((lb.lat + rt.lat) / 2, (lb.lng + rt.lng) / 2);\n  },\n\n  _onRotateStart: function _onRotateStart(evt) {\n    var map = this._map;\n\n    map.dragging.disable();\n\n    this._originMarker = null;\n    this._rotationOriginPt = map.latLngToLayerPoint(this._getRotationOrigin());\n    this._rotationStart = evt.layerPoint;\n    this._initialMatrix = this._matrix.clone();\n\n    this._angle = 0;\n    this._path._map.on('mousemove', this._onRotate, this).on('mouseup', this._onRotateEnd, this);\n\n    this._cachePoints();\n    this._path.fire('transformstart', { layer: this._path }).fire('rotatestart', { layer: this._path, rotation: 0 });\n  },\n\n  _onRotate: function _onRotate(evt) {\n    var pos = evt.layerPoint;\n    var previous = this._rotationStart;\n    var origin = this._rotationOriginPt;\n\n    this._angle = Math.atan2(pos.y - origin.y, pos.x - origin.x) - Math.atan2(previous.y - origin.y, previous.x - origin.x);\n\n    this._matrix = this._initialMatrix.clone().rotate(this._angle, origin).flip();\n\n    this._update();\n    this._path.fire('rotate', { layer: this._path, rotation: this._angle });\n  },\n\n  _onRotateEnd: function _onRotateEnd(evt) {\n    this._path._map.off('mousemove', this._onRotate, this).off('mouseup', this._onRotateEnd, this);\n\n    this._apply();\n    this._path.fire('rotateend', { layer: this._path, rotation: this._angle });\n  },\n\n  _onScaleStart: function _onScaleStart(evt) {\n    var marker = evt.target;\n    var map = this._map;\n\n    map.dragging.disable();\n\n    this._activeMarker = marker;\n\n    this._originMarker = this._handlers[(marker.options.index + 2) % 4];\n    this._scaleOrigin = this._originMarker.getLatLng();\n\n    this._initialMatrix = this._matrix.clone();\n    this._cachePoints();\n\n    this._map.on('mousemove', this._onScale, this).on('mouseup', this._onScaleEnd, this);\n    this._initialDist = this._originMarker._point.distanceTo(this._activeMarker._point);\n    this._initialDistX = this._originMarker._point.x - this._activeMarker._point.x;\n    this._initialDistY = this._originMarker._point.y - this._activeMarker._point.y;\n\n    this._path.fire('transformstart', { layer: this._path }).fire('scalestart', { layer: this._path, scale: L.point(1, 1) });\n\n    this._map.removeLayer(this._handleLine);\n    this._map.removeLayer(this._rotationMarker);\n  },\n\n  _onScale: function _onScale(evt) {\n    var originPoint = this._originMarker._point;\n    var ratioX, ratioY;\n    if (this.options.uniformScaling) {\n      ratioX = originPoint.distanceTo(evt.layerPoint) / this._initialDist;\n      ratioY = ratioX;\n    } else {\n      ratioX = (originPoint.x - evt.layerPoint.x) / this._initialDistX;\n      ratioY = (originPoint.y - evt.layerPoint.y) / this._initialDistY;\n    }\n\n    this._scale = new L.Point(ratioX, ratioY);\n\n    this._matrix = this._initialMatrix.clone().scale(this._scale, originPoint);\n\n    this._update();\n    this._path.fire('scale', {\n      layer: this._path, scale: this._scale.clone() });\n  },\n\n  _onScaleEnd: function _onScaleEnd(evt) {\n    this._map.off('mousemove', this._onScale, this).off('mouseup', this._onScaleEnd, this);\n\n    this._map.addLayer(this._handleLine);\n    this._map.addLayer(this._rotationMarker);\n\n    this._apply();\n    this._path.fire('scaleend', {\n      layer: this._path, scale: this._scale.clone() });\n  },\n\n  _cachePoints: function _cachePoints() {\n    this._handlersGroup.eachLayer(function (layer) {\n      layer.bringToFront();\n    });\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      handler._initialPoint = handler._point.clone();\n    }\n  },\n\n  _getBoundingPolygon: function _getBoundingPolygon() {\n    if (this._rectShape) {\n      return L.GeoJSON.geometryToLayer(this._rectShape, this.options.boundsOptions);\n    } else {\n      return new L.Rectangle(this._path.getBounds(), this.options.boundsOptions);\n    }\n  },\n\n  _createHandler: function _createHandler(latlng, type, index) {\n    var HandleClass = this.options.handleClass;\n    var marker = new HandleClass(latlng, L.Util.extend({}, this.options.handlerOptions, {\n      className: 'leaflet-drag-transform-marker drag-marker--' + index + ' drag-marker--' + type,\n      index: index,\n      type: type\n    }));\n\n    marker.on('mousedown', this._onScaleStart, this);\n    return marker;\n  },\n\n  _hideHandlers: function _hideHandlers() {\n    this._map.removeLayer(this._handlersGroup);\n  },\n\n  _onDragStart: function _onDragStart() {\n    this._hideHandlers();\n  },\n\n  _onDragEnd: function _onDragEnd(evt) {\n    var rect = this._rect;\n    var matrix = (evt.layer ? evt.layer : this._path).dragging._matrix.slice();\n\n    if (!rect.dragging) {\n      rect.dragging = new L.Handler.PathDrag(rect);\n    }\n    rect.dragging.enable();\n    this._map.addLayer(rect);\n    rect.dragging._transformPoints(matrix);\n    rect._updatePath();\n    rect._project();\n\n    rect.dragging.disable();\n\n    this._map.addLayer(this._handlersGroup);\n    this._updateHandlers();\n\n    this._path.fire('transformed', {\n      scale: L.point(1, 1),\n      rotation: 0,\n      matrix: L.matrix.apply(undefined, matrix),\n      translate: L.point(matrix[4], matrix[5]),\n      layer: this._path\n    });\n  }\n});\n\nL.Path.addInitHook(function () {\n  if (this.options.transform) {\n    this.transform = new L.Handler.PathTransform(this, this.options.transform);\n  }\n});\n\nexports.L = L;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkwuUGF0aC5UcmFuc2Zvcm0tc3JjLmpzIl0sIm5hbWVzIjpbIkwiLCJQYXRoIiwiaW5jbHVkZSIsIl90cmFuc2Zvcm0iLCJtYXRyaXgiLCJfcmVuZGVyZXIiLCJ0cmFuc2Zvcm1QYXRoIiwiX3Jlc2V0VHJhbnNmb3JtUGF0aCIsIl91cGRhdGUiLCJfb25Nb3VzZUNsaWNrIiwiZSIsImRyYWdnaW5nIiwibW92ZWQiLCJfbWFwIiwiX2ZpcmVNb3VzZUV2ZW50IiwiRU5EIiwibW91c2Vkb3duIiwidG91Y2hzdGFydCIsInBvaW50ZXJkb3duIiwiTVNQb2ludGVyRG93biIsIk1PVkUiLCJkaXN0YW5jZSIsImEiLCJiIiwiZHgiLCJ4IiwiZHkiLCJ5IiwiTWF0aCIsInNxcnQiLCJIYW5kbGVyIiwiUGF0aERyYWciLCJleHRlbmQiLCJzdGF0aWNzIiwiRFJBR0dJTkdfQ0xTIiwiaW5pdGlhbGl6ZSIsInBhdGgiLCJfcGF0aCIsIl9tYXRyaXgiLCJfc3RhcnRQb2ludCIsIl9kcmFnU3RhcnRQb2ludCIsIl9tYXBEcmFnZ2luZ1dhc0VuYWJsZWQiLCJhZGRIb29rcyIsIm9uIiwiX29uRHJhZ1N0YXJ0Iiwib3B0aW9ucyIsImNsYXNzTmFtZSIsIkRvbVV0aWwiLCJhZGRDbGFzcyIsInJlbW92ZUhvb2tzIiwib2ZmIiwicmVwbGFjZSIsIlJlZ0V4cCIsInJlbW92ZUNsYXNzIiwiX2RyYWdNb3ZlZCIsImV2dCIsImV2ZW50VHlwZSIsIm9yaWdpbmFsRXZlbnQiLCJfc2ltdWxhdGVkIiwidHlwZSIsImNvbnRhaW5lclBvaW50IiwiY2xvbmUiLCJEb21FdmVudCIsInN0b3AiLCJfY29udGFpbmVyIiwiZG9jdW1lbnQiLCJfb25EcmFnIiwiX29uRHJhZ0VuZCIsImVuYWJsZWQiLCJkaXNhYmxlIiwiX3BvcHVwIiwiX2Nsb3NlIiwiX3JlcGxhY2VDb29yZEdldHRlcnMiLCJmaXJzdCIsInRvdWNoZXMiLCJsZW5ndGgiLCJtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCIsInRvdGFsTW91c2VEcmFnRGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwidGFwVG9sZXJhbmNlIiwiZmlyZSIsImJyaW5nVG9Gcm9udCIsIl90cmFuc2Zvcm1Qb2ludHMiLCJfdXBkYXRlUGF0aCIsIl9wcm9qZWN0IiwiX3Jlc3RvcmVDb29yZEdldHRlcnMiLCJjb250YWlucyIsIl9jb250YWluc1BvaW50IiwiVXRpbCIsImZhbHNlRm4iLCJyZXF1ZXN0QW5pbUZyYW1lIiwic2tpcHBlZCIsImZha2VTdG9wIiwiZW5hYmxlIiwiZGVzdCIsImkiLCJsZW4iLCJsYXRsbmciLCJweCIsInBvaW50IiwiY3JzIiwidHJhbnNmb3JtYXRpb24iLCJzY2FsZSIsImdldFpvb20iLCJwcm9qZWN0aW9uIiwiZGlmZiIsInVudHJhbnNmb3JtIiwic3VidHJhY3QiLCJhcHBseVRyYW5zZm9ybSIsIl9ib3VuZHMiLCJMYXRMbmdCb3VuZHMiLCJfcG9pbnQiLCJ1bnByb2plY3QiLCJwcm9qZWN0IiwiX2xhdGxuZyIsIl9hZGQiLCJfcmluZ3MiLCJfcGFydHMiLCJyaW5ncyIsImxhdGxuZ3MiLCJfbGF0bG5ncyIsImlzQXJyYXkiLCJqIiwiamoiLCJnZXRMYXRMbmciLCJnZXRMYXRMbmdfIiwiYmluZCIsImdldExhdExuZ3MiLCJnZXRMYXRMbmdzXyIsIm1ha2VEcmFnZ2FibGUiLCJsYXllciIsInByb3RvdHlwZSIsImFkZEluaXRIb29rIiwiZHJhZ2dhYmxlIiwiaW50ZXJhY3RpdmUiLCJTVkciLCJzZXRBdHRyaWJ1dGVOUyIsImpvaW4iLCJCcm93c2VyIiwidm1sIiwiX3NrZXciLCJyZW1vdmVDaGlsZCIsInNrZXciLCJjcmVhdGUiLCJhcHBlbmRDaGlsZCIsInN0eWxlIiwiYmVoYXZpb3IiLCJtdCIsInRvRml4ZWQiLCJvZmZzZXQiLCJmbG9vciIsInMiLCJsIiwicGFyc2VGbG9hdCIsImxlZnQiLCJ0IiwidG9wIiwidyIsIndpZHRoIiwiaCIsImhlaWdodCIsImlzTmFOIiwib3JpZ2luIiwiVFJVRV9GTiIsIkNhbnZhcyIsIl9jb250YWluZXJDb3B5IiwiX2NvbnRhaW5zUG9pbnRfIiwiX3JlcXVlc3RSZWRyYXciLCJjb3B5IiwiY3R4IiwiX2N0eCIsImNvcHlDdHgiLCJtIiwicmV0aW5hIiwiYm91bmRzIiwic2l6ZSIsImdldFNpemUiLCJwb3MiLCJtaW4iLCJjcmVhdGVFbGVtZW50IiwiZ2V0Q29udGV4dCIsIl9yZW1vdmVQYXRoIiwiX3JlZHJhdyIsInRyYW5zbGF0ZSIsImRyYXdJbWFnZSIsIl9pbml0UGF0aCIsInNhdmUiLCJjbGVhclJlY3QiLCJzZXRUcmFuc2Zvcm0iLCJyZXN0b3JlIiwidHJhbnNmb3JtIiwiYXBwbHkiLCJfZHJhd2luZyIsIlBhdGhUcmFuc2Zvcm0iLCJwb2ludE9uTGluZSIsInN0YXJ0IiwiZmluYWwiLCJkaXN0UHgiLCJyYXRpbyIsIlBvaW50IiwibWVyZ2UiLCJrZXkiLCJ2YWwiLCJvYmoiLCJhcmd1bWVudHMiLCJpc09iamVjdCIsIm9iamVjdCIsIk9iamVjdCIsInRvU3RyaW5nIiwiY2FsbCIsInRhcmdldCIsImhhc093blByb3BlcnR5IiwiTWF0cml4IiwiYyIsImQiLCJmIiwidW5kZWZpbmVkIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJzY2FsZVgiLCJzY2FsZVkiLCJyb3RhdGUiLCJhbmdsZSIsImNvcyIsInNpbiIsImZsaXAiLCJyZXN1bHQiLCJzcmMiLCJvdGhlciIsImsiLCJIYW5kbGUiLCJDaXJjbGVNYXJrZXIiLCJvbkFkZCIsIm1hcCIsInNldEN1cnNvciIsImN1cnNvciIsIkN1cnNvcnNCeVR5cGUiLCJpbmRleCIsIlJvdGF0ZUhhbmRsZSIsInJvdGF0aW9uIiwic2NhbGluZyIsInVuaWZvcm1TY2FsaW5nIiwibWF4Wm9vbSIsImhhbmRsZXJPcHRpb25zIiwicmFkaXVzIiwiZmlsbENvbG9yIiwiY29sb3IiLCJmaWxsT3BhY2l0eSIsIndlaWdodCIsIm9wYWNpdHkiLCJib3VuZHNPcHRpb25zIiwiZGFzaEFycmF5IiwiZmlsbCIsInJvdGF0ZUhhbmRsZU9wdGlvbnMiLCJoYW5kbGVMZW5ndGgiLCJlZGdlc0NvdW50IiwiaGFuZGxlQ2xhc3MiLCJyb3RhdGVIYW5kbGVDbGFzcyIsIl9hY3RpdmVNYXJrZXIiLCJfb3JpZ2luTWFya2VyIiwiX3JvdGF0aW9uTWFya2VyIiwiX3JvdGF0aW9uT3JpZ2luIiwiX3NjYWxlT3JpZ2luIiwiX2FuZ2xlIiwiX3NjYWxlIiwiX2luaXRpYWxEaXN0IiwiX2luaXRpYWxEaXN0WCIsIl9pbml0aWFsRGlzdFkiLCJfcm90YXRpb25TdGFydCIsIl9yb3RhdGlvbk9yaWdpblB0IiwiX3Byb2plY3RlZE1hdHJpeCIsIl9oYW5kbGVyc0dyb3VwIiwiX3JlY3QiLCJfaGFuZGxlcnMiLCJfaGFuZGxlTGluZSIsInNldE9wdGlvbnMiLCJfY3JlYXRlSGFuZGxlcnMiLCJfaGlkZUhhbmRsZXJzIiwiX2VuYWJsZWQiLCJyb3RhdGlvbk9yaWdpbiIsInNjYWxlT3JpZ2luIiwiY2VudGVyIiwiZ2V0Q2VudGVyIiwiaGFuZGxlciIsIl9pbml0aWFsUG9pbnQiLCJfYXBwbHlUcmFuc2Zvcm0iLCJfYXBwbHkiLCJfdHJhbnNmb3JtR2VvbWV0cmllcyIsImxheWVyUG9pbnRUb0xhdExuZyIsInJlZHJhdyIsIl91cGRhdGVIYW5kbGVycyIsInJlc2V0IiwicmVtb3ZlTGF5ZXIiLCJfZ2V0Qm91bmRpbmdQb2x5Z29uIiwiYWRkVG8iLCJoYW5kbGVyc0dyb3VwIiwiX3JlY3RTaGFwZSIsInRvR2VvSlNPTiIsIl9vcmlnaW4iLCJfZ2V0UHJvamVjdGVkTWF0cml4Iiwiem9vbSIsImdldE1heFpvb20iLCJfdHJhbnNmb3JtUG9pbnQiLCJwcm9qZWN0ZWRNYXRyaXgiLCJfcmVzZXQiLCJMYXllckdyb3VwIiwicHVzaCIsIl9jcmVhdGVIYW5kbGVyIiwiX2NyZWF0ZVJvdGF0aW9uSGFuZGxlcnMiLCJib3R0b20iLCJMYXRMbmciLCJsYXQiLCJsbmciLCJ0b3BQb2ludCIsImhhbmRsZXJQb3NpdGlvbiIsImxhdExuZ1RvTGF5ZXJQb2ludCIsIlBvbHlsaW5lIiwiUm90YXRlSGFuZGxlQ2xhc3MiLCJfb25Sb3RhdGVTdGFydCIsIl9nZXRSb3RhdGlvbk9yaWdpbiIsImxiIiwicnQiLCJsYXllclBvaW50IiwiX2luaXRpYWxNYXRyaXgiLCJfb25Sb3RhdGUiLCJfb25Sb3RhdGVFbmQiLCJfY2FjaGVQb2ludHMiLCJwcmV2aW91cyIsImF0YW4yIiwiX29uU2NhbGVTdGFydCIsIm1hcmtlciIsIl9vblNjYWxlIiwiX29uU2NhbGVFbmQiLCJvcmlnaW5Qb2ludCIsInJhdGlvWCIsInJhdGlvWSIsImFkZExheWVyIiwiZWFjaExheWVyIiwiR2VvSlNPTiIsImdlb21ldHJ5VG9MYXllciIsIlJlY3RhbmdsZSIsImdldEJvdW5kcyIsIkhhbmRsZUNsYXNzIiwicmVjdCIsInNsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7Ozs7O0FBVUFBLEVBQUVDLElBQUYsQ0FBT0MsT0FBUCxDQUFlO0FBTWRDLGNBQVksb0JBQVNDLE1BQVQsRUFBaUI7QUFDNUIsUUFBSSxLQUFLQyxTQUFULEVBQW9CO0FBQ25CLFVBQUlELE1BQUosRUFBWTtBQUNYLGFBQUtDLFNBQUwsQ0FBZUMsYUFBZixDQUE2QixJQUE3QixFQUFtQ0YsTUFBbkM7QUFDQSxPQUZELE1BRU87QUFFTixhQUFLQyxTQUFMLENBQWVFLG1CQUFmLENBQW1DLElBQW5DO0FBQ0EsYUFBS0MsT0FBTDtBQUNBO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDQSxHQWpCYTs7QUF5QmRDLGlCQUFlLHVCQUFTQyxDQUFULEVBQVk7QUFDMUIsUUFBSyxLQUFLQyxRQUFMLElBQWlCLEtBQUtBLFFBQUwsQ0FBY0MsS0FBZCxFQUFsQixJQUNGLEtBQUtDLElBQUwsQ0FBVUYsUUFBVixJQUFzQixLQUFLRSxJQUFMLENBQVVGLFFBQVYsQ0FBbUJDLEtBQW5CLEVBRHhCLEVBQ3FEO0FBQ3BEO0FBQ0E7O0FBRUQsU0FBS0UsZUFBTCxDQUFxQkosQ0FBckI7QUFDQTs7QUFoQ2EsQ0FBZjtBQW1DQSxJQUFJSyxNQUFNO0FBQ1JDLGFBQWUsU0FEUDtBQUVS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QTFCOztBQTJ0QkFyQyxFQUFFQyxJQUFGLENBQU9tSSxXQUFQLENBQW1CLFlBQVc7QUFDNUIsTUFBSSxLQUFLdkYsT0FBTCxDQUFhaUosU0FBakIsRUFBNEI7QUFDMUIsU0FBS0EsU0FBTCxHQUFpQixJQUFJOUwsRUFBRThCLE9BQUYsQ0FBVW1LLGFBQWQsQ0FBNEIsSUFBNUIsRUFBa0MsS0FBS3BKLE9BQUwsQ0FBYWlKLFNBQS9DLENBQWpCO0FBQ0Q7QUFDRixDQUpEOztRQU9ROUwsQyxHQUFBQSxDIiwiZmlsZSI6IkwuUGF0aC5UcmFuc2Zvcm0tc3JjLmpzIiwic291cmNlUm9vdCI6Ii93d3cvc2l0ZXMvdnVlMi1sZWFmbGV0LXBhdGh0cmFuc2Zvcm0iLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTGVhZmxldCB2ZWN0b3IgZmVhdHVyZXMgZHJhZyBmdW5jdGlvbmFsaXR5XG4gKiBAYXV0aG9yIEFsZXhhbmRlciBNaWxldnNraSA8aW5mb0B3OHIubmFtZT5cbiAqIEBwcmVzZXJ2ZVxuICovXG5cbi8qKlxuICogTWF0cml4IHRyYW5zZm9ybSBwYXRoIGZvciBTVkcvVk1MXG4gKiBSZW5kZXJlci1pbmRlcGVuZGVudFxuICovXG5MLlBhdGguaW5jbHVkZSh7XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgbWF0cml4IHRyYW5zZm9ybWF0aW9uIHRvIFNWR1xuXHQgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+P30gbWF0cml4XG5cdCAqL1xuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0dGhpcy5fcmVuZGVyZXIudHJhbnNmb3JtUGF0aCh0aGlzLCBtYXRyaXgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gcmVzZXQgdHJhbnNmb3JtIG1hdHJpeFxuXHRcdFx0XHR0aGlzLl9yZW5kZXJlci5fcmVzZXRUcmFuc2Zvcm1QYXRoKHRoaXMpO1xuXHRcdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBmZWF0dXJlIHdhcyBkcmFnZ2VkLCB0aGF0J2xsIHN1cHJlc3MgdGhlIGNsaWNrIGV2ZW50XG5cdCAqIG9uIG1vdXNldXAuIFRoYXQgZml4ZXMgcG9wdXBzIGZvciBleGFtcGxlXG5cdCAqXG5cdCAqIEBwYXJhbSAge01vdXNlRXZlbnR9IGVcblx0ICovXG5cdF9vbk1vdXNlQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5tb3ZlZCgpKSB8fFxuXHRcdFx0KHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92ZWQoKSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9maXJlTW91c2VFdmVudChlKTtcblx0fVxuXG59KTtcbnZhciBFTkQgPSB7XG4gIG1vdXNlZG93bjogICAgICdtb3VzZXVwJyxcbiAgdG91Y2hzdGFydDogICAgJ3RvdWNoZW5kJyxcbiAgcG9pbnRlcmRvd246ICAgJ3RvdWNoZW5kJyxcbiAgTVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xufTtcblxudmFyIE1PVkUgPSB7XG4gIG1vdXNlZG93bjogICAgICdtb3VzZW1vdmUnLFxuICB0b3VjaHN0YXJ0OiAgICAndG91Y2htb3ZlJyxcbiAgcG9pbnRlcmRvd246ICAgJ3RvdWNobW92ZScsXG4gIE1TUG9pbnRlckRvd246ICd0b3VjaG1vdmUnXG59O1xuXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciBkeCA9IGEueCAtIGIueCwgZHkgPSBhLnkgLSBiLnk7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xufVxuXG4vKipcbiAqIERyYWcgaGFuZGxlclxuICogQGNsYXNzIEwuUGF0aC5EcmFnXG4gKiBAZXh0ZW5kcyB7TC5IYW5kbGVyfVxuICovXG5MLkhhbmRsZXIuUGF0aERyYWcgPSBMLkhhbmRsZXIuZXh0ZW5kKCAvKiogQGxlbmRzICBMLlBhdGguRHJhZy5wcm90b3R5cGUgKi8ge1xuXG4gIHN0YXRpY3M6IHtcbiAgICBEUkFHR0lOR19DTFM6ICdsZWFmbGV0LXBhdGgtZHJhZ2dhYmxlJyxcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtMLlBhdGh9IHBhdGhcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TC5QYXRofVxuICAgICAqL1xuICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5LjxOdW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX21hdHJpeCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TC5Qb2ludH1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGFydFBvaW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtMLlBvaW50fVxuICAgICAqL1xuICAgIHRoaXMuX2RyYWdTdGFydFBvaW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX21hcERyYWdnaW5nV2FzRW5hYmxlZCA9IGZhbHNlO1xuXG4gIH0sXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBkcmFnZ2luZ1xuICAgKi9cbiAgYWRkSG9va3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BhdGgub24oJ21vdXNlZG93bicsIHRoaXMuX29uRHJhZ1N0YXJ0LCB0aGlzKTtcblxuICAgIHRoaXMuX3BhdGgub3B0aW9ucy5jbGFzc05hbWUgPSB0aGlzLl9wYXRoLm9wdGlvbnMuY2xhc3NOYW1lID9cbiAgICAgICAgKHRoaXMuX3BhdGgub3B0aW9ucy5jbGFzc05hbWUgKyAnICcgKyBMLkhhbmRsZXIuUGF0aERyYWcuRFJBR0dJTkdfQ0xTKSA6XG4gICAgICAgICBMLkhhbmRsZXIuUGF0aERyYWcuRFJBR0dJTkdfQ0xTO1xuXG4gICAgaWYgKHRoaXMuX3BhdGguX3BhdGgpIHtcbiAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9wYXRoLl9wYXRoLCBMLkhhbmRsZXIuUGF0aERyYWcuRFJBR0dJTkdfQ0xTKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc2FibGUgZHJhZ2dpbmdcbiAgICovXG4gIHJlbW92ZUhvb2tzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wYXRoLm9mZignbW91c2Vkb3duJywgdGhpcy5fb25EcmFnU3RhcnQsIHRoaXMpO1xuXG4gICAgdGhpcy5fcGF0aC5vcHRpb25zLmNsYXNzTmFtZSA9IHRoaXMuX3BhdGgub3B0aW9ucy5jbGFzc05hbWVcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxzKycgKyBMLkhhbmRsZXIuUGF0aERyYWcuRFJBR0dJTkdfQ0xTKSwgJycpO1xuICAgIGlmICh0aGlzLl9wYXRoLl9wYXRoKSB7XG4gICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fcGF0aC5fcGF0aCwgTC5IYW5kbGVyLlBhdGhEcmFnLkRSQUdHSU5HX0NMUyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgbW92ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRoLl9kcmFnTW92ZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGRyYWdcbiAgICogQHBhcmFtICB7TC5Nb3VzZUV2ZW50fSBldnRcbiAgICovXG4gIF9vbkRyYWdTdGFydDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIGV2ZW50VHlwZSA9IGV2dC5vcmlnaW5hbEV2ZW50Ll9zaW11bGF0ZWQgPyAndG91Y2hzdGFydCcgOiBldnQub3JpZ2luYWxFdmVudC50eXBlO1xuXG4gICAgdGhpcy5fbWFwRHJhZ2dpbmdXYXNFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fc3RhcnRQb2ludCA9IGV2dC5jb250YWluZXJQb2ludC5jbG9uZSgpO1xuICAgIHRoaXMuX2RyYWdTdGFydFBvaW50ID0gZXZ0LmNvbnRhaW5lclBvaW50LmNsb25lKCk7XG4gICAgdGhpcy5fbWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIEwuRG9tRXZlbnQuc3RvcChldnQub3JpZ2luYWxFdmVudCk7XG5cbiAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fcGF0aC5fcmVuZGVyZXIuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcbiAgICBMLkRvbUV2ZW50XG4gICAgICAub24oZG9jdW1lbnQsIE1PVkVbZXZlbnRUeXBlXSwgdGhpcy5fb25EcmFnLCAgICB0aGlzKVxuICAgICAgLm9uKGRvY3VtZW50LCBFTkRbZXZlbnRUeXBlXSwgIHRoaXMuX29uRHJhZ0VuZCwgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5fcGF0aC5fbWFwLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xuICAgICAgLy8gSSBndWVzcyBpdCdzIHJlcXVpcmVkIGJlY2F1c2UgbW91c2Rvd24gZ2V0cyBzaW11bGF0ZWQgd2l0aCBhIGRlbGF5XG4gICAgICAvL3RoaXMuX3BhdGguX21hcC5kcmFnZ2luZy5fZHJhZ2dhYmxlLl9vblVwKGV2dCk7XG5cbiAgICAgIHRoaXMuX3BhdGguX21hcC5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gICAgICB0aGlzLl9tYXBEcmFnZ2luZ1dhc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9wYXRoLl9kcmFnTW92ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLl9wYXRoLl9wb3B1cCkgeyAvLyB0aGF0IG1pZ2h0IGJlIGEgY2FzZSBvbiB0b3VjaCBkZXZpY2VzIGFzIHdlbGxcbiAgICAgIHRoaXMuX3BhdGguX3BvcHVwLl9jbG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcGxhY2VDb29yZEdldHRlcnMoZXZ0KTtcbiAgfSxcblxuICAvKipcbiAgICogRHJhZ2dpbmdcbiAgICogQHBhcmFtICB7TC5Nb3VzZUV2ZW50fSBldnRcbiAgICovXG4gIF9vbkRyYWc6IGZ1bmN0aW9uKGV2dCkge1xuICAgIEwuRG9tRXZlbnQuc3RvcChldnQpO1xuXG4gICAgdmFyIGZpcnN0ID0gKGV2dC50b3VjaGVzICYmIGV2dC50b3VjaGVzLmxlbmd0aCA+PSAxID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpO1xuICAgIHZhciBjb250YWluZXJQb2ludCA9IHRoaXMuX3BhdGguX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChmaXJzdCk7XG5cbiAgICAvLyBza2lwIHRhcHNcbiAgICBpZiAoZXZ0LnR5cGUgPT09ICd0b3VjaG1vdmUnICYmICF0aGlzLl9wYXRoLl9kcmFnTW92ZWQpIHtcbiAgICAgIHZhciB0b3RhbE1vdXNlRHJhZ0Rpc3RhbmNlID0gdGhpcy5fZHJhZ1N0YXJ0UG9pbnQuZGlzdGFuY2VUbyhjb250YWluZXJQb2ludCk7XG4gICAgICBpZiAodG90YWxNb3VzZURyYWdEaXN0YW5jZSA8PSB0aGlzLl9wYXRoLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB4ID0gY29udGFpbmVyUG9pbnQueDtcbiAgICB2YXIgeSA9IGNvbnRhaW5lclBvaW50Lnk7XG5cbiAgICB2YXIgZHggPSB4IC0gdGhpcy5fc3RhcnRQb2ludC54O1xuICAgIHZhciBkeSA9IHkgLSB0aGlzLl9zdGFydFBvaW50Lnk7XG5cbiAgICAvLyBTZW5kIGV2ZW50cyBvbmx5IGlmIHBvaW50IHdhcyBtb3ZlZFxuICAgIGlmIChkeCB8fCBkeSkge1xuICAgICAgaWYgKCF0aGlzLl9wYXRoLl9kcmFnTW92ZWQpIHtcbiAgICAgICAgdGhpcy5fcGF0aC5fZHJhZ01vdmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGF0aC5maXJlKCdkcmFnc3RhcnQnLCBldnQpO1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoYXQgdG8gaGFwcGVuIG9uIGNsaWNrXG4gICAgICAgIHRoaXMuX3BhdGguYnJpbmdUb0Zyb250KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hdHJpeFs0XSArPSBkeDtcbiAgICAgIHRoaXMuX21hdHJpeFs1XSArPSBkeTtcblxuICAgICAgdGhpcy5fc3RhcnRQb2ludC54ID0geDtcbiAgICAgIHRoaXMuX3N0YXJ0UG9pbnQueSA9IHk7XG5cbiAgICAgIHRoaXMuX3BhdGguZmlyZSgncHJlZHJhZycsIGV2dCk7XG4gICAgICB0aGlzLl9wYXRoLl90cmFuc2Zvcm0odGhpcy5fbWF0cml4KTtcbiAgICAgIHRoaXMuX3BhdGguZmlyZSgnZHJhZycsIGV2dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEcmFnZ2luZyBzdG9wcGVkLCBhcHBseVxuICAgKiBAcGFyYW0gIHtMLk1vdXNlRXZlbnR9IGV2dFxuICAgKi9cbiAgX29uRHJhZ0VuZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIGNvbnRhaW5lclBvaW50ID0gdGhpcy5fcGF0aC5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2dCk7XG4gICAgdmFyIG1vdmVkID0gdGhpcy5tb3ZlZCgpO1xuXG4gICAgLy8gYXBwbHkgbWF0cml4XG4gICAgaWYgKG1vdmVkKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Qb2ludHModGhpcy5fbWF0cml4KTtcbiAgICAgIHRoaXMuX3BhdGguX3VwZGF0ZVBhdGgoKTtcbiAgICAgIHRoaXMuX3BhdGguX3Byb2plY3QoKTtcbiAgICAgIHRoaXMuX3BhdGguX3RyYW5zZm9ybShudWxsKTtcblxuICAgICAgTC5Eb21FdmVudC5zdG9wKGV2dCk7XG4gICAgfVxuXG5cbiAgICBMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ21vdXNlbW92ZSB0b3VjaG1vdmUnLCB0aGlzLl9vbkRyYWcsICAgIHRoaXMpO1xuICAgIEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCAnbW91c2V1cCB0b3VjaGVuZCcsICAgIHRoaXMuX29uRHJhZ0VuZCwgdGhpcyk7XG5cbiAgICB0aGlzLl9yZXN0b3JlQ29vcmRHZXR0ZXJzKCk7XG5cbiAgICAvLyBjb25zaXN0ZW5jeVxuICAgIGlmIChtb3ZlZCkge1xuICAgICAgdGhpcy5fcGF0aC5maXJlKCdkcmFnZW5kJywge1xuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UodGhpcy5fZHJhZ1N0YXJ0UG9pbnQsIGNvbnRhaW5lclBvaW50KVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGhhY2sgZm9yIHNraXBwaW5nIHRoZSBjbGljayBpbiBjYW52YXMtcmVuZGVyZWQgbGF5ZXJzXG4gICAgICB2YXIgY29udGFpbnMgPSB0aGlzLl9wYXRoLl9jb250YWluc1BvaW50O1xuICAgICAgdGhpcy5fcGF0aC5fY29udGFpbnNQb2ludCA9IEwuVXRpbC5mYWxzZUZuO1xuICAgICAgTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIEwuRG9tRXZlbnQuc2tpcHBlZCh7IHR5cGU6ICdjbGljaycgfSk7XG4gICAgICAgIHRoaXMuX3BhdGguX2NvbnRhaW5zUG9pbnQgPSBjb250YWlucztcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuX21hdHJpeCAgICAgICAgICA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRQb2ludCAgICAgID0gbnVsbDtcbiAgICB0aGlzLl9kcmFnU3RhcnRQb2ludCAgPSBudWxsO1xuICAgIHRoaXMuX3BhdGguX2RyYWdNb3ZlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuX21hcERyYWdnaW5nV2FzRW5hYmxlZCkge1xuICAgICAgaWYgKG1vdmVkKSBMLkRvbUV2ZW50LmZha2VTdG9wKHsgdHlwZTogJ2NsaWNrJyB9KTtcbiAgICAgIHRoaXMuX3BhdGguX21hcC5kcmFnZ2luZy5lbmFibGUoKTtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogQXBwbGllcyB0cmFuc2Zvcm1hdGlvbiwgZG9lcyBpdCBpbiBvbmUgc3dlZXAgZm9yIHBlcmZvcm1hbmNlLFxuICAgKiBzbyBkb24ndCBiZSBzdXJwcmlzZWQgYWJvdXQgdGhlIGNvZGUgcmVwZXRpdGlvbi5cbiAgICpcbiAgICogWyB4IF0gICBbIGEgIGIgIHR4IF0gWyB4IF0gICBbIGEgKiB4ICsgYiAqIHkgKyB0eCBdXG4gICAqIFsgeSBdID0gWyBjICBkICB0eSBdIFsgeSBdID0gWyBjICogeCArIGQgKiB5ICsgdHkgXVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+fSBtYXRyaXhcbiAgICovXG4gIF90cmFuc2Zvcm1Qb2ludHM6IGZ1bmN0aW9uKG1hdHJpeCwgZGVzdCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YXIgaSwgbGVuLCBsYXRsbmc7XG5cbiAgICB2YXIgcHggPSBMLnBvaW50KG1hdHJpeFs0XSwgbWF0cml4WzVdKTtcblxuICAgIHZhciBjcnMgPSBwYXRoLl9tYXAub3B0aW9ucy5jcnM7XG4gICAgdmFyIHRyYW5zZm9ybWF0aW9uID0gY3JzLnRyYW5zZm9ybWF0aW9uO1xuICAgIHZhciBzY2FsZSA9IGNycy5zY2FsZShwYXRoLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgICB2YXIgcHJvamVjdGlvbiA9IGNycy5wcm9qZWN0aW9uO1xuXG4gICAgdmFyIGRpZmYgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShweCwgc2NhbGUpXG4gICAgICAuc3VidHJhY3QodHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0oTC5wb2ludCgwLCAwKSwgc2NhbGUpKTtcbiAgICB2YXIgYXBwbHlUcmFuc2Zvcm0gPSAhZGVzdDtcblxuICAgIHBhdGguX2JvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xuXG4gICAgLy8gY29uc29sZS50aW1lKCd0cmFuc2Zvcm0nKTtcbiAgICAvLyBhbGwgc2hpZnRzIGFyZSBpbi1wbGFjZVxuICAgIGlmIChwYXRoLl9wb2ludCkgeyAvLyBMLkNpcmNsZVxuICAgICAgZGVzdCA9IHByb2plY3Rpb24udW5wcm9qZWN0KFxuICAgICAgICBwcm9qZWN0aW9uLnByb2plY3QocGF0aC5fbGF0bG5nKS5fYWRkKGRpZmYpKTtcbiAgICAgIGlmIChhcHBseVRyYW5zZm9ybSkge1xuICAgICAgICBwYXRoLl9sYXRsbmcgPSBkZXN0O1xuICAgICAgICBwYXRoLl9wb2ludC5fYWRkKHB4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhdGguX3JpbmdzIHx8IHBhdGguX3BhcnRzKSB7IC8vIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgdmFyIHJpbmdzICAgPSBwYXRoLl9yaW5ncyB8fCBwYXRoLl9wYXJ0cztcbiAgICAgIHZhciBsYXRsbmdzID0gcGF0aC5fbGF0bG5ncztcbiAgICAgIGRlc3QgPSBkZXN0IHx8IGxhdGxuZ3M7XG4gICAgICBpZiAoIUwuVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pKSB7IC8vIHBvbHlsaW5lXG4gICAgICAgIGxhdGxuZ3MgPSBbbGF0bG5nc107XG4gICAgICAgIGRlc3QgICAgPSBbZGVzdF07XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBkZXN0W2ldID0gZGVzdFtpXSB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcmluZ3NbaV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIGxhdGxuZyAgICAgPSBsYXRsbmdzW2ldW2pdO1xuICAgICAgICAgIGRlc3RbaV1bal0gPSBwcm9qZWN0aW9uXG4gICAgICAgICAgICAudW5wcm9qZWN0KHByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLl9hZGQoZGlmZikpO1xuICAgICAgICAgIGlmIChhcHBseVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcGF0aC5fYm91bmRzLmV4dGVuZChsYXRsbmdzW2ldW2pdKTtcbiAgICAgICAgICAgIHJpbmdzW2ldW2pdLl9hZGQocHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgICAvLyBjb25zb2xlLnRpbWVFbmQoJ3RyYW5zZm9ybScpO1xuICB9LFxuXG5cblxuICAvKipcbiAgICogSWYgeW91IHdhbnQgdG8gcmVhZCB0aGUgbGF0bG5ncyBkdXJpbmcgdGhlIGRyYWcgLSB5b3VyIHJpZ2h0LFxuICAgKiBidXQgdGhleSBoYXZlIHRvIGJlIHRyYW5zZm9ybWVkXG4gICAqL1xuICBfcmVwbGFjZUNvb3JkR2V0dGVyczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BhdGguZ2V0TGF0TG5nKSB7IC8vIENpcmNsZSwgQ2lyY2xlTWFya2VyXG4gICAgICB0aGlzLl9wYXRoLmdldExhdExuZ18gPSB0aGlzLl9wYXRoLmdldExhdExuZztcbiAgICAgIHRoaXMuX3BhdGguZ2V0TGF0TG5nID0gTC5VdGlsLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdnaW5nLl90cmFuc2Zvcm1Qb2ludHModGhpcy5kcmFnZ2luZy5fbWF0cml4LCB7fSk7XG4gICAgICB9LCB0aGlzLl9wYXRoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BhdGguZ2V0TGF0TG5ncykge1xuICAgICAgdGhpcy5fcGF0aC5nZXRMYXRMbmdzXyA9IHRoaXMuX3BhdGguZ2V0TGF0TG5ncztcbiAgICAgIHRoaXMuX3BhdGguZ2V0TGF0TG5ncyA9IEwuVXRpbC5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnZ2luZy5fdHJhbnNmb3JtUG9pbnRzKHRoaXMuZHJhZ2dpbmcuX21hdHJpeCwgW10pO1xuICAgICAgfSwgdGhpcy5fcGF0aCk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIFB1dCBiYWNrIHRoZSBnZXR0ZXJzXG4gICAqL1xuICBfcmVzdG9yZUNvb3JkR2V0dGVyczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BhdGguZ2V0TGF0TG5nXykge1xuICAgICAgdGhpcy5fcGF0aC5nZXRMYXRMbmcgPSB0aGlzLl9wYXRoLmdldExhdExuZ187XG4gICAgICBkZWxldGUgdGhpcy5fcGF0aC5nZXRMYXRMbmdfO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGF0aC5nZXRMYXRMbmdzXykge1xuICAgICAgdGhpcy5fcGF0aC5nZXRMYXRMbmdzID0gdGhpcy5fcGF0aC5nZXRMYXRMbmdzXztcbiAgICAgIGRlbGV0ZSB0aGlzLl9wYXRoLmdldExhdExuZ3NfO1xuICAgIH1cbiAgfVxuXG59KTtcblxuXG4vKipcbiAqIEBwYXJhbSAge0wuUGF0aH0gbGF5ZXJcbiAqIEByZXR1cm4ge0wuUGF0aH1cbiAqL1xuTC5IYW5kbGVyLlBhdGhEcmFnLm1ha2VEcmFnZ2FibGUgPSBmdW5jdGlvbihsYXllcikge1xuICBsYXllci5kcmFnZ2luZyA9IG5ldyBMLkhhbmRsZXIuUGF0aERyYWcobGF5ZXIpO1xuICByZXR1cm4gbGF5ZXI7XG59O1xuXG5cbi8qKlxuICogQWxzbyBleHBvc2UgYXMgYSBtZXRob2RcbiAqIEByZXR1cm4ge0wuUGF0aH1cbiAqL1xuTC5QYXRoLnByb3RvdHlwZS5tYWtlRHJhZ2dhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBMLkhhbmRsZXIuUGF0aERyYWcubWFrZURyYWdnYWJsZSh0aGlzKTtcbn07XG5cblxuTC5QYXRoLmFkZEluaXRIb29rKGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmRyYWdnYWJsZSkge1xuICAgIC8vIGVuc3VyZSBpbnRlcmFjdGl2ZVxuICAgIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgdGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgTC5IYW5kbGVyLlBhdGhEcmFnLm1ha2VEcmFnZ2FibGUodGhpcyk7XG4gICAgICB0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgdGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gIH1cbn0pO1xuTC5TVkcuaW5jbHVkZSh7XG5cblx0LyoqXG5cdCAqIFJlc2V0IHRyYW5zZm9ybSBtYXRyaXhcblx0ICovXG5cdF9yZXNldFRyYW5zZm9ybVBhdGg6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3RyYW5zZm9ybScsICcnKTtcblx0fSxcblxuXHQvKipcblx0ICogQXBwbGllcyBtYXRyaXggdHJhbnNmb3JtYXRpb24gdG8gU1ZHXG5cdCAqIEBwYXJhbSB7TC5QYXRofSAgICAgICAgIGxheWVyXG5cdCAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj59IG1hdHJpeFxuXHQgKi9cblx0dHJhbnNmb3JtUGF0aDogZnVuY3Rpb24obGF5ZXIsIG1hdHJpeCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICd0cmFuc2Zvcm0nLFxuXHRcdFx0J21hdHJpeCgnICsgbWF0cml4LmpvaW4oJyAnKSArICcpJyk7XG5cdH1cblxufSk7XG5MLlNWRy5pbmNsdWRlKCFMLkJyb3dzZXIudm1sID8ge30gOiB7XG5cblx0LyoqXG5cdCAqIFJlc2V0IHRyYW5zZm9ybSBtYXRyaXhcblx0ICovXG5cdF9yZXNldFRyYW5zZm9ybVBhdGg6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0aWYgKGxheWVyLl9za2V3KSB7XG5cdFx0XHQvLyBzdXBlciBpbXBvcnRhbnQhIHdvcmthcm91bmQgZm9yIGEgJ2p1bXBpbmcnIGdsaXRjaDpcblx0XHRcdC8vIGRpc2FibGUgdHJhbnNmb3JtIGJlZm9yZSByZW1vdmluZyBpdFxuXHRcdFx0bGF5ZXIuX3NrZXcub24gPSBmYWxzZTtcblx0XHRcdGxheWVyLl9wYXRoLnJlbW92ZUNoaWxkKGxheWVyLl9za2V3KTtcblx0XHRcdGxheWVyLl9za2V3ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgbWF0cml4IHRyYW5zZm9ybWF0aW9uIHRvIFZNTFxuXHQgKiBAcGFyYW0ge0wuUGF0aH0gICAgICAgICBsYXllclxuXHQgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+fSBtYXRyaXhcblx0ICovXG5cdHRyYW5zZm9ybVBhdGg6IGZ1bmN0aW9uKGxheWVyLCBtYXRyaXgpIHtcblx0XHR2YXIgc2tldyA9IGxheWVyLl9za2V3O1xuXG5cdFx0aWYgKCFza2V3KSB7XG5cdFx0XHRza2V3ID0gTC5TVkcuY3JlYXRlKCdza2V3Jyk7XG5cdFx0XHRsYXllci5fcGF0aC5hcHBlbmRDaGlsZChza2V3KTtcblx0XHRcdHNrZXcuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xuXHRcdFx0bGF5ZXIuX3NrZXcgPSBza2V3O1xuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBza2V3L3RyYW5zbGF0ZSBzZXBhcmF0ZWx5LCBjYXVzZSBpdCdzIGJyb2tlblxuXHRcdHZhciBtdCA9IG1hdHJpeFswXS50b0ZpeGVkKDgpICsgJyAnICsgbWF0cml4WzFdLnRvRml4ZWQoOCkgKyAnICcgK1xuXHRcdFx0bWF0cml4WzJdLnRvRml4ZWQoOCkgKyAnICcgKyBtYXRyaXhbM10udG9GaXhlZCg4KSArICcgMCAwJztcblx0XHR2YXIgb2Zmc2V0ID0gTWF0aC5mbG9vcihtYXRyaXhbNF0pLnRvRml4ZWQoKSArICcsICcgK1xuXHRcdFx0TWF0aC5mbG9vcihtYXRyaXhbNV0pLnRvRml4ZWQoKSArICcnO1xuXG5cdFx0dmFyIHMgPSB0aGlzLl9wYXRoLnN0eWxlO1xuXHRcdHZhciBsID0gcGFyc2VGbG9hdChzLmxlZnQpO1xuXHRcdHZhciB0ID0gcGFyc2VGbG9hdChzLnRvcCk7XG5cdFx0dmFyIHcgPSBwYXJzZUZsb2F0KHMud2lkdGgpO1xuXHRcdHZhciBoID0gcGFyc2VGbG9hdChzLmhlaWdodCk7XG5cblx0XHRpZiAoaXNOYU4obCkpICAgICAgIGwgPSAwO1xuXHRcdGlmIChpc05hTih0KSkgICAgICAgdCA9IDA7XG5cdFx0aWYgKGlzTmFOKHcpIHx8ICF3KSB3ID0gMTtcblx0XHRpZiAoaXNOYU4oaCkgfHwgIWgpIGggPSAxO1xuXG5cdFx0dmFyIG9yaWdpbiA9ICgtbCAvIHcgLSAwLjUpLnRvRml4ZWQoOCkgKyAnICcgKyAoLXQgLyBoIC0gMC41KS50b0ZpeGVkKDgpO1xuXG5cdFx0c2tldy5vbiA9ICdmJztcblx0XHRza2V3Lm1hdHJpeCA9IG10O1xuXHRcdHNrZXcub3JpZ2luID0gb3JpZ2luO1xuXHRcdHNrZXcub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdHNrZXcub24gPSB0cnVlO1xuXHR9XG5cbn0pO1xuZnVuY3Rpb24gVFJVRV9GTiAoKSB7IHJldHVybiB0cnVlOyB9XG5cbkwuQ2FudmFzLmluY2x1ZGUoe1xuXG4gIC8qKlxuICAgKiBEbyBub3RoaW5nXG4gICAqIEBwYXJhbSAge0wuUGF0aH0gbGF5ZXJcbiAgICovXG4gIF9yZXNldFRyYW5zZm9ybVBhdGg6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgaWYgKCF0aGlzLl9jb250YWluZXJDb3B5KSByZXR1cm47XG5cbiAgICBkZWxldGUgdGhpcy5fY29udGFpbmVyQ29weTtcblxuICAgIGlmIChsYXllci5fY29udGFpbnNQb2ludF8pIHtcbiAgICAgIGxheWVyLl9jb250YWluc1BvaW50ID0gbGF5ZXIuX2NvbnRhaW5zUG9pbnRfO1xuICAgICAgZGVsZXRlIGxheWVyLl9jb250YWluc1BvaW50XztcblxuICAgICAgdGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEFsZ29yaXRobSBvdXRsaW5lOlxuICAgKlxuICAgKiAxLiBwcmUtdHJhbnNmb3JtIC0gY2xlYXIgdGhlIHBhdGggb3V0IG9mIHRoZSBjYW52YXMsIGNvcHkgY2FudmFzIHN0YXRlXG4gICAqIDIuIGF0IGV2ZXJ5IGZyYW1lOlxuICAgKiAgICAyLjEuIHNhdmVcbiAgICogICAgMi4yLiByZWRyYXcgdGhlIGNhbnZhcyBmcm9tIHNhdmVkIG9uZVxuICAgKiAgICAyLjMuIHRyYW5zZm9ybVxuICAgKiAgICAyLjQuIGRyYXcgcGF0aFxuICAgKiAgICAyLjUuIHJlc3RvcmVcbiAgICogMy4gUmVwZWF0XG4gICAqXG4gICAqIEBwYXJhbSAge0wuUGF0aH0gICAgICAgICBsYXllclxuICAgKiBAcGFyYW0gIHtBcnJheS48TnVtYmVyPn0gbWF0cml4XG4gICAqL1xuICB0cmFuc2Zvcm1QYXRoOiBmdW5jdGlvbihsYXllciwgbWF0cml4KSB7XG4gICAgdmFyIGNvcHkgICA9IHRoaXMuX2NvbnRhaW5lckNvcHk7XG4gICAgdmFyIGN0eCAgICA9IHRoaXMuX2N0eCwgY29weUN0eDtcbiAgICB2YXIgbSAgICAgID0gTC5Ccm93c2VyLnJldGluYSA/IDIgOiAxO1xuICAgIHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgdmFyIHNpemUgICA9IGJvdW5kcy5nZXRTaXplKCk7XG4gICAgdmFyIHBvcyAgICA9IGJvdW5kcy5taW47XG5cbiAgICBpZiAoIWNvcHkpIHsgLy8gZ2V0IGNvcHkgb2YgYWxsIHJlbmRlcmVkIGxheWVyc1xuICAgICAgY29weSA9IHRoaXMuX2NvbnRhaW5lckNvcHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNvcHlDdHggPSBjb3B5LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvcHkpO1xuXG4gICAgICBjb3B5LndpZHRoICA9IG0gKiBzaXplLng7XG4gICAgICBjb3B5LmhlaWdodCA9IG0gKiBzaXplLnk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZVBhdGgobGF5ZXIpO1xuICAgICAgdGhpcy5fcmVkcmF3KCk7XG5cbiAgICAgIGNvcHlDdHgudHJhbnNsYXRlKG0gKiBib3VuZHMubWluLngsIG0gKiBib3VuZHMubWluLnkpO1xuICAgICAgY29weUN0eC5kcmF3SW1hZ2UodGhpcy5fY29udGFpbmVyLCAwLCAwKTtcbiAgICAgIHRoaXMuX2luaXRQYXRoKGxheWVyKTtcblxuICAgICAgLy8gYXZvaWQgZmxpY2tlcmluZyBiZWNhdXNlIG9mIHRoZSAnbW91c2VvdmVyJ3NcbiAgICAgIGxheWVyLl9jb250YWluc1BvaW50XyA9IGxheWVyLl9jb250YWluc1BvaW50O1xuICAgICAgbGF5ZXIuX2NvbnRhaW5zUG9pbnQgID0gVFJVRV9GTjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5jbGVhclJlY3QocG9zLngsIHBvcy55LCBzaXplLnggKiBtLCBzaXplLnkgKiBtKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fY29udGFpbmVyQ29weSwgMCwgMCwgc2l6ZS54LCBzaXplLnkpO1xuICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCBtYXRyaXgpO1xuXG4gICAgLy8gbm93IGRyYXcgb25lIGxheWVyIG9ubHlcbiAgICB0aGlzLl9kcmF3aW5nID0gdHJ1ZTtcbiAgICBsYXllci5fdXBkYXRlUGF0aCgpO1xuICAgIHRoaXMuX2RyYXdpbmcgPSBmYWxzZTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxufSk7XG4vKipcbiAqIERyYWcvcm90YXRlL3Jlc2l6ZSBoYW5kbGVyIGZvciBbbGVhZmxldF0oaHR0cDovL2xlYWZsZXRqcy5jb20pIHZlY3RvciBmZWF0dXJlcy5cbiAqXG4gKiBAYXV0aG9yIEFsZXhhbmRlciBNaWxldnNraSA8aW5mb0B3OHIubmFtZT5cbiAqIEBsaWNlbnNlIE1JVFxuICogQHByZXNlcnZlXG4gKi9cbi8qKlxuICogQG5hbWVzcGFjZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuTC5QYXRoVHJhbnNmb3JtID0ge307XG5cbi8qKlxuICogUG9pbnQgb24gdGhlIGxpbmUgc2VnbWVudCBvciBpdHMgZXh0ZW50aW9uXG4gKlxuICogQHBhcmFtICB7TC5Qb2ludH0gc3RhcnRcbiAqIEBwYXJhbSAge0wuUG9pbnR9IGZpbmFsXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBkaXN0UHhcbiAqIEByZXR1cm4ge0wuUG9pbnR9XG4gKi9cbkwuUGF0aFRyYW5zZm9ybS5wb2ludE9uTGluZSA9IGZ1bmN0aW9uKHN0YXJ0LCBmaW5hbCwgZGlzdFB4KSB7XG4gIHZhciByYXRpbyA9IDEgKyBkaXN0UHggLyBzdGFydC5kaXN0YW5jZVRvKGZpbmFsKTtcbiAgcmV0dXJuIG5ldyBMLlBvaW50KFxuICAgIHN0YXJ0LnggKyAoZmluYWwueCAtIHN0YXJ0LngpICogcmF0aW8sXG4gICAgc3RhcnQueSArIChmaW5hbC55IC0gc3RhcnQueSkgKiByYXRpb1xuICApO1xufTtcblxuXG4vKipcbiAqIERlZXAgbWVyZ2Ugb2JqZWN0cy5cbiAqL1xuTC5QYXRoVHJhbnNmb3JtLm1lcmdlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpID0gMTtcbiAgdmFyIGtleSwgdmFsO1xuICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgbW9kaWZ5IHNvdXJjZSBlbGVtZW50IGFuZCBpdCdzIHByb3BlcnRpZXNcbiAgLy8gb2JqZWN0cyBhcmUgcGFzc2VkIGJ5IHJlZmVyZW5jZVxuICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuXG4gIHdoaWxlIChvYmopIHtcbiAgICBvYmogPSBhcmd1bWVudHNbaSsrXTtcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhbCA9IG9ialtrZXldO1xuXG4gICAgICBpZiAoaXNPYmplY3QodmFsKSAmJiBpc09iamVjdCh0YXJnZXRba2V5XSkpe1xuICAgICAgICB0YXJnZXRba2V5XSA9IEwuVXRpbC5tZXJnZSh0YXJnZXRba2V5XSwgdmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbi8qKlxuICogQGNsYXNzICBMLk1hdHJpeFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gKiBAcGFyYW0ge051bWJlcn0gYlxuICogQHBhcmFtIHtOdW1iZXJ9IGNcbiAqIEBwYXJhbSB7TnVtYmVyfSBkXG4gKiBAcGFyYW0ge051bWJlcn0gZVxuICogQHBhcmFtIHtOdW1iZXJ9IGZcbiAqL1xuTC5NYXRyaXggPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48TnVtYmVyPn1cbiAgICovXG4gIHRoaXMuX21hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbn07XG5cblxuTC5NYXRyaXgucHJvdG90eXBlID0ge1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0wuUG9pbnR9IHBvaW50XG4gICAqIEByZXR1cm4ge0wuUG9pbnR9XG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBEZXN0cnVjdGl2ZVxuICAgKlxuICAgKiBbIHggXSA9IFsgYSAgYiAgdHggXSBbIHggXSA9IFsgYSAqIHggKyBiICogeSArIHR4IF1cbiAgICogWyB5IF0gPSBbIGMgIGQgIHR5IF0gWyB5IF0gPSBbIGMgKiB4ICsgZCAqIHkgKyB0eSBdXG4gICAqXG4gICAqIEBwYXJhbSAge0wuUG9pbnR9IHBvaW50XG4gICAqIEByZXR1cm4ge0wuUG9pbnR9XG4gICAqL1xuICBfdHJhbnNmb3JtOiBmdW5jdGlvbihwb2ludCkge1xuICAgIHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG4gICAgdmFyIHggPSBwb2ludC54LCB5ID0gcG9pbnQueTtcbiAgICBwb2ludC54ID0gbWF0cml4WzBdICogeCArIG1hdHJpeFsxXSAqIHkgKyBtYXRyaXhbNF07XG4gICAgcG9pbnQueSA9IG1hdHJpeFsyXSAqIHggKyBtYXRyaXhbM10gKiB5ICsgbWF0cml4WzVdO1xuICAgIHJldHVybiBwb2ludDtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtMLlBvaW50fSBwb2ludFxuICAgKiBAcmV0dXJuIHtMLlBvaW50fVxuICAgKi9cbiAgdW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG4gICAgcmV0dXJuIG5ldyBMLlBvaW50KFxuICAgICAgKHBvaW50LnggLyBtYXRyaXhbMF0gLSBtYXRyaXhbNF0pIC8gbWF0cml4WzBdLFxuICAgICAgKHBvaW50LnkgLyBtYXRyaXhbMl0gLSBtYXRyaXhbNV0pIC8gbWF0cml4WzJdXG4gICAgKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtMLk1hdHJpeH1cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuICAgIHJldHVybiBuZXcgTC5NYXRyaXgoXG4gICAgICBtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLFxuICAgICAgbWF0cml4WzNdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XVxuICAgICk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtIHtMLlBvaW50PXxOdW1iZXI9fSB0cmFuc2xhdGVcbiAgICogQHJldHVybiB7TC5NYXRyaXh8TC5Qb2ludH1cbiAgICovXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24odHJhbnNsYXRlKSB7XG4gICAgaWYgKHRyYW5zbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IEwuUG9pbnQodGhpcy5fbWF0cml4WzRdLCB0aGlzLl9tYXRyaXhbNV0pO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZO1xuICAgIGlmICh0eXBlb2YgdHJhbnNsYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhbnNsYXRlWCA9IHRyYW5zbGF0ZVkgPSB0cmFuc2xhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zbGF0ZVggPSB0cmFuc2xhdGUueDtcbiAgICAgIHRyYW5zbGF0ZVkgPSB0cmFuc2xhdGUueTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYWRkKDEsIDAsIDAsIDEsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TC5Qb2ludD18TnVtYmVyPX0gc2NhbGVcbiAgICogQHJldHVybiB7TC5NYXRyaXh8TC5Qb2ludH1cbiAgICovXG4gIHNjYWxlOiBmdW5jdGlvbihzY2FsZSwgb3JpZ2luKSB7XG4gICAgaWYgKHNjYWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLl9tYXRyaXhbMF0sIHRoaXMuX21hdHJpeFszXSk7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlWCwgc2NhbGVZO1xuICAgIG9yaWdpbiA9IG9yaWdpbiB8fCBMLnBvaW50KDAsIDApO1xuICAgIGlmICh0eXBlb2Ygc2NhbGUgPT09ICdudW1iZXInKSB7XG4gICAgICBzY2FsZVggPSBzY2FsZVkgPSBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVYID0gc2NhbGUueDtcbiAgICAgIHNjYWxlWSA9IHNjYWxlLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgICAgIC5fYWRkKHNjYWxlWCwgMCwgMCwgc2NhbGVZLCBvcmlnaW4ueCwgb3JpZ2luLnkpXG4gICAgICAuX2FkZCgxLCAwLCAwLCAxLCAtb3JpZ2luLngsIC1vcmlnaW4ueSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogbTAwICBtMDEgIHggLSBtMDAgKiB4IC0gbTAxICogeVxuICAgKiBtMTAgIG0xMSAgeSAtIG0xMCAqIHggLSBtMTEgKiB5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgIGFuZ2xlXG4gICAqIEBwYXJhbSB7TC5Qb2ludD19IG9yaWdpblxuICAgKiBAcmV0dXJuIHtMLk1hdHJpeH1cbiAgICovXG4gIHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIG9yaWdpbikge1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblxuICAgIG9yaWdpbiA9IG9yaWdpbiB8fCBuZXcgTC5Qb2ludCgwLCAwKTtcblxuICAgIHJldHVybiB0aGlzXG4gICAgICAuX2FkZChjb3MsIHNpbiwgLXNpbiwgY29zLCBvcmlnaW4ueCwgb3JpZ2luLnkpXG4gICAgICAuX2FkZCgxLCAwLCAwLCAxLCAtb3JpZ2luLngsIC1vcmlnaW4ueSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogSW52ZXJ0IHJvdGF0aW9uXG4gICAqIEByZXR1cm4ge0wuTWF0cml4fVxuICAgKi9cbiAgZmxpcDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbWF0cml4WzFdICo9IC0xO1xuICAgIHRoaXMuX21hdHJpeFsyXSAqPSAtMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcnxMLk1hdHJpeH0gYVxuICAgKiBAcGFyYW0ge051bWJlcn0gYlxuICAgKiBAcGFyYW0ge051bWJlcn0gY1xuICAgKiBAcGFyYW0ge051bWJlcn0gZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZlxuICAgKi9cbiAgX2FkZDogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHZhciByZXN1bHQgPSBbW10sIFtdLCBbXV07XG4gICAgdmFyIHNyYyA9IHRoaXMuX21hdHJpeDtcbiAgICB2YXIgbSA9IFtcbiAgICAgIFtzcmNbMF0sIHNyY1syXSwgc3JjWzRdXSxcbiAgICAgIFtzcmNbMV0sIHNyY1szXSwgc3JjWzVdXSxcbiAgICAgIFsgICAgIDAsICAgICAgMCwgICAgIDFdXG4gICAgXTtcbiAgICB2YXIgb3RoZXIgPSBbXG4gICAgICBbYSwgYywgZV0sXG4gICAgICBbYiwgZCwgZl0sXG4gICAgICBbMCwgMCwgMV1cbiAgICBdLCB2YWw7XG5cblxuICAgIGlmIChhICYmIGEgaW5zdGFuY2VvZiBMLk1hdHJpeCkge1xuICAgICAgc3JjID0gYS5fbWF0cml4O1xuICAgICAgb3RoZXIgPSBbXG4gICAgICAgIFtzcmNbMF0sIHNyY1syXSwgc3JjWzRdXSxcbiAgICAgICAgW3NyY1sxXSwgc3JjWzNdLCBzcmNbNV1dLFxuICAgICAgICBbICAgICAwLCAgICAgIDAsICAgICAxXV07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgIHZhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgMzsgaysrKSB7XG4gICAgICAgICAgdmFsICs9IG1baV1ba10gKiBvdGhlcltrXVtqXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbaV1bal0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWF0cml4ID0gW1xuICAgICAgcmVzdWx0WzBdWzBdLCByZXN1bHRbMV1bMF0sIHJlc3VsdFswXVsxXSxcbiAgICAgIHJlc3VsdFsxXVsxXSwgcmVzdWx0WzBdWzJdLCByZXN1bHRbMV1bMl1cbiAgICBdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cblxufTtcblxuXG5MLm1hdHJpeCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgcmV0dXJuIG5ldyBMLk1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKTtcbn07XG5cblxuLyoqXG4gKiBNYXJrZXIgaGFuZGxlclxuICogQGV4dGVuZHMge0wuQ2lyY2xlTWFya2VyfVxuICovXG5MLlBhdGhUcmFuc2Zvcm0uSGFuZGxlID0gTC5DaXJjbGVNYXJrZXIuZXh0ZW5kKHtcbiAgb3B0aW9uczoge1xuICAgIGNsYXNzTmFtZTogJ2xlYWZsZXQtcGF0aC10cmFuc2Zvcm0taGFuZGxlcidcbiAgfSxcblxuICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgIEwuQ2lyY2xlTWFya2VyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgaWYgKHRoaXMuX3BhdGggJiYgdGhpcy5vcHRpb25zLnNldEN1cnNvcikgeyAvLyBTVkcvVk1MXG4gICAgICB0aGlzLl9wYXRoLnN0eWxlLmN1cnNvciA9IEwuUGF0aFRyYW5zZm9ybS5IYW5kbGUuQ3Vyc29yc0J5VHlwZVtcbiAgICAgICAgdGhpcy5vcHRpb25zLmluZGV4XG4gICAgICBdO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuTC5QYXRoVHJhbnNmb3JtLkhhbmRsZS5DdXJzb3JzQnlUeXBlID0gW1xuICAnbmVzdy1yZXNpemUnLCAnbndzZS1yZXNpemUnLCAnbmVzdy1yZXNpemUnLCAnbndzZS1yZXNpemUnXG5dO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge0wuSGFuZGxlci5QYXRoVHJhbnNmb3JtLkhhbmRsZX1cbiAqL1xuTC5QYXRoVHJhbnNmb3JtLlJvdGF0ZUhhbmRsZSA9IEwuUGF0aFRyYW5zZm9ybS5IYW5kbGUuZXh0ZW5kKHtcbiAgb3B0aW9uczoge1xuICAgIGNsYXNzTmFtZTogJ2xlYWZsZXQtcGF0aC10cmFuc2Zvcm0taGFuZGxlciB0cmFuc2Zvcm0taGFuZGxlci0tcm90YXRlJ1xuICB9LFxuXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgTC5DaXJjbGVNYXJrZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICBpZiAodGhpcy5fcGF0aCAmJiB0aGlzLm9wdGlvbnMuc2V0Q3Vyc29yKSB7IC8vIFNWRy9WTUxcbiAgICAgIHRoaXMuX3BhdGguc3R5bGUuY3Vyc29yID0gJ2FsbC1zY3JvbGwnO1xuICAgIH1cbiAgfVxufSk7XG5cbkwuSGFuZGxlci5QYXRoVHJhbnNmb3JtID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cbiAgb3B0aW9uczoge1xuICAgIHJvdGF0aW9uOiB0cnVlLFxuICAgIHNjYWxpbmc6ICB0cnVlLFxuICAgIHVuaWZvcm1TY2FsaW5nOiB0cnVlLFxuICAgIG1heFpvb206ICAyMixcblxuICAgIC8vIGVkZ2UgaGFuZGxlcnNcbiAgICBoYW5kbGVyT3B0aW9uczoge1xuICAgICAgcmFkaXVzOiAgICAgIDUsXG4gICAgICBmaWxsQ29sb3I6ICAgJyNmZmZmZmYnLFxuICAgICAgY29sb3I6ICAgICAgICcjMjAyMDIwJyxcbiAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgd2VpZ2h0OiAgICAgIDIsXG4gICAgICBvcGFjaXR5OiAgICAgMC43LFxuICAgICAgc2V0Q3Vyc29yOiAgIHRydWVcbiAgICB9LFxuXG4gICAgLy8gcmVjdGFuZ2xlXG4gICAgYm91bmRzT3B0aW9uczoge1xuICAgICAgd2VpZ2h0OiAgICAxLFxuICAgICAgb3BhY2l0eTogICAxLFxuICAgICAgZGFzaEFycmF5OiBbMywgM10sXG4gICAgICBmaWxsOiAgICAgIGZhbHNlXG4gICAgfSxcblxuICAgIC8vIHJvdGF0aW9uIGhhbmRsZXJcbiAgICByb3RhdGVIYW5kbGVPcHRpb25zOiB7XG4gICAgICB3ZWlnaHQ6ICAgIDEsXG4gICAgICBvcGFjaXR5OiAgIDEsXG4gICAgICBzZXRDdXJzb3I6IHRydWVcbiAgICB9LFxuICAgIC8vIHJvdGF0aW9uIGhhbmRsZSBsZW5ndGhcbiAgICBoYW5kbGVMZW5ndGg6IDIwLFxuXG4gICAgLy8gbWF5YmUgSSdsbCBhZGQgc2tld2luZyBpbiB0aGUgZnV0dXJlXG4gICAgZWRnZXNDb3VudDogICA0LFxuXG4gICAgaGFuZGxlQ2xhc3M6ICAgICAgIEwuUGF0aFRyYW5zZm9ybS5IYW5kbGUsXG4gICAgcm90YXRlSGFuZGxlQ2xhc3M6IEwuUGF0aFRyYW5zZm9ybS5Sb3RhdGVIYW5kbGVcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAY2xhc3MgTC5IYW5kbGVyLlBhdGhUcmFuc2Zvcm1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge0wuUGF0aH0gcGF0aFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIHJlZmVyZW5jZXNcbiAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICB0aGlzLl9tYXAgID0gbnVsbDtcblxuICAgIC8vIGhhbmRsZXJzXG4gICAgdGhpcy5fYWN0aXZlTWFya2VyICAgPSBudWxsO1xuICAgIHRoaXMuX29yaWdpbk1hcmtlciAgID0gbnVsbDtcbiAgICB0aGlzLl9yb3RhdGlvbk1hcmtlciA9IG51bGw7XG5cbiAgICAvLyBvcmlnaW5zICYgdGVtcG9yYXJ5IHN0YXRlXG4gICAgdGhpcy5fcm90YXRpb25PcmlnaW4gICA9IG51bGw7XG4gICAgdGhpcy5fc2NhbGVPcmlnaW4gICAgICA9IG51bGw7XG4gICAgdGhpcy5fYW5nbGUgICAgICAgICAgICA9IDA7XG4gICAgdGhpcy5fc2NhbGUgICAgICAgICAgICA9IEwucG9pbnQoMSwgMSk7XG4gICAgdGhpcy5faW5pdGlhbERpc3QgICAgICA9IDA7XG4gICAgdGhpcy5faW5pdGlhbERpc3RYICAgICA9IDA7XG4gICAgdGhpcy5faW5pdGlhbERpc3RZICAgICA9IDA7XG4gICAgdGhpcy5fcm90YXRpb25TdGFydCAgICA9IG51bGw7XG4gICAgdGhpcy5fcm90YXRpb25PcmlnaW5QdCA9IG51bGw7XG5cbiAgICAvLyBwcmV2aWV3IGFuZCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgdGhpcy5fbWF0cml4ICAgICAgICAgID0gbmV3IEwuTWF0cml4KDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHRoaXMuX3Byb2plY3RlZE1hdHJpeCA9IG5ldyBMLk1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgIC8vIHVpIGVsZW1lbnRzXG4gICAgdGhpcy5faGFuZGxlcnNHcm91cCAgPSBudWxsO1xuICAgIHRoaXMuX3JlY3QgICAgICAgICAgID0gbnVsbDtcbiAgICB0aGlzLl9oYW5kbGVycyAgICAgICA9IFtdO1xuICAgIHRoaXMuX2hhbmRsZUxpbmUgICAgID0gbnVsbDtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcG9seWdvbiBpcyBub3QgcmVuZGVyZWQsIHlvdSBjYW4gdHJhbnNmb3JtIGl0IHlvdXJzZWxmXG4gICAqIGluIHRoZSBjb29yZGluYXRlcywgYW5kIGRvIGl0IHByb3Blcmx5LlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAgICovXG4gIGVuYWJsZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9wYXRoLl9tYXApIHtcbiAgICAgIHRoaXMuX21hcCA9IHRoaXMuX3BhdGguX21hcDtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIEwuSGFuZGxlci5wcm90b3R5cGUuZW5hYmxlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEluaXQgaW50ZXJhY3Rpb25zIGFuZCBoYW5kbGVyc1xuICAgKi9cbiAgYWRkSG9va3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NyZWF0ZUhhbmRsZXJzKCk7XG4gICAgdGhpcy5fcGF0aFxuICAgICAgLm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCwgdGhpcylcbiAgICAgIC5vbignZHJhZ2VuZCcsICAgdGhpcy5fb25EcmFnRW5kLCAgIHRoaXMpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBoYW5kbGVyc1xuICAgKi9cbiAgcmVtb3ZlSG9va3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hpZGVIYW5kbGVycygpO1xuICAgIHRoaXMuX3BhdGhcbiAgICAgIC5vZmYoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LCB0aGlzKVxuICAgICAgLm9mZignZHJhZ2VuZCcsICAgdGhpcy5fb25EcmFnRW5kLCAgIHRoaXMpO1xuICAgIHRoaXMuX2hhbmRsZXJzR3JvdXAgPSBudWxsO1xuICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIHRoaXMuX2hhbmRsZXJzID0gW107XG4gIH0sXG5cblxuICAvKipcbiAgICogQ2hhbmdlIGVkaXRpbmcgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBlbmFibGVkID0gdGhpcy5fZW5hYmxlZDtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gTC5QYXRoVHJhbnNmb3JtLm1lcmdlKHt9LFxuICAgICAgTC5IYW5kbGVyLlBhdGhUcmFuc2Zvcm0ucHJvdG90eXBlLm9wdGlvbnMsXG4gICAgICBvcHRpb25zKTtcblxuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gICBhbmdsZVxuICAgKiBAcGFyYW0gIHtMLkxhdExuZ30gb3JpZ2luXG4gICAqIEByZXR1cm4ge0wuSGFuZGxlci5QYXRoVHJhbnNmb3JtfVxuICAgKi9cbiAgcm90YXRlOiBmdW5jdGlvbihhbmdsZSwgb3JpZ2luKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKGFuZ2xlLCBudWxsLCBvcmlnaW4pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0wuUG9pbnR8TnVtYmVyfSBzY2FsZVxuICAgKiBAcGFyYW0gIHtMLkxhdExuZ30gICAgICAgb3JpZ2luXG4gICAqIEByZXR1cm4ge0wuSGFuZGxlci5QYXRoVHJhbnNmb3JtfVxuICAgKi9cbiAgc2NhbGU6IGZ1bmN0aW9uKHNjYWxlLCBvcmlnaW4pIHtcbiAgICBpZiAodHlwZW9mIHNjYWxlID09PSAnbnVtYmVyJykge1xuICAgICAgc2NhbGUgPSBMLnBvaW50KHNjYWxlLCBzY2FsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgwLCBzY2FsZSwgbnVsbCwgb3JpZ2luKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIGFuZ2xlXG4gICAqIEBwYXJhbSAge0wuUG9pbnR9ICAgc2NhbGVcbiAgICogQHBhcmFtICB7TC5MYXRMbmc9fSByb3RhdGlvbk9yaWdpblxuICAgKiBAcGFyYW0gIHtMLkxhdExuZz19IHNjYWxlT3JpZ2luXG4gICAqIEByZXR1cm4ge0wuSGFuZGxlci5QYXRoVHJhbnNmb3JtfVxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbihhbmdsZSwgc2NhbGUsIHJvdGF0aW9uT3JpZ2luLCBzY2FsZU9yaWdpbikge1xuICAgIHZhciBjZW50ZXIgICAgID0gdGhpcy5fcGF0aC5nZXRDZW50ZXIoKTtcbiAgICByb3RhdGlvbk9yaWdpbiA9IHJvdGF0aW9uT3JpZ2luIHx8IGNlbnRlcjtcbiAgICBzY2FsZU9yaWdpbiAgICA9IHNjYWxlT3JpZ2luICAgIHx8IGNlbnRlcjtcbiAgICB0aGlzLl9tYXAgPSB0aGlzLl9wYXRoLl9tYXA7XG4gICAgdGhpcy5fdHJhbnNmb3JtUG9pbnRzKHRoaXMuX3BhdGgsIGFuZ2xlLCBzY2FsZSwgcm90YXRpb25PcmlnaW4sIHNjYWxlT3JpZ2luKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBvbHlnb24gYW5kIGhhbmRsZXJzIHByZXZpZXcsIG5vIHJlcHJvamVjdGlvblxuICAgKi9cbiAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcblxuICAgIC8vIHVwZGF0ZSBoYW5kbGVyc1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyc1tpXTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSB0aGlzLl9vcmlnaW5NYXJrZXIpIHtcbiAgICAgICAgaGFuZGxlci5fcG9pbnQgPSBtYXRyaXgudHJhbnNmb3JtKGhhbmRsZXIuX2luaXRpYWxQb2ludCk7XG4gICAgICAgIGhhbmRsZXIuX3VwZGF0ZVBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtYXRyaXggPSBtYXRyaXguY2xvbmUoKS5mbGlwKCk7XG5cbiAgICB0aGlzLl9hcHBseVRyYW5zZm9ybShtYXRyaXgpO1xuICAgIHRoaXMuX3BhdGguZmlyZSgndHJhbnNmb3JtJywgeyBsYXllcjogdGhpcy5fcGF0aCB9KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtMLk1hdHJpeH0gbWF0cml4XG4gICAqL1xuICBfYXBwbHlUcmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIHRoaXMuX3BhdGguX3RyYW5zZm9ybShtYXRyaXguX21hdHJpeCk7XG4gICAgdGhpcy5fcmVjdC5fdHJhbnNmb3JtKG1hdHJpeC5fbWF0cml4KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucm90YXRpb24pIHtcbiAgICAgIHRoaXMuX2hhbmRsZUxpbmUuX3RyYW5zZm9ybShtYXRyaXguX21hdHJpeCk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEFwcGx5IGZpbmFsIHRyYW5zZm9ybWF0aW9uXG4gICAqL1xuICBfYXBwbHk6IGZ1bmN0aW9uKCkge1xuICAgIC8vY29uc29sZS5ncm91cCgnYXBwbHkgdHJhbnNmb3JtJyk7XG4gICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG4gICAgdmFyIGFuZ2xlID0gdGhpcy5fYW5nbGU7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5fc2NhbGUuY2xvbmUoKTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybUdlb21ldHJpZXMoKTtcblxuICAgIC8vIHVwZGF0ZSBoYW5kbGVyc1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyc1tpXTtcbiAgICAgIGhhbmRsZXIuX2xhdGxuZyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcoaGFuZGxlci5fcG9pbnQpO1xuICAgICAgZGVsZXRlIGhhbmRsZXIuX2luaXRpYWxQb2ludDtcbiAgICAgIGhhbmRsZXIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWF0cml4ID0gTC5tYXRyaXgoMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgdGhpcy5fc2NhbGUgID0gTC5wb2ludCgxLCAxKTtcbiAgICB0aGlzLl9hbmdsZSAgPSAwO1xuXG4gICAgdGhpcy5fdXBkYXRlSGFuZGxlcnMoKTtcblxuICAgIG1hcC5kcmFnZ2luZy5lbmFibGUoKTtcbiAgICB0aGlzLl9wYXRoLmZpcmUoJ3RyYW5zZm9ybWVkJywge1xuICAgICAgbWF0cml4OiBtYXRyaXgsXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICByb3RhdGlvbjogYW5nbGUsXG4gICAgICAvLyBhbmdsZTogYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSksXG4gICAgICBsYXllcjogdGhpcy5fcGF0aFxuICAgIH0pO1xuICAgIC8vIGNvbnNvbGUuZ3JvdXBFbmQoJ2FwcGx5IHRyYW5zZm9ybScpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjb21wbGV0ZWx5IHJlc2V0IGhhbmRsZXJzLCBpZiB5b3UgaGF2ZSBjaGFuZ2VkIHRoZVxuICAgKiBnZW9tZXRyeSBvZiB0cmFuc2Zvcm1lZCBsYXllclxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICBpZiAodGhpcy5fcmVjdCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVyc0dyb3VwLnJlbW92ZUxheWVyKHRoaXMuX3JlY3QpO1xuICAgICAgICB0aGlzLl9yZWN0ID0gdGhpcy5fZ2V0Qm91bmRpbmdQb2x5Z29uKCkuYWRkVG8odGhpcy5faGFuZGxlcnNHcm91cCk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVIYW5kbGVycygpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZSByb3RhdGlvbiBoYW5kbGVycyBwb3NpdGlvblxuICAgKi9cbiAgX3VwZGF0ZUhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGFuZGxlcnNHcm91cCA9IHRoaXMuX2hhbmRsZXJzR3JvdXA7XG5cbiAgICB0aGlzLl9yZWN0U2hhcGUgPSB0aGlzLl9yZWN0LnRvR2VvSlNPTigpO1xuXG4gICAgaWYgKHRoaXMuX2hhbmRsZUxpbmUpIHtcbiAgICAgIHRoaXMuX2hhbmRsZXJzR3JvdXAucmVtb3ZlTGF5ZXIodGhpcy5faGFuZGxlTGluZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JvdGF0aW9uTWFya2VyKSB7XG4gICAgICB0aGlzLl9oYW5kbGVyc0dyb3VwLnJlbW92ZUxheWVyKHRoaXMuX3JvdGF0aW9uTWFya2VyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVMaW5lID0gdGhpcy5fcm90YXRpb25NYXJrZXIgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBoYW5kbGVyc0dyb3VwLnJlbW92ZUxheWVyKHRoaXMuX2hhbmRsZXJzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVIYW5kbGVycygpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBnZW9tZXRyaWVzIHNlcGFyYXRlbHlcbiAgICovXG4gIF90cmFuc2Zvcm1HZW9tZXRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wYXRoLl90cmFuc2Zvcm0obnVsbCk7XG4gICAgdGhpcy5fcmVjdC5fdHJhbnNmb3JtKG51bGwpO1xuXG4gICAgdGhpcy5fdHJhbnNmb3JtUG9pbnRzKHRoaXMuX3BhdGgpO1xuICAgIHRoaXMuX3RyYW5zZm9ybVBvaW50cyh0aGlzLl9yZWN0KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucm90YXRpb24pIHtcbiAgICAgIHRoaXMuX2hhbmRsZUxpbmUuX3RyYW5zZm9ybShudWxsKTtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybVBvaW50cyh0aGlzLl9oYW5kbGVMaW5lLCB0aGlzLl9hbmdsZSwgbnVsbCwgdGhpcy5fb3JpZ2luKTtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVxuICAgKiBAcGFyYW0ge0wuTGF0TG5nPX0gcm90YXRpb25PcmlnaW5cbiAgICogQHBhcmFtIHtMLkxhdExuZz19IHNjYWxlT3JpZ2luXG4gICAqL1xuICBfZ2V0UHJvamVjdGVkTWF0cml4OiBmdW5jdGlvbihhbmdsZSwgc2NhbGUsIHJvdGF0aW9uT3JpZ2luLCBzY2FsZU9yaWdpbikge1xuICAgIHZhciBtYXAgICAgPSB0aGlzLl9tYXA7XG4gICAgdmFyIHpvb20gICA9IG1hcC5nZXRNYXhab29tKCkgfHwgdGhpcy5vcHRpb25zLm1heFpvb207XG4gICAgdmFyIG1hdHJpeCA9IEwubWF0cml4KDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHZhciBvcmlnaW47XG5cbiAgICBhbmdsZSA9IGFuZ2xlIHx8IHRoaXMuX2FuZ2xlIHx8IDA7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCB0aGlzLl9zY2FsZSB8fCBMLnBvaW50KDEsIDEpO1xuXG4gICAgaWYgKCEoc2NhbGUueCA9PT0gMSAmJiBzY2FsZS55ID09PSAxKSkge1xuICAgICAgc2NhbGVPcmlnaW4gPSBzY2FsZU9yaWdpbiB8fCB0aGlzLl9zY2FsZU9yaWdpbjtcbiAgICAgIG9yaWdpbiA9IG1hcC5wcm9qZWN0KHNjYWxlT3JpZ2luLCB6b29tKTtcbiAgICAgIG1hdHJpeCA9IG1hdHJpeFxuICAgICAgICAuX2FkZChMLm1hdHJpeCgxLCAwLCAwLCAxLCBvcmlnaW4ueCwgb3JpZ2luLnkpKVxuICAgICAgICAuX2FkZChMLm1hdHJpeChzY2FsZS54LCAwLCAwLCBzY2FsZS55LCAwLCAwKSlcbiAgICAgICAgLl9hZGQoTC5tYXRyaXgoMSwgMCwgMCwgMSwgLW9yaWdpbi54LCAtb3JpZ2luLnkpKTtcbiAgICB9XG5cbiAgICBpZiAoYW5nbGUpIHtcbiAgICAgIHJvdGF0aW9uT3JpZ2luID0gcm90YXRpb25PcmlnaW4gfHwgdGhpcy5fcm90YXRpb25PcmlnaW47XG4gICAgICBvcmlnaW4gPSBtYXAucHJvamVjdChyb3RhdGlvbk9yaWdpbiwgem9vbSk7XG4gICAgICBtYXRyaXggPSBtYXRyaXgucm90YXRlKGFuZ2xlLCBvcmlnaW4pLmZsaXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0cml4O1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0wuTGF0TG5nfSBsYXRsbmdcbiAgICogQHBhcmFtICB7TC5NYXRyaXh9IG1hdHJpeFxuICAgKiBAcGFyYW0gIHtMLk1hcH0gICAgbWFwXG4gICAqIEBwYXJhbSAge051bWJlcn0gICB6b29tXG4gICAqIEByZXR1cm4ge0wuTGF0TG5nfVxuICAgKi9cbiAgX3RyYW5zZm9ybVBvaW50OiBmdW5jdGlvbihsYXRsbmcsIG1hdHJpeCwgbWFwLCB6b29tKSB7XG4gICAgcmV0dXJuIG1hcC51bnByb2plY3QobWF0cml4LnRyYW5zZm9ybShcbiAgICAgIG1hcC5wcm9qZWN0KGxhdGxuZywgem9vbSkpLCB6b29tKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRyYW5zZm9ybWF0aW9uLCBkb2VzIGl0IGluIG9uZSBzd2VlcCBmb3IgcGVyZm9ybWFuY2UsXG4gICAqIHNvIGRvbid0IGJlIHN1cnByaXNlZCBhYm91dCB0aGUgY29kZSByZXBldGl0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0wuUGF0aH0gICAgcGF0aFxuICAgKiBAcGFyYW0ge051bWJlcj19ICAgYW5nbGVcbiAgICogQHBhcmFtIHtMLlBvaW50PX0gIHNjYWxlXG4gICAqIEBwYXJhbSB7TC5MYXRMbmc9fSByb3RhdGlvbk9yaWdpblxuICAgKiBAcGFyYW0ge0wuTGF0TG5nPX0gc2NhbGVPcmlnaW5cbiAgICovXG4gIF90cmFuc2Zvcm1Qb2ludHM6IGZ1bmN0aW9uKHBhdGgsIGFuZ2xlLCBzY2FsZSwgcm90YXRpb25PcmlnaW4sIHNjYWxlT3JpZ2luKSB7XG4gICAgdmFyIG1hcCA9IHBhdGguX21hcDtcbiAgICB2YXIgem9vbSA9IG1hcC5nZXRNYXhab29tKCkgfHwgdGhpcy5vcHRpb25zLm1heFpvb207XG4gICAgdmFyIGksIGxlbjtcblxuICAgIHZhciBwcm9qZWN0ZWRNYXRyaXggPSB0aGlzLl9wcm9qZWN0ZWRNYXRyaXggPVxuICAgICAgdGhpcy5fZ2V0UHJvamVjdGVkTWF0cml4KGFuZ2xlLCBzY2FsZSwgcm90YXRpb25PcmlnaW4sIHNjYWxlT3JpZ2luKTtcbiAgICAvLyBjb25zb2xlLnRpbWUoJ3RyYW5zZm9ybScpO1xuXG4gICAgLy8gYWxsIHNoaWZ0cyBhcmUgaW4tcGxhY2VcbiAgICBpZiAocGF0aC5fcG9pbnQpIHsgLy8gTC5DaXJjbGVcbiAgICAgIHBhdGguX2xhdGxuZyA9IHRoaXMuX3RyYW5zZm9ybVBvaW50KFxuICAgICAgICBwYXRoLl9sYXRsbmcsIHByb2plY3RlZE1hdHJpeCwgbWFwLCB6b29tKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguX3JpbmdzIHx8IHBhdGguX3BhcnRzKSB7IC8vIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgdmFyIHJpbmdzID0gcGF0aC5fcmluZ3M7XG4gICAgICB2YXIgbGF0bG5ncyA9IHBhdGguX2xhdGxuZ3M7XG4gICAgICBwYXRoLl9ib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblxuICAgICAgaWYgKCFMLlV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSkgeyAvLyBwb2x5bGluZVxuICAgICAgICBsYXRsbmdzID0gW2xhdGxuZ3NdO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcmluZ3NbaV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIGxhdGxuZ3NbaV1bal0gPSB0aGlzLl90cmFuc2Zvcm1Qb2ludChcbiAgICAgICAgICAgIGxhdGxuZ3NbaV1bal0sIHByb2plY3RlZE1hdHJpeCwgbWFwLCB6b29tKTtcbiAgICAgICAgICBwYXRoLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZ3NbaV1bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGF0aC5fcmVzZXQoKTtcbiAgICAvL2NvbnNvbGUudGltZUVuZCgndHJhbnNmb3JtJyk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrZXJzIGFuZCBoYW5kbGVzXG4gICAqL1xuICBfY3JlYXRlSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gICAgdGhpcy5faGFuZGxlcnNHcm91cCA9IHRoaXMuX2hhbmRsZXJzR3JvdXAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEwuTGF5ZXJHcm91cCgpLmFkZFRvKG1hcCk7XG4gICAgdGhpcy5fcmVjdCA9IHRoaXMuX3JlY3QgfHxcbiAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0Qm91bmRpbmdQb2x5Z29uKCkuYWRkVG8odGhpcy5faGFuZGxlcnNHcm91cCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNjYWxpbmcpIHtcbiAgICAgIHRoaXMuX2hhbmRsZXJzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5lZGdlc0NvdW50OyBpKyspIHtcbiAgICAgICAgLy8gVE9ETzogYWRkIHN0cmV0Y2hpbmdcbiAgICAgICAgdGhpcy5faGFuZGxlcnMucHVzaChcbiAgICAgICAgICB0aGlzLl9jcmVhdGVIYW5kbGVyKHRoaXMuX3JlY3QuX2xhdGxuZ3NbMF1baV0sIGkgKiAyLCBpKVxuICAgICAgICAgIC5hZGRUbyh0aGlzLl9oYW5kbGVyc0dyb3VwKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIGJvdW5kc1xuICAgIGlmICh0aGlzLm9wdGlvbnMucm90YXRpb24pIHtcbiAgICAgIC8vYWRkIHJvdGF0aW9uIGhhbmRsZXJcbiAgICAgIHRoaXMuX2NyZWF0ZVJvdGF0aW9uSGFuZGxlcnMoKTtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogUm90YXRpb24gbWFya2VyIGFuZCBzbWFsbCBjb25uZWN0aW4gaGFuZGxlXG4gICAqL1xuICBfY3JlYXRlUm90YXRpb25IYW5kbGVyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hcCAgICAgPSB0aGlzLl9tYXA7XG4gICAgdmFyIGxhdGxuZ3MgPSB0aGlzLl9yZWN0Ll9sYXRsbmdzWzBdO1xuXG4gICAgdmFyIGJvdHRvbSAgID0gbmV3IEwuTGF0TG5nKFxuICAgICAgKGxhdGxuZ3NbMF0ubGF0ICsgbGF0bG5nc1szXS5sYXQpIC8gMixcbiAgICAgIChsYXRsbmdzWzBdLmxuZyArIGxhdGxuZ3NbM10ubG5nKSAvIDIpO1xuICAgIC8vIGhlaGUsIHRvcCBpcyBhIHJlc2VydmVkIHdvcmRcbiAgICB2YXIgdG9wUG9pbnQgPSBuZXcgTC5MYXRMbmcoXG4gICAgICAobGF0bG5nc1sxXS5sYXQgKyBsYXRsbmdzWzJdLmxhdCkgLyAyLFxuICAgICAgKGxhdGxuZ3NbMV0ubG5nICsgbGF0bG5nc1syXS5sbmcpIC8gMik7XG5cbiAgICB2YXIgaGFuZGxlclBvc2l0aW9uID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhcbiAgICAgIEwuUGF0aFRyYW5zZm9ybS5wb2ludE9uTGluZShcbiAgICAgICAgbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChib3R0b20pLFxuICAgICAgICBtYXAubGF0TG5nVG9MYXllclBvaW50KHRvcFBvaW50KSxcbiAgICAgICAgdGhpcy5vcHRpb25zLmhhbmRsZUxlbmd0aClcbiAgICApO1xuXG4gICAgdGhpcy5faGFuZGxlTGluZSA9IG5ldyBMLlBvbHlsaW5lKFt0b3BQb2ludCwgaGFuZGxlclBvc2l0aW9uXSxcbiAgICAgIHRoaXMub3B0aW9ucy5yb3RhdGVIYW5kbGVPcHRpb25zKS5hZGRUbyh0aGlzLl9oYW5kbGVyc0dyb3VwKTtcbiAgICB2YXIgUm90YXRlSGFuZGxlQ2xhc3MgPSB0aGlzLm9wdGlvbnMucm90YXRlSGFuZGxlQ2xhc3M7XG4gICAgdGhpcy5fcm90YXRpb25NYXJrZXIgPSBuZXcgUm90YXRlSGFuZGxlQ2xhc3MoaGFuZGxlclBvc2l0aW9uLFxuICAgICAgdGhpcy5vcHRpb25zLmhhbmRsZXJPcHRpb25zKVxuICAgICAgLmFkZFRvKHRoaXMuX2hhbmRsZXJzR3JvdXApXG4gICAgICAub24oJ21vdXNlZG93bicsIHRoaXMuX29uUm90YXRlU3RhcnQsIHRoaXMpO1xuXG4gICAgdGhpcy5fcm90YXRpb25PcmlnaW4gPSBuZXcgTC5MYXRMbmcoXG4gICAgICAodG9wUG9pbnQubGF0ICsgYm90dG9tLmxhdCkgLyAyLFxuICAgICAgKHRvcFBvaW50LmxuZyArIGJvdHRvbS5sbmcpIC8gMlxuICAgICk7XG5cbiAgICB0aGlzLl9oYW5kbGVycy5wdXNoKHRoaXMuX3JvdGF0aW9uTWFya2VyKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtMLkxhdExuZ31cbiAgICovXG4gIF9nZXRSb3RhdGlvbk9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxhdGxuZ3MgPSB0aGlzLl9yZWN0Ll9sYXRsbmdzWzBdO1xuICAgIHZhciBsYiA9IGxhdGxuZ3NbMF07XG4gICAgdmFyIHJ0ID0gbGF0bG5nc1syXTtcblxuICAgIHJldHVybiBuZXcgTC5MYXRMbmcoXG4gICAgICAobGIubGF0ICsgcnQubGF0KSAvIDIsXG4gICAgICAobGIubG5nICsgcnQubG5nKSAvIDJcbiAgICApO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNlY3VyZSB0aGUgcm90YXRpb24gb3JpZ2luXG4gICAqIEBwYXJhbSAge0V2ZW50fSBldnRcbiAgICovXG4gIF9vblJvdGF0ZVN0YXJ0OiBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgbWFwLmRyYWdnaW5nLmRpc2FibGUoKTtcblxuICAgIHRoaXMuX29yaWdpbk1hcmtlciAgICAgPSBudWxsO1xuICAgIHRoaXMuX3JvdGF0aW9uT3JpZ2luUHQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2dldFJvdGF0aW9uT3JpZ2luKCkpO1xuICAgIHRoaXMuX3JvdGF0aW9uU3RhcnQgICAgPSBldnQubGF5ZXJQb2ludDtcbiAgICB0aGlzLl9pbml0aWFsTWF0cml4ICAgID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG5cbiAgICB0aGlzLl9hbmdsZSA9IDA7XG4gICAgdGhpcy5fcGF0aC5fbWFwXG4gICAgICAub24oJ21vdXNlbW92ZScsIHRoaXMuX29uUm90YXRlLCAgICAgdGhpcylcbiAgICAgIC5vbignbW91c2V1cCcsICAgdGhpcy5fb25Sb3RhdGVFbmQsIHRoaXMpO1xuXG4gICAgdGhpcy5fY2FjaGVQb2ludHMoKTtcbiAgICB0aGlzLl9wYXRoXG4gICAgICAuZmlyZSgndHJhbnNmb3Jtc3RhcnQnLCAgIHsgbGF5ZXI6IHRoaXMuX3BhdGggfSlcbiAgICAgIC5maXJlKCdyb3RhdGVzdGFydCcsIHsgbGF5ZXI6IHRoaXMuX3BhdGgsIHJvdGF0aW9uOiAwIH0pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0V2ZW50fSBldnRcbiAgICovXG4gIF9vblJvdGF0ZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIHBvcyA9IGV2dC5sYXllclBvaW50O1xuICAgIHZhciBwcmV2aW91cyA9IHRoaXMuX3JvdGF0aW9uU3RhcnQ7XG4gICAgdmFyIG9yaWdpbiAgID0gdGhpcy5fcm90YXRpb25PcmlnaW5QdDtcblxuICAgIC8vIHJvdGF0aW9uIHN0ZXAgYW5nbGVcbiAgICB0aGlzLl9hbmdsZSA9IE1hdGguYXRhbjIocG9zLnkgLSBvcmlnaW4ueSwgcG9zLnggLSBvcmlnaW4ueCkgLVxuICAgICAgICAgICAgICAgICAgTWF0aC5hdGFuMihwcmV2aW91cy55IC0gb3JpZ2luLnksIHByZXZpb3VzLnggLSBvcmlnaW4ueCk7XG5cbiAgICB0aGlzLl9tYXRyaXggPSB0aGlzLl9pbml0aWFsTWF0cml4XG4gICAgICAuY2xvbmUoKVxuICAgICAgLnJvdGF0ZSh0aGlzLl9hbmdsZSwgb3JpZ2luKVxuICAgICAgLmZsaXAoKTtcblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIHRoaXMuX3BhdGguZmlyZSgncm90YXRlJywgeyBsYXllcjogdGhpcy5fcGF0aCwgcm90YXRpb246IHRoaXMuX2FuZ2xlIH0pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0V2ZW50fSBldnRcbiAgICovXG4gIF9vblJvdGF0ZUVuZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgdGhpcy5fcGF0aC5fbWFwXG4gICAgICAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vblJvdGF0ZSwgdGhpcylcbiAgICAgIC5vZmYoJ21vdXNldXAnLCAgIHRoaXMuX29uUm90YXRlRW5kLCB0aGlzKTtcblxuICAgIHRoaXMuX2FwcGx5KCk7XG4gICAgdGhpcy5fcGF0aC5maXJlKCdyb3RhdGVlbmQnLCB7IGxheWVyOiB0aGlzLl9wYXRoLCByb3RhdGlvbjogdGhpcy5fYW5nbGUgfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtICB7RXZlbnR9IGV2dFxuICAgKi9cbiAgX29uU2NhbGVTdGFydDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIG1hcmtlciA9IGV2dC50YXJnZXQ7XG4gICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgIG1hcC5kcmFnZ2luZy5kaXNhYmxlKCk7XG5cbiAgICB0aGlzLl9hY3RpdmVNYXJrZXIgPSBtYXJrZXI7XG5cbiAgICB0aGlzLl9vcmlnaW5NYXJrZXIgPSB0aGlzLl9oYW5kbGVyc1sobWFya2VyLm9wdGlvbnMuaW5kZXggKyAyKSAlIDRdO1xuICAgIHRoaXMuX3NjYWxlT3JpZ2luICA9IHRoaXMuX29yaWdpbk1hcmtlci5nZXRMYXRMbmcoKTtcblxuICAgIHRoaXMuX2luaXRpYWxNYXRyaXggPSB0aGlzLl9tYXRyaXguY2xvbmUoKTtcbiAgICB0aGlzLl9jYWNoZVBvaW50cygpO1xuXG4gICAgdGhpcy5fbWFwXG4gICAgICAub24oJ21vdXNlbW92ZScsIHRoaXMuX29uU2NhbGUsICAgIHRoaXMpXG4gICAgICAub24oJ21vdXNldXAnLCAgIHRoaXMuX29uU2NhbGVFbmQsIHRoaXMpO1xuICAgIHRoaXMuX2luaXRpYWxEaXN0ICA9IHRoaXMuX29yaWdpbk1hcmtlci5fcG9pbnQuZGlzdGFuY2VUbyh0aGlzLl9hY3RpdmVNYXJrZXIuX3BvaW50KTtcbiAgICB0aGlzLl9pbml0aWFsRGlzdFggPSB0aGlzLl9vcmlnaW5NYXJrZXIuX3BvaW50LnggLSB0aGlzLl9hY3RpdmVNYXJrZXIuX3BvaW50Lng7XG4gICAgdGhpcy5faW5pdGlhbERpc3RZID0gdGhpcy5fb3JpZ2luTWFya2VyLl9wb2ludC55IC0gdGhpcy5fYWN0aXZlTWFya2VyLl9wb2ludC55O1xuXG4gICAgdGhpcy5fcGF0aFxuICAgICAgLmZpcmUoJ3RyYW5zZm9ybXN0YXJ0JywgeyBsYXllcjogdGhpcy5fcGF0aCB9KVxuICAgICAgLmZpcmUoJ3NjYWxlc3RhcnQnLCB7IGxheWVyOiB0aGlzLl9wYXRoLCBzY2FsZTogTC5wb2ludCgxLCAxKSB9KTtcblxuICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9oYW5kbGVMaW5lKTtcbiAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fcm90YXRpb25NYXJrZXIpO1xuXG4gICAgLy90aGlzLl9oYW5kbGVMaW5lID0gdGhpcy5fcm90YXRpb25NYXJrZXIgPSBudWxsO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0V2ZW50fSBldnRcbiAgICovXG4gIF9vblNjYWxlOiBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIgb3JpZ2luUG9pbnQgPSB0aGlzLl9vcmlnaW5NYXJrZXIuX3BvaW50O1xuICAgIHZhciByYXRpb1gsIHJhdGlvWTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnVuaWZvcm1TY2FsaW5nKSB7XG4gICAgICByYXRpb1ggPSBvcmlnaW5Qb2ludC5kaXN0YW5jZVRvKGV2dC5sYXllclBvaW50KSAvIHRoaXMuX2luaXRpYWxEaXN0O1xuICAgICAgcmF0aW9ZID0gcmF0aW9YO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXRpb1ggPSAob3JpZ2luUG9pbnQueCAtIGV2dC5sYXllclBvaW50LngpIC8gdGhpcy5faW5pdGlhbERpc3RYO1xuICAgICAgcmF0aW9ZID0gKG9yaWdpblBvaW50LnkgLSBldnQubGF5ZXJQb2ludC55KSAvIHRoaXMuX2luaXRpYWxEaXN0WTtcbiAgICB9XG5cbiAgICB0aGlzLl9zY2FsZSA9IG5ldyBMLlBvaW50KHJhdGlvWCwgcmF0aW9ZKTtcblxuICAgIC8vIHVwZGF0ZSBtYXRyaXhcbiAgICB0aGlzLl9tYXRyaXggPSB0aGlzLl9pbml0aWFsTWF0cml4XG4gICAgICAuY2xvbmUoKVxuICAgICAgLnNjYWxlKHRoaXMuX3NjYWxlLCBvcmlnaW5Qb2ludCk7XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB0aGlzLl9wYXRoLmZpcmUoJ3NjYWxlJywge1xuICAgICAgbGF5ZXI6IHRoaXMuX3BhdGgsIHNjYWxlOiB0aGlzLl9zY2FsZS5jbG9uZSgpIH0pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFNjYWxpbmcgY29tcGxldGVcbiAgICogQHBhcmFtICB7RXZlbnR9IGV2dFxuICAgKi9cbiAgX29uU2NhbGVFbmQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgIHRoaXMuX21hcFxuICAgICAgLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fb25TY2FsZSwgICAgdGhpcylcbiAgICAgIC5vZmYoJ21vdXNldXAnLCAgIHRoaXMuX29uU2NhbGVFbmQsIHRoaXMpO1xuXG4gICAgdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX2hhbmRsZUxpbmUpO1xuICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl9yb3RhdGlvbk1hcmtlcik7XG5cbiAgICB0aGlzLl9hcHBseSgpO1xuICAgIHRoaXMuX3BhdGguZmlyZSgnc2NhbGVlbmQnLCB7XG4gICAgICBsYXllcjogdGhpcy5fcGF0aCwgc2NhbGU6IHRoaXMuX3NjYWxlLmNsb25lKCkgfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQ2FjaGUgY3VycmVudCBoYW5kbGVycyBwb3NpdGlvbnNcbiAgICovXG4gIF9jYWNoZVBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faGFuZGxlcnNHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIGxheWVyLmJyaW5nVG9Gcm9udCgpO1xuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyc1tpXTtcbiAgICAgIGhhbmRsZXIuX2luaXRpYWxQb2ludCA9IGhhbmRsZXIuX3BvaW50LmNsb25lKCk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEJvdW5kaW5nIHBvbHlnb25cbiAgICogQHJldHVybiB7TC5Qb2x5Z29ufVxuICAgKi9cbiAgX2dldEJvdW5kaW5nUG9seWdvbjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3JlY3RTaGFwZSkge1xuICAgICAgcmV0dXJuIEwuR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIoXG4gICAgICAgIHRoaXMuX3JlY3RTaGFwZSwgdGhpcy5vcHRpb25zLmJvdW5kc09wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEwuUmVjdGFuZ2xlKFxuICAgICAgICB0aGlzLl9wYXRoLmdldEJvdW5kcygpLCB0aGlzLm9wdGlvbnMuYm91bmRzT3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjb3JuZXIgbWFya2VyXG4gICAqIEBwYXJhbSAge0wuTGF0TG5nfSBsYXRsbmdcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIHR5cGUgb25lIG9mIEwuSGFuZGxlci5QYXRoVHJhbnNmb3JtLkhhbmRsZXJUeXBlc1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgaW5kZXhcbiAgICogQHJldHVybiB7TC5IYW5kbGVyLlBhdGhUcmFuc2Zvcm0uSGFuZGxlfVxuICAgKi9cbiAgX2NyZWF0ZUhhbmRsZXI6IGZ1bmN0aW9uKGxhdGxuZywgdHlwZSwgaW5kZXgpIHtcbiAgICB2YXIgSGFuZGxlQ2xhc3MgPSB0aGlzLm9wdGlvbnMuaGFuZGxlQ2xhc3M7XG4gICAgdmFyIG1hcmtlciA9IG5ldyBIYW5kbGVDbGFzcyhsYXRsbmcsXG4gICAgICBMLlV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuaGFuZGxlck9wdGlvbnMsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbGVhZmxldC1kcmFnLXRyYW5zZm9ybS1tYXJrZXIgZHJhZy1tYXJrZXItLScgK1xuICAgICAgICAgICAgICAgICAgIGluZGV4ICsgJyBkcmFnLW1hcmtlci0tJyArIHR5cGUsXG4gICAgICAgIGluZGV4OiAgICAgaW5kZXgsXG4gICAgICAgIHR5cGU6ICAgICAgdHlwZVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgbWFya2VyLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9vblNjYWxlU3RhcnQsIHRoaXMpO1xuICAgIHJldHVybiBtYXJrZXI7XG4gIH0sXG5cblxuICAvKipcbiAgICogSGlkZShub3QgcmVtb3ZlKSB0aGUgaGFuZGxlcnMgbGF5ZXJcbiAgICovXG4gIF9oaWRlSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9oYW5kbGVyc0dyb3VwKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBIaWRlIGhhbmRsZXJzIGFuZCByZWN0YW5nbGVcbiAgICovXG4gIF9vbkRyYWdTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faGlkZUhhbmRsZXJzKCk7XG4gIH0sXG5cblxuICAvKipcbiAgICogRHJhZyByZWN0YW5nbGUsIHJlLWNyZWF0ZSBoYW5kbGVyc1xuICAgKi9cbiAgX29uRHJhZ0VuZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzLl9yZWN0O1xuICAgIHZhciBtYXRyaXggPSAoZXZ0LmxheWVyID8gZXZ0LmxheWVyIDogdGhpcy5fcGF0aCkuZHJhZ2dpbmcuX21hdHJpeC5zbGljZSgpO1xuXG4gICAgaWYgKCFyZWN0LmRyYWdnaW5nKSB7XG4gICAgICByZWN0LmRyYWdnaW5nID0gbmV3IEwuSGFuZGxlci5QYXRoRHJhZyhyZWN0KTtcbiAgICB9XG4gICAgcmVjdC5kcmFnZ2luZy5lbmFibGUoKTtcbiAgICB0aGlzLl9tYXAuYWRkTGF5ZXIocmVjdCk7XG4gICAgcmVjdC5kcmFnZ2luZy5fdHJhbnNmb3JtUG9pbnRzKG1hdHJpeCk7XG4gICAgcmVjdC5fdXBkYXRlUGF0aCgpO1xuICAgIHJlY3QuX3Byb2plY3QoKTtcbiAgICBcbiAgICByZWN0LmRyYWdnaW5nLmRpc2FibGUoKTtcblxuICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl9oYW5kbGVyc0dyb3VwKTtcbiAgICB0aGlzLl91cGRhdGVIYW5kbGVycygpO1xuXG4gICAgdGhpcy5fcGF0aC5maXJlKCd0cmFuc2Zvcm1lZCcsIHtcbiAgICAgIHNjYWxlOiBMLnBvaW50KDEsIDEpLFxuICAgICAgcm90YXRpb246IDAsXG4gICAgICBtYXRyaXg6IEwubWF0cml4LmFwcGx5KHVuZGVmaW5lZCwgbWF0cml4KSxcbiAgICAgIHRyYW5zbGF0ZTogTC5wb2ludChtYXRyaXhbNF0sIG1hdHJpeFs1XSksXG4gICAgICBsYXllcjogdGhpcy5fcGF0aFxuICAgIH0pO1xuICB9XG59KTtcblxuXG5MLlBhdGguYWRkSW5pdEhvb2soZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMudHJhbnNmb3JtKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBuZXcgTC5IYW5kbGVyLlBhdGhUcmFuc2Zvcm0odGhpcywgdGhpcy5vcHRpb25zLnRyYW5zZm9ybSk7XG4gIH1cbn0pO1xuXG5cbmV4cG9ydCB7TH07Il19\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _vue2Leaflet = __webpack_require__(5);\n\n__webpack_require__(1);\n\nvar props = {\n  latLngs: {\n    type: Array,\n    default: function _default() {\n      return [];\n    }\n  },\n  draggable: {\n    type: Boolean,\n    custom: true,\n    default: true\n  },\n  transform: {\n    type: Boolean,\n    custom: true,\n    default: true\n  },\n  rotation: {\n    type: Boolean,\n    custom: true,\n    default: true\n  },\n  scaling: {\n    type: Boolean,\n    custom: true,\n    default: true\n  },\n  options: {\n    type: Object,\n    default: function _default() {\n      return {};\n    }\n  },\n  handleOptions: {\n    type: Object,\n    default: function _default() {\n      return {};\n    }\n  }\n};\nexports.default = {\n  name: 'LPathTransform',\n  props: props,\n  mixins: [_vue2Leaflet.Polygon],\n  data: function data() {\n    return {\n      ready: false\n    };\n  },\n  mounted: function mounted() {\n    var options = (0, _vue2Leaflet.optionsMerger)(this.polygonOptions, this);\n    this.mapObject = L.polygon(this.latLngs, options);\n    L.DomEvent.on(this.mapObject, this.$listeners);\n    (0, _vue2Leaflet.propsBinder)(this, this.mapObject, this.$options.props);\n    this.ready = true;\n    this.parentContainer = (0, _vue2Leaflet.findRealParent)(this.$parent);\n    this.parentContainer.addLayer(this, !this.visible);\n\n    if (this.transform) {\n      this.mapObject.setOptions({\n        rotation: this.rotation,\n        scaling: this.scaling,\n        handlerOptions: this.handlerOptions\n      }).enable();\n    }\n  },\n\n  methods: {\n    setDraggable: function setDraggable(newVal, oldVal) {\n      if (this.mapObject.dragging) {\n        newVal ? this.mapObject.dragging.enable() : this.mapObject.dragging.disable();\n      }\n    },\n    setVisible: function setVisible(newVal, oldVal) {\n      if (newVal == oldVal) return;\n      if (this.mapObject) {\n        if (newVal) {\n          this.parentContainer.addLayer(this);\n        } else {\n          this.parentContainer.removeLayer(this);\n        }\n      }\n    },\n    setLatLng: function setLatLng(newVal) {\n      if (newVal == null) {\n        return;\n      }\n      if (this.mapObject) {\n        var oldLatLng = this.mapObject.getLatLng();\n        var newLatLng = {\n          lat: newVal[0] || newVal.lat,\n          lng: newVal[1] || newVal.lng\n        };\n        if (newLatLng.lat != oldLatLng.lat || newLatLng.lng != oldLatLng.lng) {\n          this.mapObject.setLatLng(newLatLng);\n        }\n      }\n    }\n  }\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticStyle: {\n      \"display\": \"none\"\n    }\n  }, [(_vm.ready) ? _vm._t(\"default\") : _vm._e()], 2)\n},staticRenderFns: []}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"vue2-leaflet\");\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// Vue2LeafletPathTransform.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 518866cecc7ae8f13455","var Component = require(\"!./node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!./node_modules/vue-loader/lib/selector?type=script&index=0!./Vue2LeafletPathTransform.vue\"),\n  /* template */\n  require(\"!!./node_modules/vue-loader/lib/template-compiler?id=data-v-54ea6851!./node_modules/vue-loader/lib/selector?type=template&index=0!./Vue2LeafletPathTransform.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Vue2LeafletPathTransform.vue\n// module id = 0\n// module chunks = 0","\n/**\n * Leaflet vector features drag functionality\n * @author Alexander Milevski <info@w8r.name>\n * @preserve\n */\n\n/**\n * Matrix transform path for SVG/VML\n * Renderer-independent\n */\nL.Path.include({\n\n\t/**\n\t * Applies matrix transformation to SVG\n\t * @param {Array.<Number>?} matrix\n\t */\n\t_transform: function(matrix) {\n\t\tif (this._renderer) {\n\t\t\tif (matrix) {\n\t\t\t\tthis._renderer.transformPath(this, matrix);\n\t\t\t} else {\n\t\t\t\t// reset transform matrix\n\t\t\t\tthis._renderer._resetTransformPath(this);\n\t\t\t\tthis._update();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * Check if the feature was dragged, that'll supress the click event\n\t * on mouseup. That fixes popups for example\n\t *\n\t * @param  {MouseEvent} e\n\t */\n\t_onMouseClick: function(e) {\n\t\tif ((this.dragging && this.dragging.moved()) ||\n\t\t\t(this._map.dragging && this._map.dragging.moved())) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireMouseEvent(e);\n\t}\n\n});\nvar END = {\n  mousedown:     'mouseup',\n  touchstart:    'touchend',\n  pointerdown:   'touchend',\n  MSPointerDown: 'touchend'\n};\n\nvar MOVE = {\n  mousedown:     'mousemove',\n  touchstart:    'touchmove',\n  pointerdown:   'touchmove',\n  MSPointerDown: 'touchmove'\n};\n\nfunction distance(a, b) {\n  var dx = a.x - b.x, dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Drag handler\n * @class L.Path.Drag\n * @extends {L.Handler}\n */\nL.Handler.PathDrag = L.Handler.extend( /** @lends  L.Path.Drag.prototype */ {\n\n  statics: {\n    DRAGGING_CLS: 'leaflet-path-draggable',\n  },\n\n\n  /**\n   * @param  {L.Path} path\n   * @constructor\n   */\n  initialize: function(path) {\n\n    /**\n     * @type {L.Path}\n     */\n    this._path = path;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this._matrix = null;\n\n    /**\n     * @type {L.Point}\n     */\n    this._startPoint = null;\n\n    /**\n     * @type {L.Point}\n     */\n    this._dragStartPoint = null;\n\n    /**\n     * @type {Boolean}\n     */\n    this._mapDraggingWasEnabled = false;\n\n  },\n\n  /**\n   * Enable dragging\n   */\n  addHooks: function() {\n    this._path.on('mousedown', this._onDragStart, this);\n\n    this._path.options.className = this._path.options.className ?\n        (this._path.options.className + ' ' + L.Handler.PathDrag.DRAGGING_CLS) :\n         L.Handler.PathDrag.DRAGGING_CLS;\n\n    if (this._path._path) {\n      L.DomUtil.addClass(this._path._path, L.Handler.PathDrag.DRAGGING_CLS);\n    }\n  },\n\n  /**\n   * Disable dragging\n   */\n  removeHooks: function() {\n    this._path.off('mousedown', this._onDragStart, this);\n\n    this._path.options.className = this._path.options.className\n      .replace(new RegExp('\\\\s+' + L.Handler.PathDrag.DRAGGING_CLS), '');\n    if (this._path._path) {\n      L.DomUtil.removeClass(this._path._path, L.Handler.PathDrag.DRAGGING_CLS);\n    }\n  },\n\n  /**\n   * @return {Boolean}\n   */\n  moved: function() {\n    return this._path._dragMoved;\n  },\n\n  /**\n   * Start drag\n   * @param  {L.MouseEvent} evt\n   */\n  _onDragStart: function(evt) {\n    var eventType = evt.originalEvent._simulated ? 'touchstart' : evt.originalEvent.type;\n\n    this._mapDraggingWasEnabled = false;\n    this._startPoint = evt.containerPoint.clone();\n    this._dragStartPoint = evt.containerPoint.clone();\n    this._matrix = [1, 0, 0, 1, 0, 0];\n    L.DomEvent.stop(evt.originalEvent);\n\n    L.DomUtil.addClass(this._path._renderer._container, 'leaflet-interactive');\n    L.DomEvent\n      .on(document, MOVE[eventType], this._onDrag,    this)\n      .on(document, END[eventType],  this._onDragEnd, this);\n\n    if (this._path._map.dragging.enabled()) {\n      // I guess it's required because mousdown gets simulated with a delay\n      //this._path._map.dragging._draggable._onUp(evt);\n\n      this._path._map.dragging.disable();\n      this._mapDraggingWasEnabled = true;\n    }\n    this._path._dragMoved = false;\n\n    if (this._path._popup) { // that might be a case on touch devices as well\n      this._path._popup._close();\n    }\n\n    this._replaceCoordGetters(evt);\n  },\n\n  /**\n   * Dragging\n   * @param  {L.MouseEvent} evt\n   */\n  _onDrag: function(evt) {\n    L.DomEvent.stop(evt);\n\n    var first = (evt.touches && evt.touches.length >= 1 ? evt.touches[0] : evt);\n    var containerPoint = this._path._map.mouseEventToContainerPoint(first);\n\n    // skip taps\n    if (evt.type === 'touchmove' && !this._path._dragMoved) {\n      var totalMouseDragDistance = this._dragStartPoint.distanceTo(containerPoint);\n      if (totalMouseDragDistance <= this._path._map.options.tapTolerance) {\n        return;\n      }\n    }\n\n    var x = containerPoint.x;\n    var y = containerPoint.y;\n\n    var dx = x - this._startPoint.x;\n    var dy = y - this._startPoint.y;\n\n    // Send events only if point was moved\n    if (dx || dy) {\n      if (!this._path._dragMoved) {\n        this._path._dragMoved = true;\n        this._path.fire('dragstart', evt);\n        // we don't want that to happen on click\n        this._path.bringToFront();\n      }\n\n      this._matrix[4] += dx;\n      this._matrix[5] += dy;\n\n      this._startPoint.x = x;\n      this._startPoint.y = y;\n\n      this._path.fire('predrag', evt);\n      this._path._transform(this._matrix);\n      this._path.fire('drag', evt);\n    }\n  },\n\n  /**\n   * Dragging stopped, apply\n   * @param  {L.MouseEvent} evt\n   */\n  _onDragEnd: function(evt) {\n    var containerPoint = this._path._map.mouseEventToContainerPoint(evt);\n    var moved = this.moved();\n\n    // apply matrix\n    if (moved) {\n      this._transformPoints(this._matrix);\n      this._path._updatePath();\n      this._path._project();\n      this._path._transform(null);\n\n      L.DomEvent.stop(evt);\n    }\n\n\n    L.DomEvent.off(document, 'mousemove touchmove', this._onDrag,    this);\n    L.DomEvent.off(document, 'mouseup touchend',    this._onDragEnd, this);\n\n    this._restoreCoordGetters();\n\n    // consistency\n    if (moved) {\n      this._path.fire('dragend', {\n        distance: distance(this._dragStartPoint, containerPoint)\n      });\n\n      // hack for skipping the click in canvas-rendered layers\n      var contains = this._path._containsPoint;\n      this._path._containsPoint = L.Util.falseFn;\n      L.Util.requestAnimFrame(function() {\n        L.DomEvent.skipped({ type: 'click' });\n        this._path._containsPoint = contains;\n      }, this);\n    }\n\n    this._matrix          = null;\n    this._startPoint      = null;\n    this._dragStartPoint  = null;\n    this._path._dragMoved = false;\n\n    if (this._mapDraggingWasEnabled) {\n      if (moved) L.DomEvent.fakeStop({ type: 'click' });\n      this._path._map.dragging.enable();\n    }\n  },\n\n\n  /**\n   * Applies transformation, does it in one sweep for performance,\n   * so don't be surprised about the code repetition.\n   *\n   * [ x ]   [ a  b  tx ] [ x ]   [ a * x + b * y + tx ]\n   * [ y ] = [ c  d  ty ] [ y ] = [ c * x + d * y + ty ]\n   *\n   * @param {Array.<Number>} matrix\n   */\n  _transformPoints: function(matrix, dest) {\n    var path = this._path;\n    var i, len, latlng;\n\n    var px = L.point(matrix[4], matrix[5]);\n\n    var crs = path._map.options.crs;\n    var transformation = crs.transformation;\n    var scale = crs.scale(path._map.getZoom());\n    var projection = crs.projection;\n\n    var diff = transformation.untransform(px, scale)\n      .subtract(transformation.untransform(L.point(0, 0), scale));\n    var applyTransform = !dest;\n\n    path._bounds = new L.LatLngBounds();\n\n    // console.time('transform');\n    // all shifts are in-place\n    if (path._point) { // L.Circle\n      dest = projection.unproject(\n        projection.project(path._latlng)._add(diff));\n      if (applyTransform) {\n        path._latlng = dest;\n        path._point._add(px);\n      }\n    } else if (path._rings || path._parts) { // everything else\n      var rings   = path._rings || path._parts;\n      var latlngs = path._latlngs;\n      dest = dest || latlngs;\n      if (!L.Util.isArray(latlngs[0])) { // polyline\n        latlngs = [latlngs];\n        dest    = [dest];\n      }\n      for (i = 0, len = rings.length; i < len; i++) {\n        dest[i] = dest[i] || [];\n        for (var j = 0, jj = rings[i].length; j < jj; j++) {\n          latlng     = latlngs[i][j];\n          dest[i][j] = projection\n            .unproject(projection.project(latlng)._add(diff));\n          if (applyTransform) {\n            path._bounds.extend(latlngs[i][j]);\n            rings[i][j]._add(px);\n          }\n        }\n      }\n    }\n    return dest;\n    // console.timeEnd('transform');\n  },\n\n\n\n  /**\n   * If you want to read the latlngs during the drag - your right,\n   * but they have to be transformed\n   */\n  _replaceCoordGetters: function() {\n    if (this._path.getLatLng) { // Circle, CircleMarker\n      this._path.getLatLng_ = this._path.getLatLng;\n      this._path.getLatLng = L.Util.bind(function() {\n        return this.dragging._transformPoints(this.dragging._matrix, {});\n      }, this._path);\n    } else if (this._path.getLatLngs) {\n      this._path.getLatLngs_ = this._path.getLatLngs;\n      this._path.getLatLngs = L.Util.bind(function() {\n        return this.dragging._transformPoints(this.dragging._matrix, []);\n      }, this._path);\n    }\n  },\n\n\n  /**\n   * Put back the getters\n   */\n  _restoreCoordGetters: function() {\n    if (this._path.getLatLng_) {\n      this._path.getLatLng = this._path.getLatLng_;\n      delete this._path.getLatLng_;\n    } else if (this._path.getLatLngs_) {\n      this._path.getLatLngs = this._path.getLatLngs_;\n      delete this._path.getLatLngs_;\n    }\n  }\n\n});\n\n\n/**\n * @param  {L.Path} layer\n * @return {L.Path}\n */\nL.Handler.PathDrag.makeDraggable = function(layer) {\n  layer.dragging = new L.Handler.PathDrag(layer);\n  return layer;\n};\n\n\n/**\n * Also expose as a method\n * @return {L.Path}\n */\nL.Path.prototype.makeDraggable = function() {\n  return L.Handler.PathDrag.makeDraggable(this);\n};\n\n\nL.Path.addInitHook(function() {\n  if (this.options.draggable) {\n    // ensure interactive\n    this.options.interactive = true;\n\n    if (this.dragging) {\n      this.dragging.enable();\n    } else {\n      L.Handler.PathDrag.makeDraggable(this);\n      this.dragging.enable();\n    }\n  } else if (this.dragging) {\n    this.dragging.disable();\n  }\n});\nL.SVG.include({\n\n\t/**\n\t * Reset transform matrix\n\t */\n\t_resetTransformPath: function(layer) {\n\t\tlayer._path.setAttributeNS(null, 'transform', '');\n\t},\n\n\t/**\n\t * Applies matrix transformation to SVG\n\t * @param {L.Path}         layer\n\t * @param {Array.<Number>} matrix\n\t */\n\ttransformPath: function(layer, matrix) {\n\t\tlayer._path.setAttributeNS(null, 'transform',\n\t\t\t'matrix(' + matrix.join(' ') + ')');\n\t}\n\n});\nL.SVG.include(!L.Browser.vml ? {} : {\n\n\t/**\n\t * Reset transform matrix\n\t */\n\t_resetTransformPath: function(layer) {\n\t\tif (layer._skew) {\n\t\t\t// super important! workaround for a 'jumping' glitch:\n\t\t\t// disable transform before removing it\n\t\t\tlayer._skew.on = false;\n\t\t\tlayer._path.removeChild(layer._skew);\n\t\t\tlayer._skew = null;\n\t\t}\n\t},\n\n\t/**\n\t * Applies matrix transformation to VML\n\t * @param {L.Path}         layer\n\t * @param {Array.<Number>} matrix\n\t */\n\ttransformPath: function(layer, matrix) {\n\t\tvar skew = layer._skew;\n\n\t\tif (!skew) {\n\t\t\tskew = L.SVG.create('skew');\n\t\t\tlayer._path.appendChild(skew);\n\t\t\tskew.style.behavior = 'url(#default#VML)';\n\t\t\tlayer._skew = skew;\n\t\t}\n\n\t\t// handle skew/translate separately, cause it's broken\n\t\tvar mt = matrix[0].toFixed(8) + ' ' + matrix[1].toFixed(8) + ' ' +\n\t\t\tmatrix[2].toFixed(8) + ' ' + matrix[3].toFixed(8) + ' 0 0';\n\t\tvar offset = Math.floor(matrix[4]).toFixed() + ', ' +\n\t\t\tMath.floor(matrix[5]).toFixed() + '';\n\n\t\tvar s = this._path.style;\n\t\tvar l = parseFloat(s.left);\n\t\tvar t = parseFloat(s.top);\n\t\tvar w = parseFloat(s.width);\n\t\tvar h = parseFloat(s.height);\n\n\t\tif (isNaN(l))       l = 0;\n\t\tif (isNaN(t))       t = 0;\n\t\tif (isNaN(w) || !w) w = 1;\n\t\tif (isNaN(h) || !h) h = 1;\n\n\t\tvar origin = (-l / w - 0.5).toFixed(8) + ' ' + (-t / h - 0.5).toFixed(8);\n\n\t\tskew.on = 'f';\n\t\tskew.matrix = mt;\n\t\tskew.origin = origin;\n\t\tskew.offset = offset;\n\t\tskew.on = true;\n\t}\n\n});\nfunction TRUE_FN () { return true; }\n\nL.Canvas.include({\n\n  /**\n   * Do nothing\n   * @param  {L.Path} layer\n   */\n  _resetTransformPath: function(layer) {\n    if (!this._containerCopy) return;\n\n    delete this._containerCopy;\n\n    if (layer._containsPoint_) {\n      layer._containsPoint = layer._containsPoint_;\n      delete layer._containsPoint_;\n\n      this._requestRedraw(layer);\n    }\n  },\n\n\n  /**\n   * Algorithm outline:\n   *\n   * 1. pre-transform - clear the path out of the canvas, copy canvas state\n   * 2. at every frame:\n   *    2.1. save\n   *    2.2. redraw the canvas from saved one\n   *    2.3. transform\n   *    2.4. draw path\n   *    2.5. restore\n   * 3. Repeat\n   *\n   * @param  {L.Path}         layer\n   * @param  {Array.<Number>} matrix\n   */\n  transformPath: function(layer, matrix) {\n    var copy   = this._containerCopy;\n    var ctx    = this._ctx, copyCtx;\n    var m      = L.Browser.retina ? 2 : 1;\n    var bounds = this._bounds;\n    var size   = bounds.getSize();\n    var pos    = bounds.min;\n\n    if (!copy) { // get copy of all rendered layers\n      copy = this._containerCopy = document.createElement('canvas');\n      copyCtx = copy.getContext('2d');\n      // document.body.appendChild(copy);\n\n      copy.width  = m * size.x;\n      copy.height = m * size.y;\n\n      this._removePath(layer);\n      this._redraw();\n\n      copyCtx.translate(m * bounds.min.x, m * bounds.min.y);\n      copyCtx.drawImage(this._container, 0, 0);\n      this._initPath(layer);\n\n      // avoid flickering because of the 'mouseover's\n      layer._containsPoint_ = layer._containsPoint;\n      layer._containsPoint  = TRUE_FN;\n    }\n\n    ctx.save();\n    ctx.clearRect(pos.x, pos.y, size.x * m, size.y * m);\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.restore();\n    ctx.save();\n\n    ctx.drawImage(this._containerCopy, 0, 0, size.x, size.y);\n    ctx.transform.apply(ctx, matrix);\n\n    // now draw one layer only\n    this._drawing = true;\n    layer._updatePath();\n    this._drawing = false;\n\n    ctx.restore();\n  }\n\n});\n/**\n * Drag/rotate/resize handler for [leaflet](http://leafletjs.com) vector features.\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n/**\n * @namespace\n * @type {Object}\n */\nL.PathTransform = {};\n\n/**\n * Point on the line segment or its extention\n *\n * @param  {L.Point} start\n * @param  {L.Point} final\n * @param  {Number}  distPx\n * @return {L.Point}\n */\nL.PathTransform.pointOnLine = function(start, final, distPx) {\n  var ratio = 1 + distPx / start.distanceTo(final);\n  return new L.Point(\n    start.x + (final.x - start.x) * ratio,\n    start.y + (final.y - start.y) * ratio\n  );\n};\n\n\n/**\n * Deep merge objects.\n */\nL.PathTransform.merge = function() {\n  var i = 1;\n  var key, val;\n  var obj = arguments[i];\n\n  function isObject(object) {\n    return Object.prototype.toString.call(object) === '[object Object]';\n  }\n\n  // make sure we don't modify source element and it's properties\n  // objects are passed by reference\n  var target = arguments[0];\n\n  while (obj) {\n    obj = arguments[i++];\n    for (key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      val = obj[key];\n\n      if (isObject(val) && isObject(target[key])){\n        target[key] = L.Util.merge(target[key], val);\n      } else {\n        target[key] = val;\n      }\n    }\n  }\n  return target;\n};\n/**\n * @class  L.Matrix\n *\n * @param {Number} a\n * @param {Number} b\n * @param {Number} c\n * @param {Number} d\n * @param {Number} e\n * @param {Number} f\n */\nL.Matrix = function(a, b, c, d, e, f) {\n\n  /**\n   * @type {Array.<Number>}\n   */\n  this._matrix = [a, b, c, d, e, f];\n};\n\n\nL.Matrix.prototype = {\n\n\n  /**\n   * @param  {L.Point} point\n   * @return {L.Point}\n   */\n  transform: function(point) {\n    return this._transform(point.clone());\n  },\n\n\n  /**\n   * Destructive\n   *\n   * [ x ] = [ a  b  tx ] [ x ] = [ a * x + b * y + tx ]\n   * [ y ] = [ c  d  ty ] [ y ] = [ c * x + d * y + ty ]\n   *\n   * @param  {L.Point} point\n   * @return {L.Point}\n   */\n  _transform: function(point) {\n    var matrix = this._matrix;\n    var x = point.x, y = point.y;\n    point.x = matrix[0] * x + matrix[1] * y + matrix[4];\n    point.y = matrix[2] * x + matrix[3] * y + matrix[5];\n    return point;\n  },\n\n\n  /**\n   * @param  {L.Point} point\n   * @return {L.Point}\n   */\n  untransform: function (point) {\n    var matrix = this._matrix;\n    return new L.Point(\n      (point.x / matrix[0] - matrix[4]) / matrix[0],\n      (point.y / matrix[2] - matrix[5]) / matrix[2]\n    );\n  },\n\n\n  /**\n   * @return {L.Matrix}\n   */\n  clone: function() {\n    var matrix = this._matrix;\n    return new L.Matrix(\n      matrix[0], matrix[1], matrix[2],\n      matrix[3], matrix[4], matrix[5]\n    );\n  },\n\n\n  /**\n   * @param {L.Point=|Number=} translate\n   * @return {L.Matrix|L.Point}\n   */\n  translate: function(translate) {\n    if (translate === undefined) {\n      return new L.Point(this._matrix[4], this._matrix[5]);\n    }\n\n    var translateX, translateY;\n    if (typeof translate === 'number') {\n      translateX = translateY = translate;\n    } else {\n      translateX = translate.x;\n      translateY = translate.y;\n    }\n\n    return this._add(1, 0, 0, 1, translateX, translateY);\n  },\n\n\n  /**\n   * @param {L.Point=|Number=} scale\n   * @return {L.Matrix|L.Point}\n   */\n  scale: function(scale, origin) {\n    if (scale === undefined) {\n      return new L.Point(this._matrix[0], this._matrix[3]);\n    }\n\n    var scaleX, scaleY;\n    origin = origin || L.point(0, 0);\n    if (typeof scale === 'number') {\n      scaleX = scaleY = scale;\n    } else {\n      scaleX = scale.x;\n      scaleY = scale.y;\n    }\n\n    return this\n      ._add(scaleX, 0, 0, scaleY, origin.x, origin.y)\n      ._add(1, 0, 0, 1, -origin.x, -origin.y);\n  },\n\n\n  /**\n   * m00  m01  x - m00 * x - m01 * y\n   * m10  m11  y - m10 * x - m11 * y\n   * @param {Number}   angle\n   * @param {L.Point=} origin\n   * @return {L.Matrix}\n   */\n  rotate: function(angle, origin) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n\n    origin = origin || new L.Point(0, 0);\n\n    return this\n      ._add(cos, sin, -sin, cos, origin.x, origin.y)\n      ._add(1, 0, 0, 1, -origin.x, -origin.y);\n  },\n\n\n  /**\n   * Invert rotation\n   * @return {L.Matrix}\n   */\n  flip: function() {\n    this._matrix[1] *= -1;\n    this._matrix[2] *= -1;\n    return this;\n  },\n\n\n  /**\n   * @param {Number|L.Matrix} a\n   * @param {Number} b\n   * @param {Number} c\n   * @param {Number} d\n   * @param {Number} e\n   * @param {Number} f\n   */\n  _add: function(a, b, c, d, e, f) {\n    var result = [[], [], []];\n    var src = this._matrix;\n    var m = [\n      [src[0], src[2], src[4]],\n      [src[1], src[3], src[5]],\n      [     0,      0,     1]\n    ];\n    var other = [\n      [a, c, e],\n      [b, d, f],\n      [0, 0, 1]\n    ], val;\n\n\n    if (a && a instanceof L.Matrix) {\n      src = a._matrix;\n      other = [\n        [src[0], src[2], src[4]],\n        [src[1], src[3], src[5]],\n        [     0,      0,     1]];\n    }\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        val = 0;\n        for (var k = 0; k < 3; k++) {\n          val += m[i][k] * other[k][j];\n        }\n        result[i][j] = val;\n      }\n    }\n\n    this._matrix = [\n      result[0][0], result[1][0], result[0][1],\n      result[1][1], result[0][2], result[1][2]\n    ];\n    return this;\n  }\n\n\n};\n\n\nL.matrix = function(a, b, c, d, e, f) {\n  return new L.Matrix(a, b, c, d, e, f);\n};\n\n\n/**\n * Marker handler\n * @extends {L.CircleMarker}\n */\nL.PathTransform.Handle = L.CircleMarker.extend({\n  options: {\n    className: 'leaflet-path-transform-handler'\n  },\n\n  onAdd: function (map) {\n    L.CircleMarker.prototype.onAdd.call(this, map);\n    if (this._path && this.options.setCursor) { // SVG/VML\n      this._path.style.cursor = L.PathTransform.Handle.CursorsByType[\n        this.options.index\n      ];\n    }\n  }\n});\n\n\n/**\n * @const\n * @type {Array}\n */\nL.PathTransform.Handle.CursorsByType = [\n  'nesw-resize', 'nwse-resize', 'nesw-resize', 'nwse-resize'\n];\n\n\n/**\n * @extends {L.Handler.PathTransform.Handle}\n */\nL.PathTransform.RotateHandle = L.PathTransform.Handle.extend({\n  options: {\n    className: 'leaflet-path-transform-handler transform-handler--rotate'\n  },\n\n  onAdd: function (map) {\n    L.CircleMarker.prototype.onAdd.call(this, map);\n    if (this._path && this.options.setCursor) { // SVG/VML\n      this._path.style.cursor = 'all-scroll';\n    }\n  }\n});\n\nL.Handler.PathTransform = L.Handler.extend({\n\n  options: {\n    rotation: true,\n    scaling:  true,\n    uniformScaling: true,\n    maxZoom:  22,\n\n    // edge handlers\n    handlerOptions: {\n      radius:      5,\n      fillColor:   '#ffffff',\n      color:       '#202020',\n      fillOpacity: 1,\n      weight:      2,\n      opacity:     0.7,\n      setCursor:   true\n    },\n\n    // rectangle\n    boundsOptions: {\n      weight:    1,\n      opacity:   1,\n      dashArray: [3, 3],\n      fill:      false\n    },\n\n    // rotation handler\n    rotateHandleOptions: {\n      weight:    1,\n      opacity:   1,\n      setCursor: true\n    },\n    // rotation handle length\n    handleLength: 20,\n\n    // maybe I'll add skewing in the future\n    edgesCount:   4,\n\n    handleClass:       L.PathTransform.Handle,\n    rotateHandleClass: L.PathTransform.RotateHandle\n  },\n\n\n  /**\n   * @class L.Handler.PathTransform\n   * @constructor\n   * @param  {L.Path} path\n   */\n  initialize: function(path) {\n    // references\n    this._path = path;\n    this._map  = null;\n\n    // handlers\n    this._activeMarker   = null;\n    this._originMarker   = null;\n    this._rotationMarker = null;\n\n    // origins & temporary state\n    this._rotationOrigin   = null;\n    this._scaleOrigin      = null;\n    this._angle            = 0;\n    this._scale            = L.point(1, 1);\n    this._initialDist      = 0;\n    this._initialDistX     = 0;\n    this._initialDistY     = 0;\n    this._rotationStart    = null;\n    this._rotationOriginPt = null;\n\n    // preview and transform matrix\n    this._matrix          = new L.Matrix(1, 0, 0, 1, 0, 0);\n    this._projectedMatrix = new L.Matrix(1, 0, 0, 1, 0, 0);\n\n    // ui elements\n    this._handlersGroup  = null;\n    this._rect           = null;\n    this._handlers       = [];\n    this._handleLine     = null;\n  },\n\n\n  /**\n   * If the polygon is not rendered, you can transform it yourself\n   * in the coordinates, and do it properly.\n   * @param {Object=} options\n   */\n  enable: function(options) {\n    if (this._path._map) {\n      this._map = this._path._map;\n      if (options) {\n        this.setOptions(options);\n      }\n      L.Handler.prototype.enable.call(this);\n    }\n  },\n\n\n  /**\n   * Init interactions and handlers\n   */\n  addHooks: function() {\n    this._createHandlers();\n    this._path\n      .on('dragstart', this._onDragStart, this)\n      .on('dragend',   this._onDragEnd,   this);\n  },\n\n\n  /**\n   * Remove handlers\n   */\n  removeHooks: function() {\n    this._hideHandlers();\n    this._path\n      .off('dragstart', this._onDragStart, this)\n      .off('dragend',   this._onDragEnd,   this);\n    this._handlersGroup = null;\n    this._rect = null;\n    this._handlers = [];\n  },\n\n\n  /**\n   * Change editing options\n   * @param {Object} options\n   */\n  setOptions: function(options) {\n    var enabled = this._enabled;\n    if (enabled) {\n      this.disable();\n    }\n\n    this.options = L.PathTransform.merge({},\n      L.Handler.PathTransform.prototype.options,\n      options);\n\n    if (enabled) {\n      this.enable();\n    }\n\n    return this;\n  },\n\n\n  /**\n   * @param  {Number}   angle\n   * @param  {L.LatLng} origin\n   * @return {L.Handler.PathTransform}\n   */\n  rotate: function(angle, origin) {\n    return this.transform(angle, null, origin);\n  },\n\n\n  /**\n   * @param  {L.Point|Number} scale\n   * @param  {L.LatLng}       origin\n   * @return {L.Handler.PathTransform}\n   */\n  scale: function(scale, origin) {\n    if (typeof scale === 'number') {\n      scale = L.point(scale, scale);\n    }\n    return this.transform(0, scale, null, origin);\n  },\n\n\n  /**\n   * @param  {Number}    angle\n   * @param  {L.Point}   scale\n   * @param  {L.LatLng=} rotationOrigin\n   * @param  {L.LatLng=} scaleOrigin\n   * @return {L.Handler.PathTransform}\n   */\n  transform: function(angle, scale, rotationOrigin, scaleOrigin) {\n    var center     = this._path.getCenter();\n    rotationOrigin = rotationOrigin || center;\n    scaleOrigin    = scaleOrigin    || center;\n    this._map = this._path._map;\n    this._transformPoints(this._path, angle, scale, rotationOrigin, scaleOrigin);\n    return this;\n  },\n\n\n  /**\n   * Update the polygon and handlers preview, no reprojection\n   */\n  _update: function() {\n    var matrix = this._matrix;\n\n    // update handlers\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      if (handler !== this._originMarker) {\n        handler._point = matrix.transform(handler._initialPoint);\n        handler._updatePath();\n      }\n    }\n\n    matrix = matrix.clone().flip();\n\n    this._applyTransform(matrix);\n    this._path.fire('transform', { layer: this._path });\n  },\n\n\n  /**\n   * @param  {L.Matrix} matrix\n   */\n  _applyTransform: function(matrix) {\n    this._path._transform(matrix._matrix);\n    this._rect._transform(matrix._matrix);\n\n    if (this.options.rotation) {\n      this._handleLine._transform(matrix._matrix);\n    }\n  },\n\n\n  /**\n   * Apply final transformation\n   */\n  _apply: function() {\n    //console.group('apply transform');\n    var map = this._map;\n    var matrix = this._matrix.clone();\n    var angle = this._angle;\n    var scale = this._scale.clone();\n\n    this._transformGeometries();\n\n    // update handlers\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      handler._latlng = map.layerPointToLatLng(handler._point);\n      delete handler._initialPoint;\n      handler.redraw();\n    }\n\n    this._matrix = L.matrix(1, 0, 0, 1, 0, 0);\n    this._scale  = L.point(1, 1);\n    this._angle  = 0;\n\n    this._updateHandlers();\n\n    map.dragging.enable();\n    this._path.fire('transformed', {\n      matrix: matrix,\n      scale: scale,\n      rotation: angle,\n      // angle: angle * (180 / Math.PI),\n      layer: this._path\n    });\n    // console.groupEnd('apply transform');\n  },\n\n\n  /**\n   * Use this method to completely reset handlers, if you have changed the\n   * geometry of transformed layer\n   */\n  reset: function() {\n    if (this._enabled) {\n      if (this._rect) {\n        this._handlersGroup.removeLayer(this._rect);\n        this._rect = this._getBoundingPolygon().addTo(this._handlersGroup);\n      }\n      this._updateHandlers();\n    }\n  },\n\n\n  /**\n   * Recalculate rotation handlers position\n   */\n  _updateHandlers: function() {\n    var handlersGroup = this._handlersGroup;\n\n    this._rectShape = this._rect.toGeoJSON();\n\n    if (this._handleLine) {\n      this._handlersGroup.removeLayer(this._handleLine);\n    }\n\n    if (this._rotationMarker) {\n      this._handlersGroup.removeLayer(this._rotationMarker);\n    }\n\n    this._handleLine = this._rotationMarker = null;\n\n    for (var i = this._handlers.length - 1; i >= 0; i--) {\n      handlersGroup.removeLayer(this._handlers[i]);\n    }\n\n    this._createHandlers();\n  },\n\n\n  /**\n   * Transform geometries separately\n   */\n  _transformGeometries: function() {\n    this._path._transform(null);\n    this._rect._transform(null);\n\n    this._transformPoints(this._path);\n    this._transformPoints(this._rect);\n\n    if (this.options.rotation) {\n      this._handleLine._transform(null);\n      this._transformPoints(this._handleLine, this._angle, null, this._origin);\n    }\n  },\n\n\n  /**\n   * @param {Number} angle\n   * @param {Number} scale\n   * @param {L.LatLng=} rotationOrigin\n   * @param {L.LatLng=} scaleOrigin\n   */\n  _getProjectedMatrix: function(angle, scale, rotationOrigin, scaleOrigin) {\n    var map    = this._map;\n    var zoom   = map.getMaxZoom() || this.options.maxZoom;\n    var matrix = L.matrix(1, 0, 0, 1, 0, 0);\n    var origin;\n\n    angle = angle || this._angle || 0;\n    scale = scale || this._scale || L.point(1, 1);\n\n    if (!(scale.x === 1 && scale.y === 1)) {\n      scaleOrigin = scaleOrigin || this._scaleOrigin;\n      origin = map.project(scaleOrigin, zoom);\n      matrix = matrix\n        ._add(L.matrix(1, 0, 0, 1, origin.x, origin.y))\n        ._add(L.matrix(scale.x, 0, 0, scale.y, 0, 0))\n        ._add(L.matrix(1, 0, 0, 1, -origin.x, -origin.y));\n    }\n\n    if (angle) {\n      rotationOrigin = rotationOrigin || this._rotationOrigin;\n      origin = map.project(rotationOrigin, zoom);\n      matrix = matrix.rotate(angle, origin).flip();\n    }\n\n    return matrix;\n  },\n\n\n  /**\n   * @param  {L.LatLng} latlng\n   * @param  {L.Matrix} matrix\n   * @param  {L.Map}    map\n   * @param  {Number}   zoom\n   * @return {L.LatLng}\n   */\n  _transformPoint: function(latlng, matrix, map, zoom) {\n    return map.unproject(matrix.transform(\n      map.project(latlng, zoom)), zoom);\n  },\n\n\n  /**\n   * Applies transformation, does it in one sweep for performance,\n   * so don't be surprised about the code repetition.\n   *\n   * @param {L.Path}    path\n   * @param {Number=}   angle\n   * @param {L.Point=}  scale\n   * @param {L.LatLng=} rotationOrigin\n   * @param {L.LatLng=} scaleOrigin\n   */\n  _transformPoints: function(path, angle, scale, rotationOrigin, scaleOrigin) {\n    var map = path._map;\n    var zoom = map.getMaxZoom() || this.options.maxZoom;\n    var i, len;\n\n    var projectedMatrix = this._projectedMatrix =\n      this._getProjectedMatrix(angle, scale, rotationOrigin, scaleOrigin);\n    // console.time('transform');\n\n    // all shifts are in-place\n    if (path._point) { // L.Circle\n      path._latlng = this._transformPoint(\n        path._latlng, projectedMatrix, map, zoom);\n    } else if (path._rings || path._parts) { // everything else\n      var rings = path._rings;\n      var latlngs = path._latlngs;\n      path._bounds = new L.LatLngBounds();\n\n      if (!L.Util.isArray(latlngs[0])) { // polyline\n        latlngs = [latlngs];\n      }\n      for (i = 0, len = rings.length; i < len; i++) {\n        for (var j = 0, jj = rings[i].length; j < jj; j++) {\n          latlngs[i][j] = this._transformPoint(\n            latlngs[i][j], projectedMatrix, map, zoom);\n          path._bounds.extend(latlngs[i][j]);\n        }\n      }\n    }\n\n    path._reset();\n    //console.timeEnd('transform');\n  },\n\n\n  /**\n   * Creates markers and handles\n   */\n  _createHandlers: function() {\n    var map = this._map;\n    this._handlersGroup = this._handlersGroup ||\n                          new L.LayerGroup().addTo(map);\n    this._rect = this._rect ||\n                 this._getBoundingPolygon().addTo(this._handlersGroup);\n\n    if (this.options.scaling) {\n      this._handlers = [];\n      for (var i = 0; i < this.options.edgesCount; i++) {\n        // TODO: add stretching\n        this._handlers.push(\n          this._createHandler(this._rect._latlngs[0][i], i * 2, i)\n          .addTo(this._handlersGroup));\n      }\n    }\n\n    // add bounds\n    if (this.options.rotation) {\n      //add rotation handler\n      this._createRotationHandlers();\n    }\n  },\n\n\n  /**\n   * Rotation marker and small connectin handle\n   */\n  _createRotationHandlers: function() {\n    var map     = this._map;\n    var latlngs = this._rect._latlngs[0];\n\n    var bottom   = new L.LatLng(\n      (latlngs[0].lat + latlngs[3].lat) / 2,\n      (latlngs[0].lng + latlngs[3].lng) / 2);\n    // hehe, top is a reserved word\n    var topPoint = new L.LatLng(\n      (latlngs[1].lat + latlngs[2].lat) / 2,\n      (latlngs[1].lng + latlngs[2].lng) / 2);\n\n    var handlerPosition = map.layerPointToLatLng(\n      L.PathTransform.pointOnLine(\n        map.latLngToLayerPoint(bottom),\n        map.latLngToLayerPoint(topPoint),\n        this.options.handleLength)\n    );\n\n    this._handleLine = new L.Polyline([topPoint, handlerPosition],\n      this.options.rotateHandleOptions).addTo(this._handlersGroup);\n    var RotateHandleClass = this.options.rotateHandleClass;\n    this._rotationMarker = new RotateHandleClass(handlerPosition,\n      this.options.handlerOptions)\n      .addTo(this._handlersGroup)\n      .on('mousedown', this._onRotateStart, this);\n\n    this._rotationOrigin = new L.LatLng(\n      (topPoint.lat + bottom.lat) / 2,\n      (topPoint.lng + bottom.lng) / 2\n    );\n\n    this._handlers.push(this._rotationMarker);\n  },\n\n\n  /**\n   * @return {L.LatLng}\n   */\n  _getRotationOrigin: function() {\n    var latlngs = this._rect._latlngs[0];\n    var lb = latlngs[0];\n    var rt = latlngs[2];\n\n    return new L.LatLng(\n      (lb.lat + rt.lat) / 2,\n      (lb.lng + rt.lng) / 2\n    );\n  },\n\n\n  /**\n   * Secure the rotation origin\n   * @param  {Event} evt\n   */\n  _onRotateStart: function(evt) {\n    var map = this._map;\n\n    map.dragging.disable();\n\n    this._originMarker     = null;\n    this._rotationOriginPt = map.latLngToLayerPoint(this._getRotationOrigin());\n    this._rotationStart    = evt.layerPoint;\n    this._initialMatrix    = this._matrix.clone();\n\n    this._angle = 0;\n    this._path._map\n      .on('mousemove', this._onRotate,     this)\n      .on('mouseup',   this._onRotateEnd, this);\n\n    this._cachePoints();\n    this._path\n      .fire('transformstart',   { layer: this._path })\n      .fire('rotatestart', { layer: this._path, rotation: 0 });\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onRotate: function(evt) {\n    var pos = evt.layerPoint;\n    var previous = this._rotationStart;\n    var origin   = this._rotationOriginPt;\n\n    // rotation step angle\n    this._angle = Math.atan2(pos.y - origin.y, pos.x - origin.x) -\n                  Math.atan2(previous.y - origin.y, previous.x - origin.x);\n\n    this._matrix = this._initialMatrix\n      .clone()\n      .rotate(this._angle, origin)\n      .flip();\n\n    this._update();\n    this._path.fire('rotate', { layer: this._path, rotation: this._angle });\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onRotateEnd: function(evt) {\n    this._path._map\n      .off('mousemove', this._onRotate, this)\n      .off('mouseup',   this._onRotateEnd, this);\n\n    this._apply();\n    this._path.fire('rotateend', { layer: this._path, rotation: this._angle });\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onScaleStart: function(evt) {\n    var marker = evt.target;\n    var map = this._map;\n\n    map.dragging.disable();\n\n    this._activeMarker = marker;\n\n    this._originMarker = this._handlers[(marker.options.index + 2) % 4];\n    this._scaleOrigin  = this._originMarker.getLatLng();\n\n    this._initialMatrix = this._matrix.clone();\n    this._cachePoints();\n\n    this._map\n      .on('mousemove', this._onScale,    this)\n      .on('mouseup',   this._onScaleEnd, this);\n    this._initialDist  = this._originMarker._point.distanceTo(this._activeMarker._point);\n    this._initialDistX = this._originMarker._point.x - this._activeMarker._point.x;\n    this._initialDistY = this._originMarker._point.y - this._activeMarker._point.y;\n\n    this._path\n      .fire('transformstart', { layer: this._path })\n      .fire('scalestart', { layer: this._path, scale: L.point(1, 1) });\n\n    this._map.removeLayer(this._handleLine);\n    this._map.removeLayer(this._rotationMarker);\n\n    //this._handleLine = this._rotationMarker = null;\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onScale: function(evt) {\n    var originPoint = this._originMarker._point;\n    var ratioX, ratioY;\n    if (this.options.uniformScaling) {\n      ratioX = originPoint.distanceTo(evt.layerPoint) / this._initialDist;\n      ratioY = ratioX;\n    } else {\n      ratioX = (originPoint.x - evt.layerPoint.x) / this._initialDistX;\n      ratioY = (originPoint.y - evt.layerPoint.y) / this._initialDistY;\n    }\n\n    this._scale = new L.Point(ratioX, ratioY);\n\n    // update matrix\n    this._matrix = this._initialMatrix\n      .clone()\n      .scale(this._scale, originPoint);\n\n    this._update();\n    this._path.fire('scale', {\n      layer: this._path, scale: this._scale.clone() });\n  },\n\n\n  /**\n   * Scaling complete\n   * @param  {Event} evt\n   */\n  _onScaleEnd: function(evt) {\n    this._map\n      .off('mousemove', this._onScale,    this)\n      .off('mouseup',   this._onScaleEnd, this);\n\n    this._map.addLayer(this._handleLine);\n    this._map.addLayer(this._rotationMarker);\n\n    this._apply();\n    this._path.fire('scaleend', {\n      layer: this._path, scale: this._scale.clone() });\n  },\n\n\n  /**\n   * Cache current handlers positions\n   */\n  _cachePoints: function() {\n    this._handlersGroup.eachLayer(function(layer) {\n      layer.bringToFront();\n    });\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      handler._initialPoint = handler._point.clone();\n    }\n  },\n\n\n  /**\n   * Bounding polygon\n   * @return {L.Polygon}\n   */\n  _getBoundingPolygon: function() {\n    if (this._rectShape) {\n      return L.GeoJSON.geometryToLayer(\n        this._rectShape, this.options.boundsOptions);\n    } else {\n      return new L.Rectangle(\n        this._path.getBounds(), this.options.boundsOptions);\n    }\n  },\n\n\n  /**\n   * Create corner marker\n   * @param  {L.LatLng} latlng\n   * @param  {Number}   type one of L.Handler.PathTransform.HandlerTypes\n   * @param  {Number}   index\n   * @return {L.Handler.PathTransform.Handle}\n   */\n  _createHandler: function(latlng, type, index) {\n    var HandleClass = this.options.handleClass;\n    var marker = new HandleClass(latlng,\n      L.Util.extend({}, this.options.handlerOptions, {\n        className: 'leaflet-drag-transform-marker drag-marker--' +\n                   index + ' drag-marker--' + type,\n        index:     index,\n        type:      type\n      })\n    );\n\n    marker.on('mousedown', this._onScaleStart, this);\n    return marker;\n  },\n\n\n  /**\n   * Hide(not remove) the handlers layer\n   */\n  _hideHandlers: function() {\n    this._map.removeLayer(this._handlersGroup);\n  },\n\n\n  /**\n   * Hide handlers and rectangle\n   */\n  _onDragStart: function() {\n    this._hideHandlers();\n  },\n\n\n  /**\n   * Drag rectangle, re-create handlers\n   */\n  _onDragEnd: function(evt) {\n    var rect = this._rect;\n    var matrix = (evt.layer ? evt.layer : this._path).dragging._matrix.slice();\n\n    if (!rect.dragging) {\n      rect.dragging = new L.Handler.PathDrag(rect);\n    }\n    rect.dragging.enable();\n    this._map.addLayer(rect);\n    rect.dragging._transformPoints(matrix);\n    rect._updatePath();\n    rect._project();\n    \n    rect.dragging.disable();\n\n    this._map.addLayer(this._handlersGroup);\n    this._updateHandlers();\n\n    this._path.fire('transformed', {\n      scale: L.point(1, 1),\n      rotation: 0,\n      matrix: L.matrix.apply(undefined, matrix),\n      translate: L.point(matrix[4], matrix[5]),\n      layer: this._path\n    });\n  }\n});\n\n\nL.Path.addInitHook(function() {\n  if (this.options.transform) {\n    this.transform = new L.Handler.PathTransform(this, this.options.transform);\n  }\n});\n\n\nexport {L};\n\n\n// WEBPACK FOOTER //\n// ./L.Path.Transform-src.js","<template>\n  <div style=\"display: none;\">\n    <slot v-if=\"ready\"></slot>\n  </div>\n</template>\n\n<script>\n\nimport { findRealParent, propsBinder, optionsMerger, Polygon } from 'vue2-leaflet'\nimport './L.Path.Transform-src.js'\n\nconst props = {\n  latLngs: {\n    type: Array,\n    default: () => []\n  },\n  draggable: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  transform: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  rotation: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  scaling: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  options: {\n    type: Object,\n    default: () => ({}),\n  },\n  handleOptions: {\n    type: Object,\n    default: () => ({}),\n  },\n};\nexport default {\n  name: 'LPathTransform',\n  props: props,\n  mixins: [Polygon],\n  data() {\n    return {\n      ready: false,\n    }\n  },\n  mounted() {\n    const options = optionsMerger(this.polygonOptions, this);\n    this.mapObject = L.polygon(this.latLngs, options);\n    L.DomEvent.on(this.mapObject, this.$listeners);\n    propsBinder(this, this.mapObject, this.$options.props);\n    this.ready = true;\n    this.parentContainer = findRealParent(this.$parent);\n    this.parentContainer.addLayer(this, !this.visible);\n\n    if(this.transform){\n      this.mapObject.setOptions({\n        rotation:this.rotation,\n        scaling:this.scaling,\n        handlerOptions: this.handlerOptions\n      }).enable();\n    }\n  },\n  methods: {\n    setDraggable(newVal, oldVal) {\n      if (this.mapObject.dragging) {\n        newVal ? this.mapObject.dragging.enable() : this.mapObject.dragging.disable();\n      }\n    },\n    setVisible(newVal, oldVal) {\n      if (newVal == oldVal) return;\n      if (this.mapObject) {\n        if (newVal) {\n          this.parentContainer.addLayer(this);\n        } else {\n          this.parentContainer.removeLayer(this);\n        }\n      }\n    },\n    setLatLng(newVal) {\n      if (newVal == null) {\n        return;\n      }\n      if (this.mapObject) {\n        let oldLatLng = this.mapObject.getLatLng();\n        let newLatLng = {\n          lat: newVal[0] || newVal.lat,\n          lng: newVal[1] || newVal.lng,\n        };\n        if (newLatLng.lat != oldLatLng.lat || newLatLng.lng != oldLatLng.lng) {\n          this.mapObject.setLatLng(newLatLng);\n        }\n      }\n    }\n  }\n};\n\n</script>\n\n\n\n// WEBPACK FOOTER //\n// Vue2LeafletPathTransform.vue?20f945f2","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 3\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticStyle: {\n      \"display\": \"none\"\n    }\n  }, [(_vm.ready) ? _vm._t(\"default\") : _vm._e()], 2)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-54ea6851!./~/vue-loader/lib/selector.js?type=template&index=0!./Vue2LeafletPathTransform.vue\n// module id = 4\n// module chunks = 0","module.exports = require(\"vue2-leaflet\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"vue2-leaflet\"\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}