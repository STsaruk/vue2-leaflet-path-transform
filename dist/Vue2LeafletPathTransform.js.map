{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///Vue2LeafletPathTransform.js","webpack:///webpack/bootstrap a50f1cfd22f05cf291f4","webpack:///external \"leaflet\"","webpack:///./Vue2LeafletPathTransform.vue","webpack:///./L.Path.Transform-src.js","webpack:///Vue2LeafletPathTransform.vue","webpack:///./~/vue-loader/lib/component-normalizer.js","webpack:///./Vue2LeafletPathTransform.vue?2b03","webpack:///external \"vue2-leaflet\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_6__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Component","distance","a","b","dx","x","dy","y","Math","sqrt","TRUE_FN","L","undefined","_leaflet","_leaflet2","obj","default","Util","merge","extend","Path","include","_transform","matrix","_renderer","transformPath","_resetTransformPath","_update","_onMouseClick","e","dragging","moved","_map","_fireMouseEvent","END","mousedown","touchstart","pointerdown","MSPointerDown","MOVE","Handler","PathDrag","statics","DRAGGING_CLS","initialize","path","_path","_matrix","_startPoint","_dragStartPoint","_mapDraggingWasEnabled","addHooks","on","_onDragStart","options","className","DomUtil","addClass","removeHooks","off","replace","RegExp","removeClass","_dragMoved","evt","eventType","originalEvent","_simulated","type","containerPoint","clone","DomEvent","stop","_container","document","_onDrag","_onDragEnd","enabled","disable","_popup","_close","_replaceCoordGetters","first","touches","length","mouseEventToContainerPoint","distanceTo","tapTolerance","fire","bringToFront","_transformPoints","_updatePath","_project","_restoreCoordGetters","contains","_containsPoint","falseFn","requestAnimFrame","skipped","fakeStop","enable","dest","len","latlng","px","point","crs","transformation","scale","getZoom","projection","diff","untransform","subtract","applyTransform","_bounds","LatLngBounds","_point","unproject","project","_latlng","_add","_rings","_parts","rings","latlngs","_latlngs","isArray","j","jj","getLatLng","getLatLng_","bind","getLatLngs","getLatLngs_","makeDraggable","layer","addInitHook","draggable","interactive","SVG","setAttributeNS","join","Browser","vml","_skew","removeChild","skew","create","appendChild","style","behavior","mt","toFixed","offset","floor","parseFloat","left","t","top","w","width","h","height","isNaN","origin","Canvas","_containerCopy","_containsPoint_","_requestRedraw","copyCtx","copy","ctx","_ctx","retina","bounds","size","getSize","pos","min","createElement","getContext","_removePath","_redraw","translate","drawImage","_initPath","save","clearRect","setTransform","restore","transform","apply","_drawing","PathTransform","pointOnLine","start","final","distPx","ratio","Point","isObject","toString","key","val","arguments","target","Matrix","f","translateX","translateY","scaleX","scaleY","rotate","angle","cos","sin","flip","result","src","other","k","Handle","CircleMarker","onAdd","map","setCursor","cursor","CursorsByType","index","RotateHandle","rotation","scaling","uniformScaling","maxZoom","handlerOptions","radius","fillColor","color","fillOpacity","weight","opacity","boundsOptions","dashArray","fill","rotateHandleOptions","handleLength","edgesCount","handleClass","rotateHandleClass","_activeMarker","_originMarker","_rotationMarker","_rotationOrigin","_scaleOrigin","_angle","_scale","_initialDist","_initialDistX","_initialDistY","_rotationStart","_rotationOriginPt","_projectedMatrix","_handlersGroup","_rect","_handlers","_handleLine","setOptions","_createHandlers","_hideHandlers","_enabled","rotationOrigin","scaleOrigin","center","getCenter","handler","_initialPoint","_applyTransform","_apply","_transformGeometries","layerPointToLatLng","redraw","_updateHandlers","reset","removeLayer","_getBoundingPolygon","addTo","handlersGroup","_rectShape","toGeoJSON","_origin","_getProjectedMatrix","zoom","getMaxZoom","_transformPoint","projectedMatrix","_reset","LayerGroup","push","_createHandler","_createRotationHandlers","bottom","LatLng","lat","lng","topPoint","handlerPosition","latLngToLayerPoint","Polyline","RotateHandleClass","_onRotateStart","_getRotationOrigin","lb","rt","layerPoint","_initialMatrix","_onRotate","_onRotateEnd","_cachePoints","previous","atan2","_onScaleStart","marker","_onScale","_onScaleEnd","ratioX","ratioY","originPoint","addLayer","eachLayer","GeoJSON","geometryToLayer","Rectangle","getBounds","HandleClass","rect","slice","_vue2Leaflet","props","latLngs","Array","Boolean","custom","mixins","LPolygon","data","ready","beforeMount","mounted","mapObject","methods","setDraggable","newVal","oldVal","setVisible","parentContainer","setLatLngs","newLatLngs","rawScriptExports","compiledTemplate","scopeId","cssModules","esModule","scriptExports","render","staticRenderFns","_scopeId","computed","keys","forEach","_vm","_h","$createElement","_self","_c","staticStyle","display","_t","_e"],"mappings":"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","file":"Vue2LeafletPathTransform.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"), require(\"vue2-leaflet\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"leaflet\", \"vue2-leaflet\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue2LeafletPathTransform\"] = factory(require(\"leaflet\"), require(\"vue2-leaflet\"));\n\telse\n\t\troot[\"Vue2LeafletPathTransform\"] = factory(root[\"leaflet\"], root[\"vue2-leaflet\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_6__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"), require(\"vue2-leaflet\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"leaflet\", \"vue2-leaflet\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue2LeafletPathTransform\"] = factory(require(\"leaflet\"), require(\"vue2-leaflet\"));\n\telse\n\t\troot[\"Vue2LeafletPathTransform\"] = factory(root[\"leaflet\"], root[\"vue2-leaflet\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_6__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"leaflet\");\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(4)(\n  /* script */\n  __webpack_require__(3),\n  /* template */\n  __webpack_require__(5),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.L = undefined;\n\nvar _leaflet = __webpack_require__(0);\n\nvar _leaflet2 = _interopRequireDefault(_leaflet);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_leaflet2.default.Util.merge = _leaflet2.default.Util.extend;\n/**\n * Leaflet vector features drag functionality\n * @author Alexander Milevski <info@w8r.name>\n * @preserve\n */\n\n_leaflet2.default.Path.include({\n  _transform: function _transform(matrix) {\n    if (this._renderer) {\n      if (matrix) {\n        this._renderer.transformPath(this, matrix);\n      } else {\n        this._renderer._resetTransformPath(this);\n        this._update();\n      }\n    }\n    return this;\n  },\n\n  _onMouseClick: function _onMouseClick(e) {\n    if (this.dragging && this.dragging.moved() || this._map.dragging && this._map.dragging.moved()) {\n      return;\n    }\n\n    this._fireMouseEvent(e);\n  }\n\n});\nvar END = {\n  mousedown: 'mouseup',\n  touchstart: 'touchend',\n  pointerdown: 'touchend',\n  MSPointerDown: 'touchend'\n};\n\nvar MOVE = {\n  mousedown: 'mousemove',\n  touchstart: 'touchmove',\n  pointerdown: 'touchmove',\n  MSPointerDown: 'touchmove'\n};\n\nfunction distance(a, b) {\n  var dx = a.x - b.x,\n      dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n_leaflet2.default.Handler.PathDrag = _leaflet2.default.Handler.extend({\n\n  statics: {\n    DRAGGING_CLS: 'leaflet-path-draggable'\n  },\n\n  initialize: function initialize(path) {\n    this._path = path;\n\n    this._matrix = null;\n\n    this._startPoint = null;\n\n    this._dragStartPoint = null;\n\n    this._mapDraggingWasEnabled = false;\n  },\n\n  addHooks: function addHooks() {\n    this._path.on('mousedown', this._onDragStart, this);\n\n    this._path.options.className = this._path.options.className ? this._path.options.className + ' ' + _leaflet2.default.Handler.PathDrag.DRAGGING_CLS : _leaflet2.default.Handler.PathDrag.DRAGGING_CLS;\n\n    if (this._path._path) {\n      _leaflet2.default.DomUtil.addClass(this._path._path, _leaflet2.default.Handler.PathDrag.DRAGGING_CLS);\n    }\n  },\n\n  removeHooks: function removeHooks() {\n    this._path.off('mousedown', this._onDragStart, this);\n\n    this._path.options.className = this._path.options.className.replace(new RegExp('\\\\s+' + _leaflet2.default.Handler.PathDrag.DRAGGING_CLS), '');\n    if (this._path._path) {\n      _leaflet2.default.DomUtil.removeClass(this._path._path, _leaflet2.default.Handler.PathDrag.DRAGGING_CLS);\n    }\n  },\n\n  moved: function moved() {\n    return this._path._dragMoved;\n  },\n\n  _onDragStart: function _onDragStart(evt) {\n    var eventType = evt.originalEvent._simulated ? 'touchstart' : evt.originalEvent.type;\n\n    this._mapDraggingWasEnabled = false;\n    this._startPoint = evt.containerPoint.clone();\n    this._dragStartPoint = evt.containerPoint.clone();\n    this._matrix = [1, 0, 0, 1, 0, 0];\n    _leaflet2.default.DomEvent.stop(evt.originalEvent);\n\n    _leaflet2.default.DomUtil.addClass(this._path._renderer._container, 'leaflet-interactive');\n    _leaflet2.default.DomEvent.on(document, MOVE[eventType], this._onDrag, this).on(document, END[eventType], this._onDragEnd, this);\n\n    if (this._path._map.dragging.enabled()) {\n\n      this._path._map.dragging.disable();\n      this._mapDraggingWasEnabled = true;\n    }\n    this._path._dragMoved = false;\n\n    if (this._path._popup) {\n      this._path._popup._close();\n    }\n\n    this._replaceCoordGetters(evt);\n  },\n\n  _onDrag: function _onDrag(evt) {\n    _leaflet2.default.DomEvent.stop(evt);\n\n    var first = evt.touches && evt.touches.length >= 1 ? evt.touches[0] : evt;\n    var containerPoint = this._path._map.mouseEventToContainerPoint(first);\n\n    if (evt.type === 'touchmove' && !this._path._dragMoved) {\n      var totalMouseDragDistance = this._dragStartPoint.distanceTo(containerPoint);\n      if (totalMouseDragDistance <= this._path._map.options.tapTolerance) {\n        return;\n      }\n    }\n\n    var x = containerPoint.x;\n    var y = containerPoint.y;\n\n    var dx = x - this._startPoint.x;\n    var dy = y - this._startPoint.y;\n\n    if (dx || dy) {\n      if (!this._path._dragMoved) {\n        this._path._dragMoved = true;\n        this._path.fire('dragstart', evt);\n\n        this._path.bringToFront();\n      }\n\n      this._matrix[4] += dx;\n      this._matrix[5] += dy;\n\n      this._startPoint.x = x;\n      this._startPoint.y = y;\n\n      this._path.fire('predrag', evt);\n      this._path._transform(this._matrix);\n      this._path.fire('drag', evt);\n    }\n  },\n\n  _onDragEnd: function _onDragEnd(evt) {\n    var containerPoint = this._path._map.mouseEventToContainerPoint(evt);\n    var moved = this.moved();\n\n    if (moved) {\n      this._transformPoints(this._matrix);\n      this._path._updatePath();\n      this._path._project();\n      this._path._transform(null);\n\n      _leaflet2.default.DomEvent.stop(evt);\n    }\n\n    _leaflet2.default.DomEvent.off(document, 'mousemove touchmove', this._onDrag, this);\n    _leaflet2.default.DomEvent.off(document, 'mouseup touchend', this._onDragEnd, this);\n\n    this._restoreCoordGetters();\n\n    if (moved) {\n      this._path.fire('dragend', {\n        distance: distance(this._dragStartPoint, containerPoint)\n      });\n\n      var contains = this._path._containsPoint;\n      this._path._containsPoint = _leaflet2.default.Util.falseFn;\n      _leaflet2.default.Util.requestAnimFrame(function () {\n        _leaflet2.default.DomEvent.skipped({ type: 'click' });\n        this._path._containsPoint = contains;\n      }, this);\n    }\n\n    this._matrix = null;\n    this._startPoint = null;\n    this._dragStartPoint = null;\n    this._path._dragMoved = false;\n\n    if (this._mapDraggingWasEnabled) {\n      if (moved) _leaflet2.default.DomEvent.fakeStop({ type: 'click' });\n      this._path._map.dragging.enable();\n    }\n  },\n\n  _transformPoints: function _transformPoints(matrix, dest) {\n    var path = this._path;\n    var i, len, latlng;\n\n    var px = _leaflet2.default.point(matrix[4], matrix[5]);\n\n    var crs = path._map.options.crs;\n    var transformation = crs.transformation;\n    var scale = crs.scale(path._map.getZoom());\n    var projection = crs.projection;\n\n    var diff = transformation.untransform(px, scale).subtract(transformation.untransform(_leaflet2.default.point(0, 0), scale));\n    var applyTransform = !dest;\n\n    path._bounds = new _leaflet2.default.LatLngBounds();\n\n    if (path._point) {\n      dest = projection.unproject(projection.project(path._latlng)._add(diff));\n      if (applyTransform) {\n        path._latlng = dest;\n        path._point._add(px);\n      }\n    } else if (path._rings || path._parts) {\n      var rings = path._rings || path._parts;\n      var latlngs = path._latlngs;\n      dest = dest || latlngs;\n      if (!_leaflet2.default.Util.isArray(latlngs[0])) {\n        latlngs = [latlngs];\n        dest = [dest];\n      }\n      for (i = 0, len = rings.length; i < len; i++) {\n        dest[i] = dest[i] || [];\n        for (var j = 0, jj = rings[i].length; j < jj; j++) {\n          latlng = latlngs[i][j];\n          dest[i][j] = projection.unproject(projection.project(latlng)._add(diff));\n          if (applyTransform) {\n            path._bounds.extend(latlngs[i][j]);\n            rings[i][j]._add(px);\n          }\n        }\n      }\n    }\n    return dest;\n  },\n\n  _replaceCoordGetters: function _replaceCoordGetters() {\n    if (this._path.getLatLng) {\n      this._path.getLatLng_ = this._path.getLatLng;\n      this._path.getLatLng = _leaflet2.default.Util.bind(function () {\n        return this.dragging._transformPoints(this.dragging._matrix, {});\n      }, this._path);\n    } else if (this._path.getLatLngs) {\n      this._path.getLatLngs_ = this._path.getLatLngs;\n      this._path.getLatLngs = _leaflet2.default.Util.bind(function () {\n        return this.dragging._transformPoints(this.dragging._matrix, []);\n      }, this._path);\n    }\n  },\n\n  _restoreCoordGetters: function _restoreCoordGetters() {\n    if (this._path.getLatLng_) {\n      this._path.getLatLng = this._path.getLatLng_;\n      delete this._path.getLatLng_;\n    } else if (this._path.getLatLngs_) {\n      this._path.getLatLngs = this._path.getLatLngs_;\n      delete this._path.getLatLngs_;\n    }\n  }\n\n});\n\n_leaflet2.default.Handler.PathDrag.makeDraggable = function (layer) {\n  layer.dragging = new _leaflet2.default.Handler.PathDrag(layer);\n  return layer;\n};\n\n_leaflet2.default.Path.prototype.makeDraggable = function () {\n  return _leaflet2.default.Handler.PathDrag.makeDraggable(this);\n};\n\n_leaflet2.default.Path.addInitHook(function () {\n  if (this.options.draggable) {\n    this.options.interactive = true;\n\n    if (this.dragging) {\n      this.dragging.enable();\n    } else {\n      _leaflet2.default.Handler.PathDrag.makeDraggable(this);\n      this.dragging.enable();\n    }\n  } else if (this.dragging) {\n    this.dragging.disable();\n  }\n});\n_leaflet2.default.SVG.include({\n  _resetTransformPath: function _resetTransformPath(layer) {\n    layer._path.setAttributeNS(null, 'transform', '');\n  },\n\n  transformPath: function transformPath(layer, matrix) {\n    layer._path.setAttributeNS(null, 'transform', 'matrix(' + matrix.join(' ') + ')');\n  }\n\n});\n_leaflet2.default.SVG.include(!_leaflet2.default.Browser.vml ? {} : {\n  _resetTransformPath: function _resetTransformPath(layer) {\n    if (layer._skew) {\n      layer._skew.on = false;\n      layer._path.removeChild(layer._skew);\n      layer._skew = null;\n    }\n  },\n\n  transformPath: function transformPath(layer, matrix) {\n    var skew = layer._skew;\n\n    if (!skew) {\n      skew = _leaflet2.default.SVG.create('skew');\n      layer._path.appendChild(skew);\n      skew.style.behavior = 'url(#default#VML)';\n      layer._skew = skew;\n    }\n\n    var mt = matrix[0].toFixed(8) + ' ' + matrix[1].toFixed(8) + ' ' + matrix[2].toFixed(8) + ' ' + matrix[3].toFixed(8) + ' 0 0';\n    var offset = Math.floor(matrix[4]).toFixed() + ', ' + Math.floor(matrix[5]).toFixed() + '';\n\n    var s = this._path.style;\n    var l = parseFloat(s.left);\n    var t = parseFloat(s.top);\n    var w = parseFloat(s.width);\n    var h = parseFloat(s.height);\n\n    if (isNaN(l)) l = 0;\n    if (isNaN(t)) t = 0;\n    if (isNaN(w) || !w) w = 1;\n    if (isNaN(h) || !h) h = 1;\n\n    var origin = (-l / w - 0.5).toFixed(8) + ' ' + (-t / h - 0.5).toFixed(8);\n\n    skew.on = 'f';\n    skew.matrix = mt;\n    skew.origin = origin;\n    skew.offset = offset;\n    skew.on = true;\n  }\n\n});\nfunction TRUE_FN() {\n  return true;\n}\n\n_leaflet2.default.Canvas.include({\n  _resetTransformPath: function _resetTransformPath(layer) {\n    if (!this._containerCopy) return;\n\n    delete this._containerCopy;\n\n    if (layer._containsPoint_) {\n      layer._containsPoint = layer._containsPoint_;\n      delete layer._containsPoint_;\n\n      this._requestRedraw(layer);\n    }\n  },\n\n  transformPath: function transformPath(layer, matrix) {\n    var copy = this._containerCopy;\n    var ctx = this._ctx,\n        copyCtx;\n    var m = _leaflet2.default.Browser.retina ? 2 : 1;\n    var bounds = this._bounds;\n    var size = bounds.getSize();\n    var pos = bounds.min;\n\n    if (!copy) {\n      copy = this._containerCopy = document.createElement('canvas');\n      copyCtx = copy.getContext('2d');\n\n\n      copy.width = m * size.x;\n      copy.height = m * size.y;\n\n      this._removePath(layer);\n      this._redraw();\n\n      copyCtx.translate(m * bounds.min.x, m * bounds.min.y);\n      copyCtx.drawImage(this._container, 0, 0);\n      this._initPath(layer);\n\n      layer._containsPoint_ = layer._containsPoint;\n      layer._containsPoint = TRUE_FN;\n    }\n\n    ctx.save();\n    ctx.clearRect(pos.x, pos.y, size.x * m, size.y * m);\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.restore();\n    ctx.save();\n\n    ctx.drawImage(this._containerCopy, 0, 0, size.x, size.y);\n    ctx.transform.apply(ctx, matrix);\n\n    this._drawing = true;\n    layer._updatePath();\n    this._drawing = false;\n\n    ctx.restore();\n  }\n\n});\n/**\n * Drag/rotate/resize handler for [leaflet](http://leafletjs.com) vector features.\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n_leaflet2.default.PathTransform = {};\n\n_leaflet2.default.PathTransform.pointOnLine = function (start, final, distPx) {\n  var ratio = 1 + distPx / start.distanceTo(final);\n  return new _leaflet2.default.Point(start.x + (final.x - start.x) * ratio, start.y + (final.y - start.y) * ratio);\n};\n\n_leaflet2.default.PathTransform.merge = function () {\n  var i = 1;\n  var key, val;\n  var obj = arguments[i];\n\n  function isObject(object) {\n    return Object.prototype.toString.call(object) === '[object Object]';\n  }\n\n  var target = arguments[0];\n\n  while (obj) {\n    obj = arguments[i++];\n    for (key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      val = obj[key];\n\n      if (isObject(val) && isObject(target[key])) {\n        target[key] = _leaflet2.default.Util.merge(target[key], val);\n      } else {\n        target[key] = val;\n      }\n    }\n  }\n  return target;\n};\n\n_leaflet2.default.Matrix = function (a, b, c, d, e, f) {\n  this._matrix = [a, b, c, d, e, f];\n};\n\n_leaflet2.default.Matrix.prototype = {\n  transform: function transform(point) {\n    return this._transform(point.clone());\n  },\n\n  _transform: function _transform(point) {\n    var matrix = this._matrix;\n    var x = point.x,\n        y = point.y;\n    point.x = matrix[0] * x + matrix[1] * y + matrix[4];\n    point.y = matrix[2] * x + matrix[3] * y + matrix[5];\n    return point;\n  },\n\n  untransform: function untransform(point) {\n    var matrix = this._matrix;\n    return new _leaflet2.default.Point((point.x / matrix[0] - matrix[4]) / matrix[0], (point.y / matrix[2] - matrix[5]) / matrix[2]);\n  },\n\n  clone: function clone() {\n    var matrix = this._matrix;\n    return new _leaflet2.default.Matrix(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n  },\n\n  translate: function translate(_translate) {\n    if (_translate === undefined) {\n      return new _leaflet2.default.Point(this._matrix[4], this._matrix[5]);\n    }\n\n    var translateX, translateY;\n    if (typeof _translate === 'number') {\n      translateX = translateY = _translate;\n    } else {\n      translateX = _translate.x;\n      translateY = _translate.y;\n    }\n\n    return this._add(1, 0, 0, 1, translateX, translateY);\n  },\n\n  scale: function scale(_scale, origin) {\n    if (_scale === undefined) {\n      return new _leaflet2.default.Point(this._matrix[0], this._matrix[3]);\n    }\n\n    var scaleX, scaleY;\n    origin = origin || _leaflet2.default.point(0, 0);\n    if (typeof _scale === 'number') {\n      scaleX = scaleY = _scale;\n    } else {\n      scaleX = _scale.x;\n      scaleY = _scale.y;\n    }\n\n    return this._add(scaleX, 0, 0, scaleY, origin.x, origin.y)._add(1, 0, 0, 1, -origin.x, -origin.y);\n  },\n\n  rotate: function rotate(angle, origin) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n\n    origin = origin || new _leaflet2.default.Point(0, 0);\n\n    return this._add(cos, sin, -sin, cos, origin.x, origin.y)._add(1, 0, 0, 1, -origin.x, -origin.y);\n  },\n\n  flip: function flip() {\n    this._matrix[1] *= -1;\n    this._matrix[2] *= -1;\n    return this;\n  },\n\n  _add: function _add(a, b, c, d, e, f) {\n    var result = [[], [], []];\n    var src = this._matrix;\n    var m = [[src[0], src[2], src[4]], [src[1], src[3], src[5]], [0, 0, 1]];\n    var other = [[a, c, e], [b, d, f], [0, 0, 1]],\n        val;\n\n    if (a && a instanceof _leaflet2.default.Matrix) {\n      src = a._matrix;\n      other = [[src[0], src[2], src[4]], [src[1], src[3], src[5]], [0, 0, 1]];\n    }\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        val = 0;\n        for (var k = 0; k < 3; k++) {\n          val += m[i][k] * other[k][j];\n        }\n        result[i][j] = val;\n      }\n    }\n\n    this._matrix = [result[0][0], result[1][0], result[0][1], result[1][1], result[0][2], result[1][2]];\n    return this;\n  }\n\n};\n\n_leaflet2.default.matrix = function (a, b, c, d, e, f) {\n  return new _leaflet2.default.Matrix(a, b, c, d, e, f);\n};\n\n_leaflet2.default.PathTransform.Handle = _leaflet2.default.CircleMarker.extend({\n  options: {\n    className: 'leaflet-path-transform-handler'\n  },\n\n  onAdd: function onAdd(map) {\n    _leaflet2.default.CircleMarker.prototype.onAdd.call(this, map);\n    if (this._path && this.options.setCursor) {\n      this._path.style.cursor = _leaflet2.default.PathTransform.Handle.CursorsByType[this.options.index];\n    }\n  }\n});\n\n_leaflet2.default.PathTransform.Handle.CursorsByType = ['nesw-resize', 'nwse-resize', 'nesw-resize', 'nwse-resize'];\n\n_leaflet2.default.PathTransform.RotateHandle = _leaflet2.default.PathTransform.Handle.extend({\n  options: {\n    className: 'leaflet-path-transform-handler transform-handler--rotate'\n  },\n\n  onAdd: function onAdd(map) {\n    _leaflet2.default.CircleMarker.prototype.onAdd.call(this, map);\n    if (this._path && this.options.setCursor) {\n      this._path.style.cursor = 'all-scroll';\n    }\n  }\n});\n\n_leaflet2.default.Handler.PathTransform = _leaflet2.default.Handler.extend({\n\n  options: {\n    rotation: true,\n    scaling: true,\n    uniformScaling: true,\n    maxZoom: 22,\n\n    handlerOptions: {\n      radius: 5,\n      fillColor: '#ffffff',\n      color: '#202020',\n      fillOpacity: 1,\n      weight: 2,\n      opacity: 0.7,\n      setCursor: true\n    },\n\n    boundsOptions: {\n      weight: 1,\n      opacity: 1,\n      dashArray: [3, 3],\n      fill: false\n    },\n\n    rotateHandleOptions: {\n      weight: 1,\n      opacity: 1,\n      setCursor: true\n    },\n\n    handleLength: 20,\n\n    edgesCount: 4,\n\n    handleClass: _leaflet2.default.PathTransform.Handle,\n    rotateHandleClass: _leaflet2.default.PathTransform.RotateHandle\n  },\n\n  initialize: function initialize(path) {\n    this._path = path;\n    this._map = null;\n\n    this._activeMarker = null;\n    this._originMarker = null;\n    this._rotationMarker = null;\n\n    this._rotationOrigin = null;\n    this._scaleOrigin = null;\n    this._angle = 0;\n    this._scale = _leaflet2.default.point(1, 1);\n    this._initialDist = 0;\n    this._initialDistX = 0;\n    this._initialDistY = 0;\n    this._rotationStart = null;\n    this._rotationOriginPt = null;\n\n    this._matrix = new _leaflet2.default.Matrix(1, 0, 0, 1, 0, 0);\n    this._projectedMatrix = new _leaflet2.default.Matrix(1, 0, 0, 1, 0, 0);\n\n    this._handlersGroup = null;\n    this._rect = null;\n    this._handlers = [];\n    this._handleLine = null;\n  },\n\n  enable: function enable(options) {\n    if (this._path._map) {\n      this._map = this._path._map;\n      if (options) {\n        this.setOptions(options);\n      }\n      _leaflet2.default.Handler.prototype.enable.call(this);\n    }\n  },\n\n  addHooks: function addHooks() {\n    this._createHandlers();\n    this._path.on('dragstart', this._onDragStart, this).on('dragend', this._onDragEnd, this);\n  },\n\n  removeHooks: function removeHooks() {\n    this._hideHandlers();\n    this._path.off('dragstart', this._onDragStart, this).off('dragend', this._onDragEnd, this);\n    this._handlersGroup = null;\n    this._rect = null;\n    this._handlers = [];\n  },\n\n  setOptions: function setOptions(options) {\n    var enabled = this._enabled;\n    if (enabled) {\n      this.disable();\n    }\n\n    this.options = _leaflet2.default.PathTransform.merge({}, _leaflet2.default.Handler.PathTransform.prototype.options, options);\n\n    if (enabled) {\n      this.enable();\n    }\n\n    return this;\n  },\n\n  rotate: function rotate(angle, origin) {\n    return this.transform(angle, null, origin);\n  },\n\n  scale: function scale(_scale2, origin) {\n    if (typeof _scale2 === 'number') {\n      _scale2 = _leaflet2.default.point(_scale2, _scale2);\n    }\n    return this.transform(0, _scale2, null, origin);\n  },\n\n  transform: function transform(angle, scale, rotationOrigin, scaleOrigin) {\n    var center = this._path.getCenter();\n    rotationOrigin = rotationOrigin || center;\n    scaleOrigin = scaleOrigin || center;\n    this._map = this._path._map;\n    this._transformPoints(this._path, angle, scale, rotationOrigin, scaleOrigin);\n    return this;\n  },\n\n  _update: function _update() {\n    var matrix = this._matrix;\n\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      if (handler !== this._originMarker) {\n        handler._point = matrix.transform(handler._initialPoint);\n        handler._updatePath();\n      }\n    }\n\n    matrix = matrix.clone().flip();\n\n    this._applyTransform(matrix);\n    this._path.fire('transform', { layer: this._path });\n  },\n\n  _applyTransform: function _applyTransform(matrix) {\n    this._path._transform(matrix._matrix);\n    this._rect._transform(matrix._matrix);\n\n    if (this.options.rotation) {\n      this._handleLine._transform(matrix._matrix);\n    }\n  },\n\n  _apply: function _apply() {\n    var map = this._map;\n    var matrix = this._matrix.clone();\n    var angle = this._angle;\n    var scale = this._scale.clone();\n\n    this._transformGeometries();\n\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      handler._latlng = map.layerPointToLatLng(handler._point);\n      delete handler._initialPoint;\n      handler.redraw();\n    }\n\n    this._matrix = _leaflet2.default.matrix(1, 0, 0, 1, 0, 0);\n    this._scale = _leaflet2.default.point(1, 1);\n    this._angle = 0;\n\n    this._updateHandlers();\n\n    map.dragging.enable();\n    this._path.fire('transformed', {\n      matrix: matrix,\n      scale: scale,\n      rotation: angle,\n\n      layer: this._path\n    });\n  },\n\n  reset: function reset() {\n    if (this._enabled) {\n      if (this._rect) {\n        this._handlersGroup.removeLayer(this._rect);\n        this._rect = this._getBoundingPolygon().addTo(this._handlersGroup);\n      }\n      this._updateHandlers();\n    }\n  },\n\n  _updateHandlers: function _updateHandlers() {\n    var handlersGroup = this._handlersGroup;\n\n    this._rectShape = this._rect.toGeoJSON();\n\n    if (this._handleLine) {\n      this._handlersGroup.removeLayer(this._handleLine);\n    }\n\n    if (this._rotationMarker) {\n      this._handlersGroup.removeLayer(this._rotationMarker);\n    }\n\n    this._handleLine = this._rotationMarker = null;\n\n    for (var i = this._handlers.length - 1; i >= 0; i--) {\n      handlersGroup.removeLayer(this._handlers[i]);\n    }\n\n    this._createHandlers();\n  },\n\n  _transformGeometries: function _transformGeometries() {\n    this._path._transform(null);\n    this._rect._transform(null);\n\n    this._transformPoints(this._path);\n    this._transformPoints(this._rect);\n\n    if (this.options.rotation) {\n      this._handleLine._transform(null);\n      this._transformPoints(this._handleLine, this._angle, null, this._origin);\n    }\n  },\n\n  _getProjectedMatrix: function _getProjectedMatrix(angle, scale, rotationOrigin, scaleOrigin) {\n    var map = this._map;\n    var zoom = map.getMaxZoom() || this.options.maxZoom;\n    var matrix = _leaflet2.default.matrix(1, 0, 0, 1, 0, 0);\n    var origin;\n\n    angle = angle || this._angle || 0;\n    scale = scale || this._scale || _leaflet2.default.point(1, 1);\n\n    if (!(scale.x === 1 && scale.y === 1)) {\n      scaleOrigin = scaleOrigin || this._scaleOrigin;\n      origin = map.project(scaleOrigin, zoom);\n      matrix = matrix._add(_leaflet2.default.matrix(1, 0, 0, 1, origin.x, origin.y))._add(_leaflet2.default.matrix(scale.x, 0, 0, scale.y, 0, 0))._add(_leaflet2.default.matrix(1, 0, 0, 1, -origin.x, -origin.y));\n    }\n\n    if (angle) {\n      rotationOrigin = rotationOrigin || this._rotationOrigin;\n      origin = map.project(rotationOrigin, zoom);\n      matrix = matrix.rotate(angle, origin).flip();\n    }\n\n    return matrix;\n  },\n\n  _transformPoint: function _transformPoint(latlng, matrix, map, zoom) {\n    return map.unproject(matrix.transform(map.project(latlng, zoom)), zoom);\n  },\n\n  _transformPoints: function _transformPoints(path, angle, scale, rotationOrigin, scaleOrigin) {\n    var map = path._map;\n    var zoom = map.getMaxZoom() || this.options.maxZoom;\n    var i, len;\n\n    var projectedMatrix = this._projectedMatrix = this._getProjectedMatrix(angle, scale, rotationOrigin, scaleOrigin);\n\n    if (path._point) {\n      path._latlng = this._transformPoint(path._latlng, projectedMatrix, map, zoom);\n    } else if (path._rings || path._parts) {\n      var rings = path._rings;\n      var latlngs = path._latlngs;\n      path._bounds = new _leaflet2.default.LatLngBounds();\n\n      if (!_leaflet2.default.Util.isArray(latlngs[0])) {\n        latlngs = [latlngs];\n      }\n      for (i = 0, len = rings.length; i < len; i++) {\n        for (var j = 0, jj = rings[i].length; j < jj; j++) {\n          latlngs[i][j] = this._transformPoint(latlngs[i][j], projectedMatrix, map, zoom);\n          path._bounds.extend(latlngs[i][j]);\n        }\n      }\n    }\n\n    path._reset();\n  },\n\n  _createHandlers: function _createHandlers() {\n    var map = this._map;\n    this._handlersGroup = this._handlersGroup || new _leaflet2.default.LayerGroup().addTo(map);\n    this._rect = this._rect || this._getBoundingPolygon().addTo(this._handlersGroup);\n\n    if (this.options.scaling) {\n      this._handlers = [];\n      for (var i = 0; i < this.options.edgesCount; i++) {\n        this._handlers.push(this._createHandler(this._rect._latlngs[0][i], i * 2, i).addTo(this._handlersGroup));\n      }\n    }\n\n    if (this.options.rotation) {\n      this._createRotationHandlers();\n    }\n  },\n\n  _createRotationHandlers: function _createRotationHandlers() {\n    var map = this._map;\n    var latlngs = this._rect._latlngs[0];\n\n    var bottom = new _leaflet2.default.LatLng((latlngs[0].lat + latlngs[3].lat) / 2, (latlngs[0].lng + latlngs[3].lng) / 2);\n\n    var topPoint = new _leaflet2.default.LatLng((latlngs[1].lat + latlngs[2].lat) / 2, (latlngs[1].lng + latlngs[2].lng) / 2);\n\n    var handlerPosition = map.layerPointToLatLng(_leaflet2.default.PathTransform.pointOnLine(map.latLngToLayerPoint(bottom), map.latLngToLayerPoint(topPoint), this.options.handleLength));\n\n    this._handleLine = new _leaflet2.default.Polyline([topPoint, handlerPosition], this.options.rotateHandleOptions).addTo(this._handlersGroup);\n    var RotateHandleClass = this.options.rotateHandleClass;\n    this._rotationMarker = new RotateHandleClass(handlerPosition, this.options.handlerOptions).addTo(this._handlersGroup).on('mousedown', this._onRotateStart, this);\n\n    this._rotationOrigin = new _leaflet2.default.LatLng((topPoint.lat + bottom.lat) / 2, (topPoint.lng + bottom.lng) / 2);\n\n    this._handlers.push(this._rotationMarker);\n  },\n\n  _getRotationOrigin: function _getRotationOrigin() {\n    var latlngs = this._rect._latlngs[0];\n    var lb = latlngs[0];\n    var rt = latlngs[2];\n\n    return new _leaflet2.default.LatLng((lb.lat + rt.lat) / 2, (lb.lng + rt.lng) / 2);\n  },\n\n  _onRotateStart: function _onRotateStart(evt) {\n    var map = this._map;\n\n    map.dragging.disable();\n\n    this._originMarker = null;\n    this._rotationOriginPt = map.latLngToLayerPoint(this._getRotationOrigin());\n    this._rotationStart = evt.layerPoint;\n    this._initialMatrix = this._matrix.clone();\n\n    this._angle = 0;\n    this._path._map.on('mousemove', this._onRotate, this).on('mouseup', this._onRotateEnd, this);\n\n    this._cachePoints();\n    this._path.fire('transformstart', { layer: this._path }).fire('rotatestart', { layer: this._path, rotation: 0 });\n  },\n\n  _onRotate: function _onRotate(evt) {\n    var pos = evt.layerPoint;\n    var previous = this._rotationStart;\n    var origin = this._rotationOriginPt;\n\n    this._angle = Math.atan2(pos.y - origin.y, pos.x - origin.x) - Math.atan2(previous.y - origin.y, previous.x - origin.x);\n\n    this._matrix = this._initialMatrix.clone().rotate(this._angle, origin).flip();\n\n    this._update();\n    this._path.fire('rotate', { layer: this._path, rotation: this._angle });\n  },\n\n  _onRotateEnd: function _onRotateEnd(evt) {\n    this._path._map.off('mousemove', this._onRotate, this).off('mouseup', this._onRotateEnd, this);\n\n    this._apply();\n    this._path.fire('rotateend', { layer: this._path, rotation: this._angle });\n  },\n\n  _onScaleStart: function _onScaleStart(evt) {\n    var marker = evt.target;\n    var map = this._map;\n\n    map.dragging.disable();\n\n    this._activeMarker = marker;\n\n    this._originMarker = this._handlers[(marker.options.index + 2) % 4];\n    this._scaleOrigin = this._originMarker.getLatLng();\n\n    this._initialMatrix = this._matrix.clone();\n    this._cachePoints();\n\n    this._map.on('mousemove', this._onScale, this).on('mouseup', this._onScaleEnd, this);\n    this._initialDist = this._originMarker._point.distanceTo(this._activeMarker._point);\n    this._initialDistX = this._originMarker._point.x - this._activeMarker._point.x;\n    this._initialDistY = this._originMarker._point.y - this._activeMarker._point.y;\n\n    this._path.fire('transformstart', { layer: this._path }).fire('scalestart', { layer: this._path, scale: _leaflet2.default.point(1, 1) });\n\n    this._map.removeLayer(this._handleLine);\n    this._map.removeLayer(this._rotationMarker);\n  },\n\n  _onScale: function _onScale(evt) {\n    var originPoint = this._originMarker._point;\n    var ratioX, ratioY;\n    if (this.options.uniformScaling) {\n      ratioX = originPoint.distanceTo(evt.layerPoint) / this._initialDist;\n      ratioY = ratioX;\n    } else {\n      ratioX = (originPoint.x - evt.layerPoint.x) / this._initialDistX;\n      ratioY = (originPoint.y - evt.layerPoint.y) / this._initialDistY;\n    }\n\n    this._scale = new _leaflet2.default.Point(ratioX, ratioY);\n\n    this._matrix = this._initialMatrix.clone().scale(this._scale, originPoint);\n\n    this._update();\n    this._path.fire('scale', {\n      layer: this._path, scale: this._scale.clone() });\n  },\n\n  _onScaleEnd: function _onScaleEnd(evt) {\n    this._map.off('mousemove', this._onScale, this).off('mouseup', this._onScaleEnd, this);\n\n    this._map.addLayer(this._handleLine);\n    this._map.addLayer(this._rotationMarker);\n\n    this._apply();\n    this._path.fire('scaleend', {\n      layer: this._path, scale: this._scale.clone() });\n  },\n\n  _cachePoints: function _cachePoints() {\n    this._handlersGroup.eachLayer(function (layer) {\n      layer.bringToFront();\n    });\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      handler._initialPoint = handler._point.clone();\n    }\n  },\n\n  _getBoundingPolygon: function _getBoundingPolygon() {\n    if (this._rectShape) {\n      return _leaflet2.default.GeoJSON.geometryToLayer(this._rectShape, this.options.boundsOptions);\n    } else {\n      return new _leaflet2.default.Rectangle(this._path.getBounds(), this.options.boundsOptions);\n    }\n  },\n\n  _createHandler: function _createHandler(latlng, type, index) {\n    var HandleClass = this.options.handleClass;\n    var marker = new HandleClass(latlng, _leaflet2.default.Util.extend({}, this.options.handlerOptions, {\n      className: 'leaflet-drag-transform-marker drag-marker--' + index + ' drag-marker--' + type,\n      index: index,\n      type: type\n    }));\n\n    marker.on('mousedown', this._onScaleStart, this);\n    return marker;\n  },\n\n  _hideHandlers: function _hideHandlers() {\n    this._map.removeLayer(this._handlersGroup);\n  },\n\n  _onDragStart: function _onDragStart() {\n    this._hideHandlers();\n  },\n\n  _onDragEnd: function _onDragEnd(evt) {\n    var rect = this._rect;\n    var matrix = (evt.layer ? evt.layer : this._path).dragging._matrix.slice();\n\n    if (!rect.dragging) {\n      rect.dragging = new _leaflet2.default.Handler.PathDrag(rect);\n    }\n    rect.dragging.enable();\n    this._map.addLayer(rect);\n    rect.dragging._transformPoints(matrix);\n    rect._updatePath();\n    rect._project();\n\n    rect.dragging.disable();\n\n    this._map.addLayer(this._handlersGroup);\n    this._updateHandlers();\n\n    this._path.fire('transformed', {\n      scale: _leaflet2.default.point(1, 1),\n      rotation: 0,\n      matrix: _leaflet2.default.matrix.apply(undefined, matrix),\n      translate: _leaflet2.default.point(matrix[4], matrix[5]),\n      layer: this._path\n    });\n  }\n});\n\n_leaflet2.default.Path.addInitHook(function () {\n  if (this.options.transform) {\n    this.transform = new _leaflet2.default.Handler.PathTransform(this, this.options.transform);\n  }\n});\n\nexports.L = _leaflet2.default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkwuUGF0aC5UcmFuc2Zvcm0tc3JjLmpzIl0sIm5hbWVzIjpbIkwiLCJVdGlsIiwibWVyZ2UiLCJleHRlbmQiLCJQYXRoIiwiaW5jbHVkZSIsIl90cmFuc2Zvcm0iLCJtYXRyaXgiLCJfcmVuZGVyZXIiLCJ0cmFuc2Zvcm1QYXRoIiwiX3Jlc2V0VHJhbnNmb3JtUGF0aCIsIl91cGRhdGUiLCJfb25Nb3VzZUNsaWNrIiwiZSIsImRyYWdnaW5nIiwibW92ZWQiLCJfbWFwIiwiX2ZpcmVNb3VzZUV2ZW50IiwiRU5EIiwibW91c2Vkb3duIiwidG91Y2hzdGFydCIsInBvaW50ZXJkb3duIiwiTVNQb2ludGVyRG93biIsIk1PVkUiLCJkaXN0YW5jZSIsImEiLCJiIiwiZHgiLCJ4IiwiZHkiLCJ5IiwiTWF0aCIsInNxcnQiLCJIYW5kbGVyIiwiUGF0aERyYWciLCJzdGF0aWNzIiwiRFJBR0dJTkdfQ0xTIiwiaW5pdGlhbGl6ZSIsInBhdGgiLCJfcGF0aCIsIl9tYXRyaXgiLCJfc3RhcnRQb2ludCIsIl9kcmFnU3RhcnRQb2ludCIsIl9tYXBEcmFnZ2luZ1dhc0VuYWJsZWQiLCJhZGRIb29rcyIsIm9uIiwiX29uRHJhZ1N0YXJ0Iiwib3B0aW9ucyIsImNsYXNzTmFtZSIsIkRvbVV0aWwiLCJhZGRDbGFzcyIsInJlbW92ZUhvb2tzIiwib2ZmIiwicmVwbGFjZSIsIlJlZ0V4cCIsInJlbW92ZUNsYXNzIiwiX2RyYWdNb3ZlZCIsImV2dCIsImV2ZW50VHlwZSIsIm9yaWdpbmFsRXZlbnQiLCJfc2ltdWxhdGVkIiwidHlwZSIsImNvbnRhaW5lclBvaW50IiwiY2xvbmUiLCJEb21FdmVudCIsInN0b3AiLCJfY29udGFpbmVyIiwiZG9jdW1lbnQiLCJfb25EcmFnIiwiX29uRHJhZ0VuZCIsImVuYWJsZWQiLCJkaXNhYmxlIiwiX3BvcHVwIiwiX2Nsb3NlIiwiX3JlcGxhY2VDb29yZEdldHRlcnMiLCJmaXJzdCIsInRvdWNoZXMiLCJsZW5ndGgiLCJtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCIsInRvdGFsTW91c2VEcmFnRGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwidGFwVG9sZXJhbmNlIiwiZmlyZSIsImJyaW5nVG9Gcm9udCIsIl90cmFuc2Zvcm1Qb2ludHMiLCJfdXBkYXRlUGF0aCIsIl9wcm9qZWN0IiwiX3Jlc3RvcmVDb29yZEdldHRlcnMiLCJjb250YWlucyIsIl9jb250YWluc1BvaW50IiwiZmFsc2VGbiIsInJlcXVlc3RBbmltRnJhbWUiLCJza2lwcGVkIiwiZmFrZVN0b3AiLCJlbmFibGUiLCJkZXN0IiwiaSIsImxlbiIsImxhdGxuZyIsInB4IiwicG9pbnQiLCJjcnMiLCJ0cmFuc2Zvcm1hdGlvbiIsInNjYWxlIiwiZ2V0Wm9vbSIsInByb2plY3Rpb24iLCJkaWZmIiwidW50cmFuc2Zvcm0iLCJzdWJ0cmFjdCIsImFwcGx5VHJhbnNmb3JtIiwiX2JvdW5kcyIsIkxhdExuZ0JvdW5kcyIsIl9wb2ludCIsInVucHJvamVjdCIsInByb2plY3QiLCJfbGF0bG5nIiwiX2FkZCIsIl9yaW5ncyIsIl9wYXJ0cyIsInJpbmdzIiwibGF0bG5ncyIsIl9sYXRsbmdzIiwiaXNBcnJheSIsImoiLCJqaiIsImdldExhdExuZyIsImdldExhdExuZ18iLCJiaW5kIiwiZ2V0TGF0TG5ncyIsImdldExhdExuZ3NfIiwibWFrZURyYWdnYWJsZSIsImxheWVyIiwicHJvdG90eXBlIiwiYWRkSW5pdEhvb2siLCJkcmFnZ2FibGUiLCJpbnRlcmFjdGl2ZSIsIlNWRyIsInNldEF0dHJpYnV0ZU5TIiwiam9pbiIsIkJyb3dzZXIiLCJ2bWwiLCJfc2tldyIsInJlbW92ZUNoaWxkIiwic2tldyIsImNyZWF0ZSIsImFwcGVuZENoaWxkIiwic3R5bGUiLCJiZWhhdmlvciIsIm10IiwidG9GaXhlZCIsIm9mZnNldCIsImZsb29yIiwicyIsImwiLCJwYXJzZUZsb2F0IiwibGVmdCIsInQiLCJ0b3AiLCJ3Iiwid2lkdGgiLCJoIiwiaGVpZ2h0IiwiaXNOYU4iLCJvcmlnaW4iLCJUUlVFX0ZOIiwiQ2FudmFzIiwiX2NvbnRhaW5lckNvcHkiLCJfY29udGFpbnNQb2ludF8iLCJfcmVxdWVzdFJlZHJhdyIsImNvcHkiLCJjdHgiLCJfY3R4IiwiY29weUN0eCIsIm0iLCJyZXRpbmEiLCJib3VuZHMiLCJzaXplIiwiZ2V0U2l6ZSIsInBvcyIsIm1pbiIsImNyZWF0ZUVsZW1lbnQiLCJnZXRDb250ZXh0IiwiX3JlbW92ZVBhdGgiLCJfcmVkcmF3IiwidHJhbnNsYXRlIiwiZHJhd0ltYWdlIiwiX2luaXRQYXRoIiwic2F2ZSIsImNsZWFyUmVjdCIsInNldFRyYW5zZm9ybSIsInJlc3RvcmUiLCJ0cmFuc2Zvcm0iLCJhcHBseSIsIl9kcmF3aW5nIiwiUGF0aFRyYW5zZm9ybSIsInBvaW50T25MaW5lIiwic3RhcnQiLCJmaW5hbCIsImRpc3RQeCIsInJhdGlvIiwiUG9pbnQiLCJrZXkiLCJ2YWwiLCJvYmoiLCJhcmd1bWVudHMiLCJpc09iamVjdCIsIm9iamVjdCIsIk9iamVjdCIsInRvU3RyaW5nIiwiY2FsbCIsInRhcmdldCIsImhhc093blByb3BlcnR5IiwiTWF0cml4IiwiYyIsImQiLCJmIiwidW5kZWZpbmVkIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJzY2FsZVgiLCJzY2FsZVkiLCJyb3RhdGUiLCJhbmdsZSIsImNvcyIsInNpbiIsImZsaXAiLCJyZXN1bHQiLCJzcmMiLCJvdGhlciIsImsiLCJIYW5kbGUiLCJDaXJjbGVNYXJrZXIiLCJvbkFkZCIsIm1hcCIsInNldEN1cnNvciIsImN1cnNvciIsIkN1cnNvcnNCeVR5cGUiLCJpbmRleCIsIlJvdGF0ZUhhbmRsZSIsInJvdGF0aW9uIiwic2NhbGluZyIsInVuaWZvcm1TY2FsaW5nIiwibWF4Wm9vbSIsImhhbmRsZXJPcHRpb25zIiwicmFkaXVzIiwiZmlsbENvbG9yIiwiY29sb3IiLCJmaWxsT3BhY2l0eSIsIndlaWdodCIsIm9wYWNpdHkiLCJib3VuZHNPcHRpb25zIiwiZGFzaEFycmF5IiwiZmlsbCIsInJvdGF0ZUhhbmRsZU9wdGlvbnMiLCJoYW5kbGVMZW5ndGgiLCJlZGdlc0NvdW50IiwiaGFuZGxlQ2xhc3MiLCJyb3RhdGVIYW5kbGVDbGFzcyIsIl9hY3RpdmVNYXJrZXIiLCJfb3JpZ2luTWFya2VyIiwiX3JvdGF0aW9uTWFya2VyIiwiX3JvdGF0aW9uT3JpZ2luIiwiX3NjYWxlT3JpZ2luIiwiX2FuZ2xlIiwiX3NjYWxlIiwiX2luaXRpYWxEaXN0IiwiX2luaXRpYWxEaXN0WCIsIl9pbml0aWFsRGlzdFkiLCJfcm90YXRpb25TdGFydCIsIl9yb3RhdGlvbk9yaWdpblB0IiwiX3Byb2plY3RlZE1hdHJpeCIsIl9oYW5kbGVyc0dyb3VwIiwiX3JlY3QiLCJfaGFuZGxlcnMiLCJfaGFuZGxlTGluZSIsInNldE9wdGlvbnMiLCJfY3JlYXRlSGFuZGxlcnMiLCJfaGlkZUhhbmRsZXJzIiwiX2VuYWJsZWQiLCJyb3RhdGlvbk9yaWdpbiIsInNjYWxlT3JpZ2luIiwiY2VudGVyIiwiZ2V0Q2VudGVyIiwiaGFuZGxlciIsIl9pbml0aWFsUG9pbnQiLCJfYXBwbHlUcmFuc2Zvcm0iLCJfYXBwbHkiLCJfdHJhbnNmb3JtR2VvbWV0cmllcyIsImxheWVyUG9pbnRUb0xhdExuZyIsInJlZHJhdyIsIl91cGRhdGVIYW5kbGVycyIsInJlc2V0IiwicmVtb3ZlTGF5ZXIiLCJfZ2V0Qm91bmRpbmdQb2x5Z29uIiwiYWRkVG8iLCJoYW5kbGVyc0dyb3VwIiwiX3JlY3RTaGFwZSIsInRvR2VvSlNPTiIsIl9vcmlnaW4iLCJfZ2V0UHJvamVjdGVkTWF0cml4Iiwiem9vbSIsImdldE1heFpvb20iLCJfdHJhbnNmb3JtUG9pbnQiLCJwcm9qZWN0ZWRNYXRyaXgiLCJfcmVzZXQiLCJMYXllckdyb3VwIiwicHVzaCIsIl9jcmVhdGVIYW5kbGVyIiwiX2NyZWF0ZVJvdGF0aW9uSGFuZGxlcnMiLCJib3R0b20iLCJMYXRMbmciLCJsYXQiLCJsbmciLCJ0b3BQb2ludCIsImhhbmRsZXJQb3NpdGlvbiIsImxhdExuZ1RvTGF5ZXJQb2ludCIsIlBvbHlsaW5lIiwiUm90YXRlSGFuZGxlQ2xhc3MiLCJfb25Sb3RhdGVTdGFydCIsIl9nZXRSb3RhdGlvbk9yaWdpbiIsImxiIiwicnQiLCJsYXllclBvaW50IiwiX2luaXRpYWxNYXRyaXgiLCJfb25Sb3RhdGUiLCJfb25Sb3RhdGVFbmQiLCJfY2FjaGVQb2ludHMiLCJwcmV2aW91cyIsImF0YW4yIiwiX29uU2NhbGVTdGFydCIsIm1hcmtlciIsIl9vblNjYWxlIiwiX29uU2NhbGVFbmQiLCJvcmlnaW5Qb2ludCIsInJhdGlvWCIsInJhdGlvWSIsImFkZExheWVyIiwiZWFjaExheWVyIiwiR2VvSlNPTiIsImdlb21ldHJ5VG9MYXllciIsIlJlY3RhbmdsZSIsImdldEJvdW5kcyIsIkhhbmRsZUNsYXNzIiwicmVjdCIsInNsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7OztBQUNBQSxrQkFBRUMsSUFBRixDQUFPQyxLQUFQLEdBQWVGLGtCQUFFQyxJQUFGLENBQU9FLE1BQXRCO0FBQ0E7Ozs7OztBQVVBSCxrQkFBRUksSUFBRixDQUFPQyxPQUFQLENBQWU7QUFNZEMsY0FBWSxvQkFBU0MsTUFBVCxFQUFpQjtBQUM1QixRQUFJLEtBQUtDLFNBQVQsRUFBb0I7QUFDbkIsVUFBSUQsTUFBSixFQUFZO0FBQ1gsYUFBS0MsU0FBTCxDQUFlQyxhQUFmLENBQTZCLElBQTdCLEVBQW1DRixNQUFuQztBQUNBLE9BRkQsTUFFTztBQUVOLGFBQUtDLFNBQUwsQ0FBZUUsbUJBQWYsQ0FBbUMsSUFBbkM7QUFDQSxhQUFLQyxPQUFMO0FBQ0E7QUFDRDtBQUNELFdBQU8sSUFBUDtBQUNBLEdBakJhOztBQXlCZEMsaUJBQWUsdUJBQVNDLENBQVQsRUFBWTtBQUMxQixRQUFLLEtBQUtDLFFBQUwsSUFBaUIsS0FBS0EsUUFBTCxDQUFjQyxLQUFkLEVBQWxCLElBQ0YsS0FBS0MsSUFBTCxDQUFVRixRQUFWLElBQXNCLEtBQUtFLElBQUwsQ0FBVUYsUUFBVixDQUFtQkMsS0FBbkIsRUFEeEIsRUFDcUQ7QUFDcEQ7QUFDQTs7QUFFRCxTQUFLRSxl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QVQsQ0FBZXdCLFNBQWYsRUFBMEJqTixNQUExQixDQUhxQjtBQUk3QmlMLGlCQUFXeEwsa0JBQUVvRyxLQUFGLENBQVE3RixPQUFPLENBQVAsQ0FBUixFQUFtQkEsT0FBTyxDQUFQLENBQW5CLENBSmtCO0FBSzdCNEgsYUFBTyxLQUFLNUY7QUFMaUIsS0FBL0I7QUFPRDtBQXZ0QndDLENBQWpCLENBQTFCOztBQTJ0QkF2QyxrQkFBRUksSUFBRixDQUFPaUksV0FBUCxDQUFtQixZQUFXO0FBQzVCLE1BQUksS0FBS3RGLE9BQUwsQ0FBYWdKLFNBQWpCLEVBQTRCO0FBQzFCLFNBQUtBLFNBQUwsR0FBaUIsSUFBSS9MLGtCQUFFaUMsT0FBRixDQUFVaUssYUFBZCxDQUE0QixJQUE1QixFQUFrQyxLQUFLbkosT0FBTCxDQUFhZ0osU0FBL0MsQ0FBakI7QUFDRDtBQUNGLENBSkQ7O1FBT1EvTCxDLEdBQUFBLGlCIiwiZmlsZSI6IkwuUGF0aC5UcmFuc2Zvcm0tc3JjLmpzIiwic291cmNlUm9vdCI6Ii93d3cvc2l0ZXMvdnVlMi1sZWFmbGV0LXBhdGh0cmFuc2Zvcm0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTCBmcm9tICdsZWFmbGV0JztcbkwuVXRpbC5tZXJnZSA9IEwuVXRpbC5leHRlbmQ7XG4vKipcbiAqIExlYWZsZXQgdmVjdG9yIGZlYXR1cmVzIGRyYWcgZnVuY3Rpb25hbGl0eVxuICogQGF1dGhvciBBbGV4YW5kZXIgTWlsZXZza2kgPGluZm9AdzhyLm5hbWU+XG4gKiBAcHJlc2VydmVcbiAqL1xuXG4vKipcbiAqIE1hdHJpeCB0cmFuc2Zvcm0gcGF0aCBmb3IgU1ZHL1ZNTFxuICogUmVuZGVyZXItaW5kZXBlbmRlbnRcbiAqL1xuTC5QYXRoLmluY2x1ZGUoe1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIG1hdHJpeCB0cmFuc2Zvcm1hdGlvbiB0byBTVkdcblx0ICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj99IG1hdHJpeFxuXHQgKi9cblx0X3RyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdHRoaXMuX3JlbmRlcmVyLnRyYW5zZm9ybVBhdGgodGhpcywgbWF0cml4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlc2V0IHRyYW5zZm9ybSBtYXRyaXhcblx0XHRcdFx0dGhpcy5fcmVuZGVyZXIuX3Jlc2V0VHJhbnNmb3JtUGF0aCh0aGlzKTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgZmVhdHVyZSB3YXMgZHJhZ2dlZCwgdGhhdCdsbCBzdXByZXNzIHRoZSBjbGljayBldmVudFxuXHQgKiBvbiBtb3VzZXVwLiBUaGF0IGZpeGVzIHBvcHVwcyBmb3IgZXhhbXBsZVxuXHQgKlxuXHQgKiBAcGFyYW0gIHtNb3VzZUV2ZW50fSBlXG5cdCAqL1xuXHRfb25Nb3VzZUNsaWNrOiBmdW5jdGlvbihlKSB7XG5cdFx0aWYgKCh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcubW92ZWQoKSkgfHxcblx0XHRcdCh0aGlzLl9tYXAuZHJhZ2dpbmcgJiYgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmVkKCkpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlyZU1vdXNlRXZlbnQoZSk7XG5cdH1cblxufSk7XG52YXIgRU5EID0ge1xuICBtb3VzZWRvd246ICAgICAnbW91c2V1cCcsXG4gIHRvdWNoc3RhcnQ6ICAgICd0b3VjaGVuZCcsXG4gIHBvaW50ZXJkb3duOiAgICd0b3VjaGVuZCcsXG4gIE1TUG9pbnRlckRvd246ICd0b3VjaGVuZCdcbn07XG5cbnZhciBNT1ZFID0ge1xuICBtb3VzZWRvd246ICAgICAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hzdGFydDogICAgJ3RvdWNobW92ZScsXG4gIHBvaW50ZXJkb3duOiAgICd0b3VjaG1vdmUnLFxuICBNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xufTtcblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgZHggPSBhLnggLSBiLngsIGR5ID0gYS55IC0gYi55O1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbn1cblxuLyoqXG4gKiBEcmFnIGhhbmRsZXJcbiAqIEBjbGFzcyBMLlBhdGguRHJhZ1xuICogQGV4dGVuZHMge0wuSGFuZGxlcn1cbiAqL1xuTC5IYW5kbGVyLlBhdGhEcmFnID0gTC5IYW5kbGVyLmV4dGVuZCggLyoqIEBsZW5kcyAgTC5QYXRoLkRyYWcucHJvdG90eXBlICovIHtcblxuICBzdGF0aWNzOiB7XG4gICAgRFJBR0dJTkdfQ0xTOiAnbGVhZmxldC1wYXRoLWRyYWdnYWJsZScsXG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtICB7TC5QYXRofSBwYXRoXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCkge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0wuUGF0aH1cbiAgICAgKi9cbiAgICB0aGlzLl9wYXRoID0gcGF0aDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48TnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9tYXRyaXggPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0wuUG9pbnR9XG4gICAgICovXG4gICAgdGhpcy5fc3RhcnRQb2ludCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TC5Qb2ludH1cbiAgICAgKi9cbiAgICB0aGlzLl9kcmFnU3RhcnRQb2ludCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9tYXBEcmFnZ2luZ1dhc0VuYWJsZWQgPSBmYWxzZTtcblxuICB9LFxuXG4gIC8qKlxuICAgKiBFbmFibGUgZHJhZ2dpbmdcbiAgICovXG4gIGFkZEhvb2tzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wYXRoLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9vbkRyYWdTdGFydCwgdGhpcyk7XG5cbiAgICB0aGlzLl9wYXRoLm9wdGlvbnMuY2xhc3NOYW1lID0gdGhpcy5fcGF0aC5vcHRpb25zLmNsYXNzTmFtZSA/XG4gICAgICAgICh0aGlzLl9wYXRoLm9wdGlvbnMuY2xhc3NOYW1lICsgJyAnICsgTC5IYW5kbGVyLlBhdGhEcmFnLkRSQUdHSU5HX0NMUykgOlxuICAgICAgICAgTC5IYW5kbGVyLlBhdGhEcmFnLkRSQUdHSU5HX0NMUztcblxuICAgIGlmICh0aGlzLl9wYXRoLl9wYXRoKSB7XG4gICAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fcGF0aC5fcGF0aCwgTC5IYW5kbGVyLlBhdGhEcmFnLkRSQUdHSU5HX0NMUyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIGRyYWdnaW5nXG4gICAqL1xuICByZW1vdmVIb29rczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcGF0aC5vZmYoJ21vdXNlZG93bicsIHRoaXMuX29uRHJhZ1N0YXJ0LCB0aGlzKTtcblxuICAgIHRoaXMuX3BhdGgub3B0aW9ucy5jbGFzc05hbWUgPSB0aGlzLl9wYXRoLm9wdGlvbnMuY2xhc3NOYW1lXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxccysnICsgTC5IYW5kbGVyLlBhdGhEcmFnLkRSQUdHSU5HX0NMUyksICcnKTtcbiAgICBpZiAodGhpcy5fcGF0aC5fcGF0aCkge1xuICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3BhdGguX3BhdGgsIEwuSGFuZGxlci5QYXRoRHJhZy5EUkFHR0lOR19DTFMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIG1vdmVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aC5fZHJhZ01vdmVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdGFydCBkcmFnXG4gICAqIEBwYXJhbSAge0wuTW91c2VFdmVudH0gZXZ0XG4gICAqL1xuICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciBldmVudFR5cGUgPSBldnQub3JpZ2luYWxFdmVudC5fc2ltdWxhdGVkID8gJ3RvdWNoc3RhcnQnIDogZXZ0Lm9yaWdpbmFsRXZlbnQudHlwZTtcblxuICAgIHRoaXMuX21hcERyYWdnaW5nV2FzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXJ0UG9pbnQgPSBldnQuY29udGFpbmVyUG9pbnQuY2xvbmUoKTtcbiAgICB0aGlzLl9kcmFnU3RhcnRQb2ludCA9IGV2dC5jb250YWluZXJQb2ludC5jbG9uZSgpO1xuICAgIHRoaXMuX21hdHJpeCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICBMLkRvbUV2ZW50LnN0b3AoZXZ0Lm9yaWdpbmFsRXZlbnQpO1xuXG4gICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3BhdGguX3JlbmRlcmVyLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG4gICAgTC5Eb21FdmVudFxuICAgICAgLm9uKGRvY3VtZW50LCBNT1ZFW2V2ZW50VHlwZV0sIHRoaXMuX29uRHJhZywgICAgdGhpcylcbiAgICAgIC5vbihkb2N1bWVudCwgRU5EW2V2ZW50VHlwZV0sICB0aGlzLl9vbkRyYWdFbmQsIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX3BhdGguX21hcC5kcmFnZ2luZy5lbmFibGVkKCkpIHtcbiAgICAgIC8vIEkgZ3Vlc3MgaXQncyByZXF1aXJlZCBiZWNhdXNlIG1vdXNkb3duIGdldHMgc2ltdWxhdGVkIHdpdGggYSBkZWxheVxuICAgICAgLy90aGlzLl9wYXRoLl9tYXAuZHJhZ2dpbmcuX2RyYWdnYWJsZS5fb25VcChldnQpO1xuXG4gICAgICB0aGlzLl9wYXRoLl9tYXAuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICAgICAgdGhpcy5fbWFwRHJhZ2dpbmdXYXNFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fcGF0aC5fZHJhZ01vdmVkID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5fcGF0aC5fcG9wdXApIHsgLy8gdGhhdCBtaWdodCBiZSBhIGNhc2Ugb24gdG91Y2ggZGV2aWNlcyBhcyB3ZWxsXG4gICAgICB0aGlzLl9wYXRoLl9wb3B1cC5fY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXBsYWNlQ29vcmRHZXR0ZXJzKGV2dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERyYWdnaW5nXG4gICAqIEBwYXJhbSAge0wuTW91c2VFdmVudH0gZXZ0XG4gICAqL1xuICBfb25EcmFnOiBmdW5jdGlvbihldnQpIHtcbiAgICBMLkRvbUV2ZW50LnN0b3AoZXZ0KTtcblxuICAgIHZhciBmaXJzdCA9IChldnQudG91Y2hlcyAmJiBldnQudG91Y2hlcy5sZW5ndGggPj0gMSA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KTtcbiAgICB2YXIgY29udGFpbmVyUG9pbnQgPSB0aGlzLl9wYXRoLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZmlyc3QpO1xuXG4gICAgLy8gc2tpcCB0YXBzXG4gICAgaWYgKGV2dC50eXBlID09PSAndG91Y2htb3ZlJyAmJiAhdGhpcy5fcGF0aC5fZHJhZ01vdmVkKSB7XG4gICAgICB2YXIgdG90YWxNb3VzZURyYWdEaXN0YW5jZSA9IHRoaXMuX2RyYWdTdGFydFBvaW50LmRpc3RhbmNlVG8oY29udGFpbmVyUG9pbnQpO1xuICAgICAgaWYgKHRvdGFsTW91c2VEcmFnRGlzdGFuY2UgPD0gdGhpcy5fcGF0aC5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeCA9IGNvbnRhaW5lclBvaW50Lng7XG4gICAgdmFyIHkgPSBjb250YWluZXJQb2ludC55O1xuXG4gICAgdmFyIGR4ID0geCAtIHRoaXMuX3N0YXJ0UG9pbnQueDtcbiAgICB2YXIgZHkgPSB5IC0gdGhpcy5fc3RhcnRQb2ludC55O1xuXG4gICAgLy8gU2VuZCBldmVudHMgb25seSBpZiBwb2ludCB3YXMgbW92ZWRcbiAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgIGlmICghdGhpcy5fcGF0aC5fZHJhZ01vdmVkKSB7XG4gICAgICAgIHRoaXMuX3BhdGguX2RyYWdNb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhdGguZmlyZSgnZHJhZ3N0YXJ0JywgZXZ0KTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGhhcHBlbiBvbiBjbGlja1xuICAgICAgICB0aGlzLl9wYXRoLmJyaW5nVG9Gcm9udCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYXRyaXhbNF0gKz0gZHg7XG4gICAgICB0aGlzLl9tYXRyaXhbNV0gKz0gZHk7XG5cbiAgICAgIHRoaXMuX3N0YXJ0UG9pbnQueCA9IHg7XG4gICAgICB0aGlzLl9zdGFydFBvaW50LnkgPSB5O1xuXG4gICAgICB0aGlzLl9wYXRoLmZpcmUoJ3ByZWRyYWcnLCBldnQpO1xuICAgICAgdGhpcy5fcGF0aC5fdHJhbnNmb3JtKHRoaXMuX21hdHJpeCk7XG4gICAgICB0aGlzLl9wYXRoLmZpcmUoJ2RyYWcnLCBldnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRHJhZ2dpbmcgc3RvcHBlZCwgYXBwbHlcbiAgICogQHBhcmFtICB7TC5Nb3VzZUV2ZW50fSBldnRcbiAgICovXG4gIF9vbkRyYWdFbmQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciBjb250YWluZXJQb2ludCA9IHRoaXMuX3BhdGguX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldnQpO1xuICAgIHZhciBtb3ZlZCA9IHRoaXMubW92ZWQoKTtcblxuICAgIC8vIGFwcGx5IG1hdHJpeFxuICAgIGlmIChtb3ZlZCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtUG9pbnRzKHRoaXMuX21hdHJpeCk7XG4gICAgICB0aGlzLl9wYXRoLl91cGRhdGVQYXRoKCk7XG4gICAgICB0aGlzLl9wYXRoLl9wcm9qZWN0KCk7XG4gICAgICB0aGlzLl9wYXRoLl90cmFuc2Zvcm0obnVsbCk7XG5cbiAgICAgIEwuRG9tRXZlbnQuc3RvcChldnQpO1xuICAgIH1cblxuXG4gICAgTC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUgdG91Y2htb3ZlJywgdGhpcy5fb25EcmFnLCAgICB0aGlzKTtcbiAgICBMLkRvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ21vdXNldXAgdG91Y2hlbmQnLCAgICB0aGlzLl9vbkRyYWdFbmQsIHRoaXMpO1xuXG4gICAgdGhpcy5fcmVzdG9yZUNvb3JkR2V0dGVycygpO1xuXG4gICAgLy8gY29uc2lzdGVuY3lcbiAgICBpZiAobW92ZWQpIHtcbiAgICAgIHRoaXMuX3BhdGguZmlyZSgnZHJhZ2VuZCcsIHtcbiAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlKHRoaXMuX2RyYWdTdGFydFBvaW50LCBjb250YWluZXJQb2ludClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYWNrIGZvciBza2lwcGluZyB0aGUgY2xpY2sgaW4gY2FudmFzLXJlbmRlcmVkIGxheWVyc1xuICAgICAgdmFyIGNvbnRhaW5zID0gdGhpcy5fcGF0aC5fY29udGFpbnNQb2ludDtcbiAgICAgIHRoaXMuX3BhdGguX2NvbnRhaW5zUG9pbnQgPSBMLlV0aWwuZmFsc2VGbjtcbiAgICAgIEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBMLkRvbUV2ZW50LnNraXBwZWQoeyB0eXBlOiAnY2xpY2snIH0pO1xuICAgICAgICB0aGlzLl9wYXRoLl9jb250YWluc1BvaW50ID0gY29udGFpbnM7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXRyaXggICAgICAgICAgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0UG9pbnQgICAgICA9IG51bGw7XG4gICAgdGhpcy5fZHJhZ1N0YXJ0UG9pbnQgID0gbnVsbDtcbiAgICB0aGlzLl9wYXRoLl9kcmFnTW92ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLl9tYXBEcmFnZ2luZ1dhc0VuYWJsZWQpIHtcbiAgICAgIGlmIChtb3ZlZCkgTC5Eb21FdmVudC5mYWtlU3RvcCh7IHR5cGU6ICdjbGljaycgfSk7XG4gICAgICB0aGlzLl9wYXRoLl9tYXAuZHJhZ2dpbmcuZW5hYmxlKCk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdHJhbnNmb3JtYXRpb24sIGRvZXMgaXQgaW4gb25lIHN3ZWVwIGZvciBwZXJmb3JtYW5jZSxcbiAgICogc28gZG9uJ3QgYmUgc3VycHJpc2VkIGFib3V0IHRoZSBjb2RlIHJlcGV0aXRpb24uXG4gICAqXG4gICAqIFsgeCBdICAgWyBhICBiICB0eCBdIFsgeCBdICAgWyBhICogeCArIGIgKiB5ICsgdHggXVxuICAgKiBbIHkgXSA9IFsgYyAgZCAgdHkgXSBbIHkgXSA9IFsgYyAqIHggKyBkICogeSArIHR5IF1cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gbWF0cml4XG4gICAqL1xuICBfdHJhbnNmb3JtUG9pbnRzOiBmdW5jdGlvbihtYXRyaXgsIGRlc3QpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFyIGksIGxlbiwgbGF0bG5nO1xuXG4gICAgdmFyIHB4ID0gTC5wb2ludChtYXRyaXhbNF0sIG1hdHJpeFs1XSk7XG5cbiAgICB2YXIgY3JzID0gcGF0aC5fbWFwLm9wdGlvbnMuY3JzO1xuICAgIHZhciB0cmFuc2Zvcm1hdGlvbiA9IGNycy50cmFuc2Zvcm1hdGlvbjtcbiAgICB2YXIgc2NhbGUgPSBjcnMuc2NhbGUocGF0aC5fbWFwLmdldFpvb20oKSk7XG4gICAgdmFyIHByb2plY3Rpb24gPSBjcnMucHJvamVjdGlvbjtcblxuICAgIHZhciBkaWZmID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocHgsIHNjYWxlKVxuICAgICAgLnN1YnRyYWN0KHRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKEwucG9pbnQoMCwgMCksIHNjYWxlKSk7XG4gICAgdmFyIGFwcGx5VHJhbnNmb3JtID0gIWRlc3Q7XG5cbiAgICBwYXRoLl9ib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblxuICAgIC8vIGNvbnNvbGUudGltZSgndHJhbnNmb3JtJyk7XG4gICAgLy8gYWxsIHNoaWZ0cyBhcmUgaW4tcGxhY2VcbiAgICBpZiAocGF0aC5fcG9pbnQpIHsgLy8gTC5DaXJjbGVcbiAgICAgIGRlc3QgPSBwcm9qZWN0aW9uLnVucHJvamVjdChcbiAgICAgICAgcHJvamVjdGlvbi5wcm9qZWN0KHBhdGguX2xhdGxuZykuX2FkZChkaWZmKSk7XG4gICAgICBpZiAoYXBwbHlUcmFuc2Zvcm0pIHtcbiAgICAgICAgcGF0aC5fbGF0bG5nID0gZGVzdDtcbiAgICAgICAgcGF0aC5fcG9pbnQuX2FkZChweCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXRoLl9yaW5ncyB8fCBwYXRoLl9wYXJ0cykgeyAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICAgIHZhciByaW5ncyAgID0gcGF0aC5fcmluZ3MgfHwgcGF0aC5fcGFydHM7XG4gICAgICB2YXIgbGF0bG5ncyA9IHBhdGguX2xhdGxuZ3M7XG4gICAgICBkZXN0ID0gZGVzdCB8fCBsYXRsbmdzO1xuICAgICAgaWYgKCFMLlV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSkgeyAvLyBwb2x5bGluZVxuICAgICAgICBsYXRsbmdzID0gW2xhdGxuZ3NdO1xuICAgICAgICBkZXN0ICAgID0gW2Rlc3RdO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZGVzdFtpXSA9IGRlc3RbaV0gfHwgW107XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHJpbmdzW2ldLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICBsYXRsbmcgICAgID0gbGF0bG5nc1tpXVtqXTtcbiAgICAgICAgICBkZXN0W2ldW2pdID0gcHJvamVjdGlvblxuICAgICAgICAgICAgLnVucHJvamVjdChwcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKS5fYWRkKGRpZmYpKTtcbiAgICAgICAgICBpZiAoYXBwbHlUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHBhdGguX2JvdW5kcy5leHRlbmQobGF0bG5nc1tpXVtqXSk7XG4gICAgICAgICAgICByaW5nc1tpXVtqXS5fYWRkKHB4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gICAgLy8gY29uc29sZS50aW1lRW5kKCd0cmFuc2Zvcm0nKTtcbiAgfSxcblxuXG5cbiAgLyoqXG4gICAqIElmIHlvdSB3YW50IHRvIHJlYWQgdGhlIGxhdGxuZ3MgZHVyaW5nIHRoZSBkcmFnIC0geW91ciByaWdodCxcbiAgICogYnV0IHRoZXkgaGF2ZSB0byBiZSB0cmFuc2Zvcm1lZFxuICAgKi9cbiAgX3JlcGxhY2VDb29yZEdldHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wYXRoLmdldExhdExuZykgeyAvLyBDaXJjbGUsIENpcmNsZU1hcmtlclxuICAgICAgdGhpcy5fcGF0aC5nZXRMYXRMbmdfID0gdGhpcy5fcGF0aC5nZXRMYXRMbmc7XG4gICAgICB0aGlzLl9wYXRoLmdldExhdExuZyA9IEwuVXRpbC5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnZ2luZy5fdHJhbnNmb3JtUG9pbnRzKHRoaXMuZHJhZ2dpbmcuX21hdHJpeCwge30pO1xuICAgICAgfSwgdGhpcy5fcGF0aCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wYXRoLmdldExhdExuZ3MpIHtcbiAgICAgIHRoaXMuX3BhdGguZ2V0TGF0TG5nc18gPSB0aGlzLl9wYXRoLmdldExhdExuZ3M7XG4gICAgICB0aGlzLl9wYXRoLmdldExhdExuZ3MgPSBMLlV0aWwuYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ2dpbmcuX3RyYW5zZm9ybVBvaW50cyh0aGlzLmRyYWdnaW5nLl9tYXRyaXgsIFtdKTtcbiAgICAgIH0sIHRoaXMuX3BhdGgpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBQdXQgYmFjayB0aGUgZ2V0dGVyc1xuICAgKi9cbiAgX3Jlc3RvcmVDb29yZEdldHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wYXRoLmdldExhdExuZ18pIHtcbiAgICAgIHRoaXMuX3BhdGguZ2V0TGF0TG5nID0gdGhpcy5fcGF0aC5nZXRMYXRMbmdfO1xuICAgICAgZGVsZXRlIHRoaXMuX3BhdGguZ2V0TGF0TG5nXztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BhdGguZ2V0TGF0TG5nc18pIHtcbiAgICAgIHRoaXMuX3BhdGguZ2V0TGF0TG5ncyA9IHRoaXMuX3BhdGguZ2V0TGF0TG5nc187XG4gICAgICBkZWxldGUgdGhpcy5fcGF0aC5nZXRMYXRMbmdzXztcbiAgICB9XG4gIH1cblxufSk7XG5cblxuLyoqXG4gKiBAcGFyYW0gIHtMLlBhdGh9IGxheWVyXG4gKiBAcmV0dXJuIHtMLlBhdGh9XG4gKi9cbkwuSGFuZGxlci5QYXRoRHJhZy5tYWtlRHJhZ2dhYmxlID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgbGF5ZXIuZHJhZ2dpbmcgPSBuZXcgTC5IYW5kbGVyLlBhdGhEcmFnKGxheWVyKTtcbiAgcmV0dXJuIGxheWVyO1xufTtcblxuXG4vKipcbiAqIEFsc28gZXhwb3NlIGFzIGEgbWV0aG9kXG4gKiBAcmV0dXJuIHtMLlBhdGh9XG4gKi9cbkwuUGF0aC5wcm90b3R5cGUubWFrZURyYWdnYWJsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTC5IYW5kbGVyLlBhdGhEcmFnLm1ha2VEcmFnZ2FibGUodGhpcyk7XG59O1xuXG5cbkwuUGF0aC5hZGRJbml0SG9vayhmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpIHtcbiAgICAvLyBlbnN1cmUgaW50ZXJhY3RpdmVcbiAgICB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEwuSGFuZGxlci5QYXRoRHJhZy5tYWtlRHJhZ2dhYmxlKHRoaXMpO1xuICAgICAgdGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgIHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICB9XG59KTtcbkwuU1ZHLmluY2x1ZGUoe1xuXG5cdC8qKlxuXHQgKiBSZXNldCB0cmFuc2Zvcm0gbWF0cml4XG5cdCAqL1xuXHRfcmVzZXRUcmFuc2Zvcm1QYXRoOiBmdW5jdGlvbihsYXllcikge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICd0cmFuc2Zvcm0nLCAnJyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgbWF0cml4IHRyYW5zZm9ybWF0aW9uIHRvIFNWR1xuXHQgKiBAcGFyYW0ge0wuUGF0aH0gICAgICAgICBsYXllclxuXHQgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+fSBtYXRyaXhcblx0ICovXG5cdHRyYW5zZm9ybVBhdGg6IGZ1bmN0aW9uKGxheWVyLCBtYXRyaXgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAndHJhbnNmb3JtJyxcblx0XHRcdCdtYXRyaXgoJyArIG1hdHJpeC5qb2luKCcgJykgKyAnKScpO1xuXHR9XG5cbn0pO1xuTC5TVkcuaW5jbHVkZSghTC5Ccm93c2VyLnZtbCA/IHt9IDoge1xuXG5cdC8qKlxuXHQgKiBSZXNldCB0cmFuc2Zvcm0gbWF0cml4XG5cdCAqL1xuXHRfcmVzZXRUcmFuc2Zvcm1QYXRoOiBmdW5jdGlvbihsYXllcikge1xuXHRcdGlmIChsYXllci5fc2tldykge1xuXHRcdFx0Ly8gc3VwZXIgaW1wb3J0YW50ISB3b3JrYXJvdW5kIGZvciBhICdqdW1waW5nJyBnbGl0Y2g6XG5cdFx0XHQvLyBkaXNhYmxlIHRyYW5zZm9ybSBiZWZvcmUgcmVtb3ZpbmcgaXRcblx0XHRcdGxheWVyLl9za2V3Lm9uID0gZmFsc2U7XG5cdFx0XHRsYXllci5fcGF0aC5yZW1vdmVDaGlsZChsYXllci5fc2tldyk7XG5cdFx0XHRsYXllci5fc2tldyA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIG1hdHJpeCB0cmFuc2Zvcm1hdGlvbiB0byBWTUxcblx0ICogQHBhcmFtIHtMLlBhdGh9ICAgICAgICAgbGF5ZXJcblx0ICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gbWF0cml4XG5cdCAqL1xuXHR0cmFuc2Zvcm1QYXRoOiBmdW5jdGlvbihsYXllciwgbWF0cml4KSB7XG5cdFx0dmFyIHNrZXcgPSBsYXllci5fc2tldztcblxuXHRcdGlmICghc2tldykge1xuXHRcdFx0c2tldyA9IEwuU1ZHLmNyZWF0ZSgnc2tldycpO1xuXHRcdFx0bGF5ZXIuX3BhdGguYXBwZW5kQ2hpbGQoc2tldyk7XG5cdFx0XHRza2V3LnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcblx0XHRcdGxheWVyLl9za2V3ID0gc2tldztcblx0XHR9XG5cblx0XHQvLyBoYW5kbGUgc2tldy90cmFuc2xhdGUgc2VwYXJhdGVseSwgY2F1c2UgaXQncyBicm9rZW5cblx0XHR2YXIgbXQgPSBtYXRyaXhbMF0udG9GaXhlZCg4KSArICcgJyArIG1hdHJpeFsxXS50b0ZpeGVkKDgpICsgJyAnICtcblx0XHRcdG1hdHJpeFsyXS50b0ZpeGVkKDgpICsgJyAnICsgbWF0cml4WzNdLnRvRml4ZWQoOCkgKyAnIDAgMCc7XG5cdFx0dmFyIG9mZnNldCA9IE1hdGguZmxvb3IobWF0cml4WzRdKS50b0ZpeGVkKCkgKyAnLCAnICtcblx0XHRcdE1hdGguZmxvb3IobWF0cml4WzVdKS50b0ZpeGVkKCkgKyAnJztcblxuXHRcdHZhciBzID0gdGhpcy5fcGF0aC5zdHlsZTtcblx0XHR2YXIgbCA9IHBhcnNlRmxvYXQocy5sZWZ0KTtcblx0XHR2YXIgdCA9IHBhcnNlRmxvYXQocy50b3ApO1xuXHRcdHZhciB3ID0gcGFyc2VGbG9hdChzLndpZHRoKTtcblx0XHR2YXIgaCA9IHBhcnNlRmxvYXQocy5oZWlnaHQpO1xuXG5cdFx0aWYgKGlzTmFOKGwpKSAgICAgICBsID0gMDtcblx0XHRpZiAoaXNOYU4odCkpICAgICAgIHQgPSAwO1xuXHRcdGlmIChpc05hTih3KSB8fCAhdykgdyA9IDE7XG5cdFx0aWYgKGlzTmFOKGgpIHx8ICFoKSBoID0gMTtcblxuXHRcdHZhciBvcmlnaW4gPSAoLWwgLyB3IC0gMC41KS50b0ZpeGVkKDgpICsgJyAnICsgKC10IC8gaCAtIDAuNSkudG9GaXhlZCg4KTtcblxuXHRcdHNrZXcub24gPSAnZic7XG5cdFx0c2tldy5tYXRyaXggPSBtdDtcblx0XHRza2V3Lm9yaWdpbiA9IG9yaWdpbjtcblx0XHRza2V3Lm9mZnNldCA9IG9mZnNldDtcblx0XHRza2V3Lm9uID0gdHJ1ZTtcblx0fVxuXG59KTtcbmZ1bmN0aW9uIFRSVUVfRk4gKCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5MLkNhbnZhcy5pbmNsdWRlKHtcblxuICAvKipcbiAgICogRG8gbm90aGluZ1xuICAgKiBAcGFyYW0gIHtMLlBhdGh9IGxheWVyXG4gICAqL1xuICBfcmVzZXRUcmFuc2Zvcm1QYXRoOiBmdW5jdGlvbihsYXllcikge1xuICAgIGlmICghdGhpcy5fY29udGFpbmVyQ29weSkgcmV0dXJuO1xuXG4gICAgZGVsZXRlIHRoaXMuX2NvbnRhaW5lckNvcHk7XG5cbiAgICBpZiAobGF5ZXIuX2NvbnRhaW5zUG9pbnRfKSB7XG4gICAgICBsYXllci5fY29udGFpbnNQb2ludCA9IGxheWVyLl9jb250YWluc1BvaW50XztcbiAgICAgIGRlbGV0ZSBsYXllci5fY29udGFpbnNQb2ludF87XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBBbGdvcml0aG0gb3V0bGluZTpcbiAgICpcbiAgICogMS4gcHJlLXRyYW5zZm9ybSAtIGNsZWFyIHRoZSBwYXRoIG91dCBvZiB0aGUgY2FudmFzLCBjb3B5IGNhbnZhcyBzdGF0ZVxuICAgKiAyLiBhdCBldmVyeSBmcmFtZTpcbiAgICogICAgMi4xLiBzYXZlXG4gICAqICAgIDIuMi4gcmVkcmF3IHRoZSBjYW52YXMgZnJvbSBzYXZlZCBvbmVcbiAgICogICAgMi4zLiB0cmFuc2Zvcm1cbiAgICogICAgMi40LiBkcmF3IHBhdGhcbiAgICogICAgMi41LiByZXN0b3JlXG4gICAqIDMuIFJlcGVhdFxuICAgKlxuICAgKiBAcGFyYW0gIHtMLlBhdGh9ICAgICAgICAgbGF5ZXJcbiAgICogQHBhcmFtICB7QXJyYXkuPE51bWJlcj59IG1hdHJpeFxuICAgKi9cbiAgdHJhbnNmb3JtUGF0aDogZnVuY3Rpb24obGF5ZXIsIG1hdHJpeCkge1xuICAgIHZhciBjb3B5ICAgPSB0aGlzLl9jb250YWluZXJDb3B5O1xuICAgIHZhciBjdHggICAgPSB0aGlzLl9jdHgsIGNvcHlDdHg7XG4gICAgdmFyIG0gICAgICA9IEwuQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcbiAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xuICAgIHZhciBzaXplICAgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuICAgIHZhciBwb3MgICAgPSBib3VuZHMubWluO1xuXG4gICAgaWYgKCFjb3B5KSB7IC8vIGdldCBjb3B5IG9mIGFsbCByZW5kZXJlZCBsYXllcnNcbiAgICAgIGNvcHkgPSB0aGlzLl9jb250YWluZXJDb3B5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjb3B5Q3R4ID0gY29weS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgLy8gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3B5KTtcblxuICAgICAgY29weS53aWR0aCAgPSBtICogc2l6ZS54O1xuICAgICAgY29weS5oZWlnaHQgPSBtICogc2l6ZS55O1xuXG4gICAgICB0aGlzLl9yZW1vdmVQYXRoKGxheWVyKTtcbiAgICAgIHRoaXMuX3JlZHJhdygpO1xuXG4gICAgICBjb3B5Q3R4LnRyYW5zbGF0ZShtICogYm91bmRzLm1pbi54LCBtICogYm91bmRzLm1pbi55KTtcbiAgICAgIGNvcHlDdHguZHJhd0ltYWdlKHRoaXMuX2NvbnRhaW5lciwgMCwgMCk7XG4gICAgICB0aGlzLl9pbml0UGF0aChsYXllcik7XG5cbiAgICAgIC8vIGF2b2lkIGZsaWNrZXJpbmcgYmVjYXVzZSBvZiB0aGUgJ21vdXNlb3ZlcidzXG4gICAgICBsYXllci5fY29udGFpbnNQb2ludF8gPSBsYXllci5fY29udGFpbnNQb2ludDtcbiAgICAgIGxheWVyLl9jb250YWluc1BvaW50ICA9IFRSVUVfRk47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguY2xlYXJSZWN0KHBvcy54LCBwb3MueSwgc2l6ZS54ICogbSwgc2l6ZS55ICogbSk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2NvbnRhaW5lckNvcHksIDAsIDAsIHNpemUueCwgc2l6ZS55KTtcbiAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgbWF0cml4KTtcblxuICAgIC8vIG5vdyBkcmF3IG9uZSBsYXllciBvbmx5XG4gICAgdGhpcy5fZHJhd2luZyA9IHRydWU7XG4gICAgbGF5ZXIuX3VwZGF0ZVBhdGgoKTtcbiAgICB0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbn0pO1xuLyoqXG4gKiBEcmFnL3JvdGF0ZS9yZXNpemUgaGFuZGxlciBmb3IgW2xlYWZsZXRdKGh0dHA6Ly9sZWFmbGV0anMuY29tKSB2ZWN0b3IgZmVhdHVyZXMuXG4gKlxuICogQGF1dGhvciBBbGV4YW5kZXIgTWlsZXZza2kgPGluZm9AdzhyLm5hbWU+XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBwcmVzZXJ2ZVxuICovXG4vKipcbiAqIEBuYW1lc3BhY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkwuUGF0aFRyYW5zZm9ybSA9IHt9O1xuXG4vKipcbiAqIFBvaW50IG9uIHRoZSBsaW5lIHNlZ21lbnQgb3IgaXRzIGV4dGVudGlvblxuICpcbiAqIEBwYXJhbSAge0wuUG9pbnR9IHN0YXJ0XG4gKiBAcGFyYW0gIHtMLlBvaW50fSBmaW5hbFxuICogQHBhcmFtICB7TnVtYmVyfSAgZGlzdFB4XG4gKiBAcmV0dXJuIHtMLlBvaW50fVxuICovXG5MLlBhdGhUcmFuc2Zvcm0ucG9pbnRPbkxpbmUgPSBmdW5jdGlvbihzdGFydCwgZmluYWwsIGRpc3RQeCkge1xuICB2YXIgcmF0aW8gPSAxICsgZGlzdFB4IC8gc3RhcnQuZGlzdGFuY2VUbyhmaW5hbCk7XG4gIHJldHVybiBuZXcgTC5Qb2ludChcbiAgICBzdGFydC54ICsgKGZpbmFsLnggLSBzdGFydC54KSAqIHJhdGlvLFxuICAgIHN0YXJ0LnkgKyAoZmluYWwueSAtIHN0YXJ0LnkpICogcmF0aW9cbiAgKTtcbn07XG5cblxuLyoqXG4gKiBEZWVwIG1lcmdlIG9iamVjdHMuXG4gKi9cbkwuUGF0aFRyYW5zZm9ybS5tZXJnZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaSA9IDE7XG4gIHZhciBrZXksIHZhbDtcbiAgdmFyIG9iaiA9IGFyZ3VtZW50c1tpXTtcblxuICBmdW5jdGlvbiBpc09iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IG1vZGlmeSBzb3VyY2UgZWxlbWVudCBhbmQgaXQncyBwcm9wZXJ0aWVzXG4gIC8vIG9iamVjdHMgYXJlIHBhc3NlZCBieSByZWZlcmVuY2VcbiAgdmFyIHRhcmdldCA9IGFyZ3VtZW50c1swXTtcblxuICB3aGlsZSAob2JqKSB7XG4gICAgb2JqID0gYXJndW1lbnRzW2krK107XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YWwgPSBvYmpba2V5XTtcblxuICAgICAgaWYgKGlzT2JqZWN0KHZhbCkgJiYgaXNPYmplY3QodGFyZ2V0W2tleV0pKXtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBMLlV0aWwubWVyZ2UodGFyZ2V0W2tleV0sIHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG4vKipcbiAqIEBjbGFzcyAgTC5NYXRyaXhcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYVxuICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjXG4gKiBAcGFyYW0ge051bWJlcn0gZFxuICogQHBhcmFtIHtOdW1iZXJ9IGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBmXG4gKi9cbkwuTWF0cml4ID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPE51bWJlcj59XG4gICAqL1xuICB0aGlzLl9tYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG59O1xuXG5cbkwuTWF0cml4LnByb3RvdHlwZSA9IHtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtMLlBvaW50fSBwb2ludFxuICAgKiBAcmV0dXJuIHtMLlBvaW50fVxuICAgKi9cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0ocG9pbnQuY2xvbmUoKSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogRGVzdHJ1Y3RpdmVcbiAgICpcbiAgICogWyB4IF0gPSBbIGEgIGIgIHR4IF0gWyB4IF0gPSBbIGEgKiB4ICsgYiAqIHkgKyB0eCBdXG4gICAqIFsgeSBdID0gWyBjICBkICB0eSBdIFsgeSBdID0gWyBjICogeCArIGQgKiB5ICsgdHkgXVxuICAgKlxuICAgKiBAcGFyYW0gIHtMLlBvaW50fSBwb2ludFxuICAgKiBAcmV0dXJuIHtMLlBvaW50fVxuICAgKi9cbiAgX3RyYW5zZm9ybTogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuICAgIHZhciB4ID0gcG9pbnQueCwgeSA9IHBvaW50Lnk7XG4gICAgcG9pbnQueCA9IG1hdHJpeFswXSAqIHggKyBtYXRyaXhbMV0gKiB5ICsgbWF0cml4WzRdO1xuICAgIHBvaW50LnkgPSBtYXRyaXhbMl0gKiB4ICsgbWF0cml4WzNdICogeSArIG1hdHJpeFs1XTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtICB7TC5Qb2ludH0gcG9pbnRcbiAgICogQHJldHVybiB7TC5Qb2ludH1cbiAgICovXG4gIHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuICAgIHJldHVybiBuZXcgTC5Qb2ludChcbiAgICAgIChwb2ludC54IC8gbWF0cml4WzBdIC0gbWF0cml4WzRdKSAvIG1hdHJpeFswXSxcbiAgICAgIChwb2ludC55IC8gbWF0cml4WzJdIC0gbWF0cml4WzVdKSAvIG1hdHJpeFsyXVxuICAgICk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHJldHVybiB7TC5NYXRyaXh9XG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcbiAgICByZXR1cm4gbmV3IEwuTWF0cml4KFxuICAgICAgbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFsyXSxcbiAgICAgIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV1cbiAgICApO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TC5Qb2ludD18TnVtYmVyPX0gdHJhbnNsYXRlXG4gICAqIEByZXR1cm4ge0wuTWF0cml4fEwuUG9pbnR9XG4gICAqL1xuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHRyYW5zbGF0ZSkge1xuICAgIGlmICh0cmFuc2xhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBMLlBvaW50KHRoaXMuX21hdHJpeFs0XSwgdGhpcy5fbWF0cml4WzVdKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWTtcbiAgICBpZiAodHlwZW9mIHRyYW5zbGF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRyYW5zbGF0ZVggPSB0cmFuc2xhdGVZID0gdHJhbnNsYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2xhdGVYID0gdHJhbnNsYXRlLng7XG4gICAgICB0cmFuc2xhdGVZID0gdHJhbnNsYXRlLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2FkZCgxLCAwLCAwLCAxLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0wuUG9pbnQ9fE51bWJlcj19IHNjYWxlXG4gICAqIEByZXR1cm4ge0wuTWF0cml4fEwuUG9pbnR9XG4gICAqL1xuICBzY2FsZTogZnVuY3Rpb24oc2NhbGUsIG9yaWdpbikge1xuICAgIGlmIChzY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IEwuUG9pbnQodGhpcy5fbWF0cml4WzBdLCB0aGlzLl9tYXRyaXhbM10pO1xuICAgIH1cblxuICAgIHZhciBzY2FsZVgsIHNjYWxlWTtcbiAgICBvcmlnaW4gPSBvcmlnaW4gfHwgTC5wb2ludCgwLCAwKTtcbiAgICBpZiAodHlwZW9mIHNjYWxlID09PSAnbnVtYmVyJykge1xuICAgICAgc2NhbGVYID0gc2NhbGVZID0gc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlWCA9IHNjYWxlLng7XG4gICAgICBzY2FsZVkgPSBzY2FsZS55O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gICAgICAuX2FkZChzY2FsZVgsIDAsIDAsIHNjYWxlWSwgb3JpZ2luLngsIG9yaWdpbi55KVxuICAgICAgLl9hZGQoMSwgMCwgMCwgMSwgLW9yaWdpbi54LCAtb3JpZ2luLnkpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIG0wMCAgbTAxICB4IC0gbTAwICogeCAtIG0wMSAqIHlcbiAgICogbTEwICBtMTEgIHkgLSBtMTAgKiB4IC0gbTExICogeVxuICAgKiBAcGFyYW0ge051bWJlcn0gICBhbmdsZVxuICAgKiBAcGFyYW0ge0wuUG9pbnQ9fSBvcmlnaW5cbiAgICogQHJldHVybiB7TC5NYXRyaXh9XG4gICAqL1xuICByb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlLCBvcmlnaW4pIHtcbiAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICBvcmlnaW4gPSBvcmlnaW4gfHwgbmV3IEwuUG9pbnQoMCwgMCk7XG5cbiAgICByZXR1cm4gdGhpc1xuICAgICAgLl9hZGQoY29zLCBzaW4sIC1zaW4sIGNvcywgb3JpZ2luLngsIG9yaWdpbi55KVxuICAgICAgLl9hZGQoMSwgMCwgMCwgMSwgLW9yaWdpbi54LCAtb3JpZ2luLnkpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEludmVydCByb3RhdGlvblxuICAgKiBAcmV0dXJuIHtMLk1hdHJpeH1cbiAgICovXG4gIGZsaXA6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX21hdHJpeFsxXSAqPSAtMTtcbiAgICB0aGlzLl9tYXRyaXhbMl0gKj0gLTE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ8TC5NYXRyaXh9IGFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZcbiAgICovXG4gIF9hZGQ6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB2YXIgcmVzdWx0ID0gW1tdLCBbXSwgW11dO1xuICAgIHZhciBzcmMgPSB0aGlzLl9tYXRyaXg7XG4gICAgdmFyIG0gPSBbXG4gICAgICBbc3JjWzBdLCBzcmNbMl0sIHNyY1s0XV0sXG4gICAgICBbc3JjWzFdLCBzcmNbM10sIHNyY1s1XV0sXG4gICAgICBbICAgICAwLCAgICAgIDAsICAgICAxXVxuICAgIF07XG4gICAgdmFyIG90aGVyID0gW1xuICAgICAgW2EsIGMsIGVdLFxuICAgICAgW2IsIGQsIGZdLFxuICAgICAgWzAsIDAsIDFdXG4gICAgXSwgdmFsO1xuXG5cbiAgICBpZiAoYSAmJiBhIGluc3RhbmNlb2YgTC5NYXRyaXgpIHtcbiAgICAgIHNyYyA9IGEuX21hdHJpeDtcbiAgICAgIG90aGVyID0gW1xuICAgICAgICBbc3JjWzBdLCBzcmNbMl0sIHNyY1s0XV0sXG4gICAgICAgIFtzcmNbMV0sIHNyY1szXSwgc3JjWzVdXSxcbiAgICAgICAgWyAgICAgMCwgICAgICAwLCAgICAgMV1dO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IDM7IGsrKykge1xuICAgICAgICAgIHZhbCArPSBtW2ldW2tdICogb3RoZXJba11bal07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2ldW2pdID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hdHJpeCA9IFtcbiAgICAgIHJlc3VsdFswXVswXSwgcmVzdWx0WzFdWzBdLCByZXN1bHRbMF1bMV0sXG4gICAgICByZXN1bHRbMV1bMV0sIHJlc3VsdFswXVsyXSwgcmVzdWx0WzFdWzJdXG4gICAgXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cbn07XG5cblxuTC5tYXRyaXggPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHJldHVybiBuZXcgTC5NYXRyaXgoYSwgYiwgYywgZCwgZSwgZik7XG59O1xuXG5cbi8qKlxuICogTWFya2VyIGhhbmRsZXJcbiAqIEBleHRlbmRzIHtMLkNpcmNsZU1hcmtlcn1cbiAqL1xuTC5QYXRoVHJhbnNmb3JtLkhhbmRsZSA9IEwuQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG4gIG9wdGlvbnM6IHtcbiAgICBjbGFzc05hbWU6ICdsZWFmbGV0LXBhdGgtdHJhbnNmb3JtLWhhbmRsZXInXG4gIH0sXG5cbiAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICBMLkNpcmNsZU1hcmtlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgIGlmICh0aGlzLl9wYXRoICYmIHRoaXMub3B0aW9ucy5zZXRDdXJzb3IpIHsgLy8gU1ZHL1ZNTFxuICAgICAgdGhpcy5fcGF0aC5zdHlsZS5jdXJzb3IgPSBMLlBhdGhUcmFuc2Zvcm0uSGFuZGxlLkN1cnNvcnNCeVR5cGVbXG4gICAgICAgIHRoaXMub3B0aW9ucy5pbmRleFxuICAgICAgXTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbkwuUGF0aFRyYW5zZm9ybS5IYW5kbGUuQ3Vyc29yc0J5VHlwZSA9IFtcbiAgJ25lc3ctcmVzaXplJywgJ253c2UtcmVzaXplJywgJ25lc3ctcmVzaXplJywgJ253c2UtcmVzaXplJ1xuXTtcblxuXG4vKipcbiAqIEBleHRlbmRzIHtMLkhhbmRsZXIuUGF0aFRyYW5zZm9ybS5IYW5kbGV9XG4gKi9cbkwuUGF0aFRyYW5zZm9ybS5Sb3RhdGVIYW5kbGUgPSBMLlBhdGhUcmFuc2Zvcm0uSGFuZGxlLmV4dGVuZCh7XG4gIG9wdGlvbnM6IHtcbiAgICBjbGFzc05hbWU6ICdsZWFmbGV0LXBhdGgtdHJhbnNmb3JtLWhhbmRsZXIgdHJhbnNmb3JtLWhhbmRsZXItLXJvdGF0ZSdcbiAgfSxcblxuICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgIEwuQ2lyY2xlTWFya2VyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgaWYgKHRoaXMuX3BhdGggJiYgdGhpcy5vcHRpb25zLnNldEN1cnNvcikgeyAvLyBTVkcvVk1MXG4gICAgICB0aGlzLl9wYXRoLnN0eWxlLmN1cnNvciA9ICdhbGwtc2Nyb2xsJztcbiAgICB9XG4gIH1cbn0pO1xuXG5MLkhhbmRsZXIuUGF0aFRyYW5zZm9ybSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXG4gIG9wdGlvbnM6IHtcbiAgICByb3RhdGlvbjogdHJ1ZSxcbiAgICBzY2FsaW5nOiAgdHJ1ZSxcbiAgICB1bmlmb3JtU2NhbGluZzogdHJ1ZSxcbiAgICBtYXhab29tOiAgMjIsXG5cbiAgICAvLyBlZGdlIGhhbmRsZXJzXG4gICAgaGFuZGxlck9wdGlvbnM6IHtcbiAgICAgIHJhZGl1czogICAgICA1LFxuICAgICAgZmlsbENvbG9yOiAgICcjZmZmZmZmJyxcbiAgICAgIGNvbG9yOiAgICAgICAnIzIwMjAyMCcsXG4gICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgIHdlaWdodDogICAgICAyLFxuICAgICAgb3BhY2l0eTogICAgIDAuNyxcbiAgICAgIHNldEN1cnNvcjogICB0cnVlXG4gICAgfSxcblxuICAgIC8vIHJlY3RhbmdsZVxuICAgIGJvdW5kc09wdGlvbnM6IHtcbiAgICAgIHdlaWdodDogICAgMSxcbiAgICAgIG9wYWNpdHk6ICAgMSxcbiAgICAgIGRhc2hBcnJheTogWzMsIDNdLFxuICAgICAgZmlsbDogICAgICBmYWxzZVxuICAgIH0sXG5cbiAgICAvLyByb3RhdGlvbiBoYW5kbGVyXG4gICAgcm90YXRlSGFuZGxlT3B0aW9uczoge1xuICAgICAgd2VpZ2h0OiAgICAxLFxuICAgICAgb3BhY2l0eTogICAxLFxuICAgICAgc2V0Q3Vyc29yOiB0cnVlXG4gICAgfSxcbiAgICAvLyByb3RhdGlvbiBoYW5kbGUgbGVuZ3RoXG4gICAgaGFuZGxlTGVuZ3RoOiAyMCxcblxuICAgIC8vIG1heWJlIEknbGwgYWRkIHNrZXdpbmcgaW4gdGhlIGZ1dHVyZVxuICAgIGVkZ2VzQ291bnQ6ICAgNCxcblxuICAgIGhhbmRsZUNsYXNzOiAgICAgICBMLlBhdGhUcmFuc2Zvcm0uSGFuZGxlLFxuICAgIHJvdGF0ZUhhbmRsZUNsYXNzOiBMLlBhdGhUcmFuc2Zvcm0uUm90YXRlSGFuZGxlXG4gIH0sXG5cblxuICAvKipcbiAgICogQGNsYXNzIEwuSGFuZGxlci5QYXRoVHJhbnNmb3JtXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtMLlBhdGh9IHBhdGhcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAvLyByZWZlcmVuY2VzXG4gICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgdGhpcy5fbWFwICA9IG51bGw7XG5cbiAgICAvLyBoYW5kbGVyc1xuICAgIHRoaXMuX2FjdGl2ZU1hcmtlciAgID0gbnVsbDtcbiAgICB0aGlzLl9vcmlnaW5NYXJrZXIgICA9IG51bGw7XG4gICAgdGhpcy5fcm90YXRpb25NYXJrZXIgPSBudWxsO1xuXG4gICAgLy8gb3JpZ2lucyAmIHRlbXBvcmFyeSBzdGF0ZVxuICAgIHRoaXMuX3JvdGF0aW9uT3JpZ2luICAgPSBudWxsO1xuICAgIHRoaXMuX3NjYWxlT3JpZ2luICAgICAgPSBudWxsO1xuICAgIHRoaXMuX2FuZ2xlICAgICAgICAgICAgPSAwO1xuICAgIHRoaXMuX3NjYWxlICAgICAgICAgICAgPSBMLnBvaW50KDEsIDEpO1xuICAgIHRoaXMuX2luaXRpYWxEaXN0ICAgICAgPSAwO1xuICAgIHRoaXMuX2luaXRpYWxEaXN0WCAgICAgPSAwO1xuICAgIHRoaXMuX2luaXRpYWxEaXN0WSAgICAgPSAwO1xuICAgIHRoaXMuX3JvdGF0aW9uU3RhcnQgICAgPSBudWxsO1xuICAgIHRoaXMuX3JvdGF0aW9uT3JpZ2luUHQgPSBudWxsO1xuXG4gICAgLy8gcHJldmlldyBhbmQgdHJhbnNmb3JtIG1hdHJpeFxuICAgIHRoaXMuX21hdHJpeCAgICAgICAgICA9IG5ldyBMLk1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLl9wcm9qZWN0ZWRNYXRyaXggPSBuZXcgTC5NYXRyaXgoMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAvLyB1aSBlbGVtZW50c1xuICAgIHRoaXMuX2hhbmRsZXJzR3JvdXAgID0gbnVsbDtcbiAgICB0aGlzLl9yZWN0ICAgICAgICAgICA9IG51bGw7XG4gICAgdGhpcy5faGFuZGxlcnMgICAgICAgPSBbXTtcbiAgICB0aGlzLl9oYW5kbGVMaW5lICAgICA9IG51bGw7XG4gIH0sXG5cblxuICAvKipcbiAgICogSWYgdGhlIHBvbHlnb24gaXMgbm90IHJlbmRlcmVkLCB5b3UgY2FuIHRyYW5zZm9ybSBpdCB5b3Vyc2VsZlxuICAgKiBpbiB0aGUgY29vcmRpbmF0ZXMsIGFuZCBkbyBpdCBwcm9wZXJseS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gICAqL1xuICBlbmFibGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fcGF0aC5fbWFwKSB7XG4gICAgICB0aGlzLl9tYXAgPSB0aGlzLl9wYXRoLl9tYXA7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBMLkhhbmRsZXIucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBJbml0IGludGVyYWN0aW9ucyBhbmQgaGFuZGxlcnNcbiAgICovXG4gIGFkZEhvb2tzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jcmVhdGVIYW5kbGVycygpO1xuICAgIHRoaXMuX3BhdGhcbiAgICAgIC5vbignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQsIHRoaXMpXG4gICAgICAub24oJ2RyYWdlbmQnLCAgIHRoaXMuX29uRHJhZ0VuZCwgICB0aGlzKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgaGFuZGxlcnNcbiAgICovXG4gIHJlbW92ZUhvb2tzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9oaWRlSGFuZGxlcnMoKTtcbiAgICB0aGlzLl9wYXRoXG4gICAgICAub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCwgdGhpcylcbiAgICAgIC5vZmYoJ2RyYWdlbmQnLCAgIHRoaXMuX29uRHJhZ0VuZCwgICB0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVyc0dyb3VwID0gbnVsbDtcbiAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIENoYW5nZSBlZGl0aW5nIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZW5hYmxlZCA9IHRoaXMuX2VuYWJsZWQ7XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IEwuUGF0aFRyYW5zZm9ybS5tZXJnZSh7fSxcbiAgICAgIEwuSGFuZGxlci5QYXRoVHJhbnNmb3JtLnByb3RvdHlwZS5vcHRpb25zLFxuICAgICAgb3B0aW9ucyk7XG5cbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgYW5nbGVcbiAgICogQHBhcmFtICB7TC5MYXRMbmd9IG9yaWdpblxuICAgKiBAcmV0dXJuIHtMLkhhbmRsZXIuUGF0aFRyYW5zZm9ybX1cbiAgICovXG4gIHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIG9yaWdpbikge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShhbmdsZSwgbnVsbCwgb3JpZ2luKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtMLlBvaW50fE51bWJlcn0gc2NhbGVcbiAgICogQHBhcmFtICB7TC5MYXRMbmd9ICAgICAgIG9yaWdpblxuICAgKiBAcmV0dXJuIHtMLkhhbmRsZXIuUGF0aFRyYW5zZm9ybX1cbiAgICovXG4gIHNjYWxlOiBmdW5jdGlvbihzY2FsZSwgb3JpZ2luKSB7XG4gICAgaWYgKHR5cGVvZiBzY2FsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHNjYWxlID0gTC5wb2ludChzY2FsZSwgc2NhbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oMCwgc2NhbGUsIG51bGwsIG9yaWdpbik7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICBhbmdsZVxuICAgKiBAcGFyYW0gIHtMLlBvaW50fSAgIHNjYWxlXG4gICAqIEBwYXJhbSAge0wuTGF0TG5nPX0gcm90YXRpb25PcmlnaW5cbiAgICogQHBhcmFtICB7TC5MYXRMbmc9fSBzY2FsZU9yaWdpblxuICAgKiBAcmV0dXJuIHtMLkhhbmRsZXIuUGF0aFRyYW5zZm9ybX1cbiAgICovXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24oYW5nbGUsIHNjYWxlLCByb3RhdGlvbk9yaWdpbiwgc2NhbGVPcmlnaW4pIHtcbiAgICB2YXIgY2VudGVyICAgICA9IHRoaXMuX3BhdGguZ2V0Q2VudGVyKCk7XG4gICAgcm90YXRpb25PcmlnaW4gPSByb3RhdGlvbk9yaWdpbiB8fCBjZW50ZXI7XG4gICAgc2NhbGVPcmlnaW4gICAgPSBzY2FsZU9yaWdpbiAgICB8fCBjZW50ZXI7XG4gICAgdGhpcy5fbWFwID0gdGhpcy5fcGF0aC5fbWFwO1xuICAgIHRoaXMuX3RyYW5zZm9ybVBvaW50cyh0aGlzLl9wYXRoLCBhbmdsZSwgc2NhbGUsIHJvdGF0aW9uT3JpZ2luLCBzY2FsZU9yaWdpbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwb2x5Z29uIGFuZCBoYW5kbGVycyBwcmV2aWV3LCBubyByZXByb2plY3Rpb25cbiAgICovXG4gIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG5cbiAgICAvLyB1cGRhdGUgaGFuZGxlcnNcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcnNbaV07XG4gICAgICBpZiAoaGFuZGxlciAhPT0gdGhpcy5fb3JpZ2luTWFya2VyKSB7XG4gICAgICAgIGhhbmRsZXIuX3BvaW50ID0gbWF0cml4LnRyYW5zZm9ybShoYW5kbGVyLl9pbml0aWFsUG9pbnQpO1xuICAgICAgICBoYW5kbGVyLl91cGRhdGVQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWF0cml4ID0gbWF0cml4LmNsb25lKCkuZmxpcCgpO1xuXG4gICAgdGhpcy5fYXBwbHlUcmFuc2Zvcm0obWF0cml4KTtcbiAgICB0aGlzLl9wYXRoLmZpcmUoJ3RyYW5zZm9ybScsIHsgbGF5ZXI6IHRoaXMuX3BhdGggfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtICB7TC5NYXRyaXh9IG1hdHJpeFxuICAgKi9cbiAgX2FwcGx5VHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICB0aGlzLl9wYXRoLl90cmFuc2Zvcm0obWF0cml4Ll9tYXRyaXgpO1xuICAgIHRoaXMuX3JlY3QuX3RyYW5zZm9ybShtYXRyaXguX21hdHJpeCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0aW9uKSB7XG4gICAgICB0aGlzLl9oYW5kbGVMaW5lLl90cmFuc2Zvcm0obWF0cml4Ll9tYXRyaXgpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBBcHBseSBmaW5hbCB0cmFuc2Zvcm1hdGlvblxuICAgKi9cbiAgX2FwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAvL2NvbnNvbGUuZ3JvdXAoJ2FwcGx5IHRyYW5zZm9ybScpO1xuICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeC5jbG9uZSgpO1xuICAgIHZhciBhbmdsZSA9IHRoaXMuX2FuZ2xlO1xuICAgIHZhciBzY2FsZSA9IHRoaXMuX3NjYWxlLmNsb25lKCk7XG5cbiAgICB0aGlzLl90cmFuc2Zvcm1HZW9tZXRyaWVzKCk7XG5cbiAgICAvLyB1cGRhdGUgaGFuZGxlcnNcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcnNbaV07XG4gICAgICBoYW5kbGVyLl9sYXRsbmcgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKGhhbmRsZXIuX3BvaW50KTtcbiAgICAgIGRlbGV0ZSBoYW5kbGVyLl9pbml0aWFsUG9pbnQ7XG4gICAgICBoYW5kbGVyLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHRoaXMuX21hdHJpeCA9IEwubWF0cml4KDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHRoaXMuX3NjYWxlICA9IEwucG9pbnQoMSwgMSk7XG4gICAgdGhpcy5fYW5nbGUgID0gMDtcblxuICAgIHRoaXMuX3VwZGF0ZUhhbmRsZXJzKCk7XG5cbiAgICBtYXAuZHJhZ2dpbmcuZW5hYmxlKCk7XG4gICAgdGhpcy5fcGF0aC5maXJlKCd0cmFuc2Zvcm1lZCcsIHtcbiAgICAgIG1hdHJpeDogbWF0cml4LFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgcm90YXRpb246IGFuZ2xlLFxuICAgICAgLy8gYW5nbGU6IGFuZ2xlICogKDE4MCAvIE1hdGguUEkpLFxuICAgICAgbGF5ZXI6IHRoaXMuX3BhdGhcbiAgICB9KTtcbiAgICAvLyBjb25zb2xlLmdyb3VwRW5kKCdhcHBseSB0cmFuc2Zvcm0nKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY29tcGxldGVseSByZXNldCBoYW5kbGVycywgaWYgeW91IGhhdmUgY2hhbmdlZCB0aGVcbiAgICogZ2VvbWV0cnkgb2YgdHJhbnNmb3JtZWQgbGF5ZXJcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgICAgaWYgKHRoaXMuX3JlY3QpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlcnNHcm91cC5yZW1vdmVMYXllcih0aGlzLl9yZWN0KTtcbiAgICAgICAgdGhpcy5fcmVjdCA9IHRoaXMuX2dldEJvdW5kaW5nUG9seWdvbigpLmFkZFRvKHRoaXMuX2hhbmRsZXJzR3JvdXApO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlSGFuZGxlcnMoKTtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogUmVjYWxjdWxhdGUgcm90YXRpb24gaGFuZGxlcnMgcG9zaXRpb25cbiAgICovXG4gIF91cGRhdGVIYW5kbGVyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhhbmRsZXJzR3JvdXAgPSB0aGlzLl9oYW5kbGVyc0dyb3VwO1xuXG4gICAgdGhpcy5fcmVjdFNoYXBlID0gdGhpcy5fcmVjdC50b0dlb0pTT04oKTtcblxuICAgIGlmICh0aGlzLl9oYW5kbGVMaW5lKSB7XG4gICAgICB0aGlzLl9oYW5kbGVyc0dyb3VwLnJlbW92ZUxheWVyKHRoaXMuX2hhbmRsZUxpbmUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yb3RhdGlvbk1hcmtlcikge1xuICAgICAgdGhpcy5faGFuZGxlcnNHcm91cC5yZW1vdmVMYXllcih0aGlzLl9yb3RhdGlvbk1hcmtlcik7XG4gICAgfVxuXG4gICAgdGhpcy5faGFuZGxlTGluZSA9IHRoaXMuX3JvdGF0aW9uTWFya2VyID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSB0aGlzLl9oYW5kbGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaGFuZGxlcnNHcm91cC5yZW1vdmVMYXllcih0aGlzLl9oYW5kbGVyc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlSGFuZGxlcnMoKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gZ2VvbWV0cmllcyBzZXBhcmF0ZWx5XG4gICAqL1xuICBfdHJhbnNmb3JtR2VvbWV0cmllczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcGF0aC5fdHJhbnNmb3JtKG51bGwpO1xuICAgIHRoaXMuX3JlY3QuX3RyYW5zZm9ybShudWxsKTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybVBvaW50cyh0aGlzLl9wYXRoKTtcbiAgICB0aGlzLl90cmFuc2Zvcm1Qb2ludHModGhpcy5fcmVjdCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0aW9uKSB7XG4gICAgICB0aGlzLl9oYW5kbGVMaW5lLl90cmFuc2Zvcm0obnVsbCk7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Qb2ludHModGhpcy5faGFuZGxlTGluZSwgdGhpcy5fYW5nbGUsIG51bGwsIHRoaXMuX29yaWdpbik7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVcbiAgICogQHBhcmFtIHtMLkxhdExuZz19IHJvdGF0aW9uT3JpZ2luXG4gICAqIEBwYXJhbSB7TC5MYXRMbmc9fSBzY2FsZU9yaWdpblxuICAgKi9cbiAgX2dldFByb2plY3RlZE1hdHJpeDogZnVuY3Rpb24oYW5nbGUsIHNjYWxlLCByb3RhdGlvbk9yaWdpbiwgc2NhbGVPcmlnaW4pIHtcbiAgICB2YXIgbWFwICAgID0gdGhpcy5fbWFwO1xuICAgIHZhciB6b29tICAgPSBtYXAuZ2V0TWF4Wm9vbSgpIHx8IHRoaXMub3B0aW9ucy5tYXhab29tO1xuICAgIHZhciBtYXRyaXggPSBMLm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB2YXIgb3JpZ2luO1xuXG4gICAgYW5nbGUgPSBhbmdsZSB8fCB0aGlzLl9hbmdsZSB8fCAwO1xuICAgIHNjYWxlID0gc2NhbGUgfHwgdGhpcy5fc2NhbGUgfHwgTC5wb2ludCgxLCAxKTtcblxuICAgIGlmICghKHNjYWxlLnggPT09IDEgJiYgc2NhbGUueSA9PT0gMSkpIHtcbiAgICAgIHNjYWxlT3JpZ2luID0gc2NhbGVPcmlnaW4gfHwgdGhpcy5fc2NhbGVPcmlnaW47XG4gICAgICBvcmlnaW4gPSBtYXAucHJvamVjdChzY2FsZU9yaWdpbiwgem9vbSk7XG4gICAgICBtYXRyaXggPSBtYXRyaXhcbiAgICAgICAgLl9hZGQoTC5tYXRyaXgoMSwgMCwgMCwgMSwgb3JpZ2luLngsIG9yaWdpbi55KSlcbiAgICAgICAgLl9hZGQoTC5tYXRyaXgoc2NhbGUueCwgMCwgMCwgc2NhbGUueSwgMCwgMCkpXG4gICAgICAgIC5fYWRkKEwubWF0cml4KDEsIDAsIDAsIDEsIC1vcmlnaW4ueCwgLW9yaWdpbi55KSk7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlKSB7XG4gICAgICByb3RhdGlvbk9yaWdpbiA9IHJvdGF0aW9uT3JpZ2luIHx8IHRoaXMuX3JvdGF0aW9uT3JpZ2luO1xuICAgICAgb3JpZ2luID0gbWFwLnByb2plY3Qocm90YXRpb25PcmlnaW4sIHpvb20pO1xuICAgICAgbWF0cml4ID0gbWF0cml4LnJvdGF0ZShhbmdsZSwgb3JpZ2luKS5mbGlwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtMLkxhdExuZ30gbGF0bG5nXG4gICAqIEBwYXJhbSAge0wuTWF0cml4fSBtYXRyaXhcbiAgICogQHBhcmFtICB7TC5NYXB9ICAgIG1hcFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgem9vbVxuICAgKiBAcmV0dXJuIHtMLkxhdExuZ31cbiAgICovXG4gIF90cmFuc2Zvcm1Qb2ludDogZnVuY3Rpb24obGF0bG5nLCBtYXRyaXgsIG1hcCwgem9vbSkge1xuICAgIHJldHVybiBtYXAudW5wcm9qZWN0KG1hdHJpeC50cmFuc2Zvcm0oXG4gICAgICBtYXAucHJvamVjdChsYXRsbmcsIHpvb20pKSwgem9vbSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQXBwbGllcyB0cmFuc2Zvcm1hdGlvbiwgZG9lcyBpdCBpbiBvbmUgc3dlZXAgZm9yIHBlcmZvcm1hbmNlLFxuICAgKiBzbyBkb24ndCBiZSBzdXJwcmlzZWQgYWJvdXQgdGhlIGNvZGUgcmVwZXRpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtMLlBhdGh9ICAgIHBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXI9fSAgIGFuZ2xlXG4gICAqIEBwYXJhbSB7TC5Qb2ludD19ICBzY2FsZVxuICAgKiBAcGFyYW0ge0wuTGF0TG5nPX0gcm90YXRpb25PcmlnaW5cbiAgICogQHBhcmFtIHtMLkxhdExuZz19IHNjYWxlT3JpZ2luXG4gICAqL1xuICBfdHJhbnNmb3JtUG9pbnRzOiBmdW5jdGlvbihwYXRoLCBhbmdsZSwgc2NhbGUsIHJvdGF0aW9uT3JpZ2luLCBzY2FsZU9yaWdpbikge1xuICAgIHZhciBtYXAgPSBwYXRoLl9tYXA7XG4gICAgdmFyIHpvb20gPSBtYXAuZ2V0TWF4Wm9vbSgpIHx8IHRoaXMub3B0aW9ucy5tYXhab29tO1xuICAgIHZhciBpLCBsZW47XG5cbiAgICB2YXIgcHJvamVjdGVkTWF0cml4ID0gdGhpcy5fcHJvamVjdGVkTWF0cml4ID1cbiAgICAgIHRoaXMuX2dldFByb2plY3RlZE1hdHJpeChhbmdsZSwgc2NhbGUsIHJvdGF0aW9uT3JpZ2luLCBzY2FsZU9yaWdpbik7XG4gICAgLy8gY29uc29sZS50aW1lKCd0cmFuc2Zvcm0nKTtcblxuICAgIC8vIGFsbCBzaGlmdHMgYXJlIGluLXBsYWNlXG4gICAgaWYgKHBhdGguX3BvaW50KSB7IC8vIEwuQ2lyY2xlXG4gICAgICBwYXRoLl9sYXRsbmcgPSB0aGlzLl90cmFuc2Zvcm1Qb2ludChcbiAgICAgICAgcGF0aC5fbGF0bG5nLCBwcm9qZWN0ZWRNYXRyaXgsIG1hcCwgem9vbSk7XG4gICAgfSBlbHNlIGlmIChwYXRoLl9yaW5ncyB8fCBwYXRoLl9wYXJ0cykgeyAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICAgIHZhciByaW5ncyA9IHBhdGguX3JpbmdzO1xuICAgICAgdmFyIGxhdGxuZ3MgPSBwYXRoLl9sYXRsbmdzO1xuICAgICAgcGF0aC5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XG5cbiAgICAgIGlmICghTC5VdGlsLmlzQXJyYXkobGF0bG5nc1swXSkpIHsgLy8gcG9seWxpbmVcbiAgICAgICAgbGF0bG5ncyA9IFtsYXRsbmdzXTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHJpbmdzW2ldLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICBsYXRsbmdzW2ldW2pdID0gdGhpcy5fdHJhbnNmb3JtUG9pbnQoXG4gICAgICAgICAgICBsYXRsbmdzW2ldW2pdLCBwcm9qZWN0ZWRNYXRyaXgsIG1hcCwgem9vbSk7XG4gICAgICAgICAgcGF0aC5fYm91bmRzLmV4dGVuZChsYXRsbmdzW2ldW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHBhdGguX3Jlc2V0KCk7XG4gICAgLy9jb25zb2xlLnRpbWVFbmQoJ3RyYW5zZm9ybScpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya2VycyBhbmQgaGFuZGxlc1xuICAgKi9cbiAgX2NyZWF0ZUhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgIHRoaXMuX2hhbmRsZXJzR3JvdXAgPSB0aGlzLl9oYW5kbGVyc0dyb3VwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBMLkxheWVyR3JvdXAoKS5hZGRUbyhtYXApO1xuICAgIHRoaXMuX3JlY3QgPSB0aGlzLl9yZWN0IHx8XG4gICAgICAgICAgICAgICAgIHRoaXMuX2dldEJvdW5kaW5nUG9seWdvbigpLmFkZFRvKHRoaXMuX2hhbmRsZXJzR3JvdXApO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zY2FsaW5nKSB7XG4gICAgICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMuZWRnZXNDb3VudDsgaSsrKSB7XG4gICAgICAgIC8vIFRPRE86IGFkZCBzdHJldGNoaW5nXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzLnB1c2goXG4gICAgICAgICAgdGhpcy5fY3JlYXRlSGFuZGxlcih0aGlzLl9yZWN0Ll9sYXRsbmdzWzBdW2ldLCBpICogMiwgaSlcbiAgICAgICAgICAuYWRkVG8odGhpcy5faGFuZGxlcnNHcm91cCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBib3VuZHNcbiAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0aW9uKSB7XG4gICAgICAvL2FkZCByb3RhdGlvbiBoYW5kbGVyXG4gICAgICB0aGlzLl9jcmVhdGVSb3RhdGlvbkhhbmRsZXJzKCk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIFJvdGF0aW9uIG1hcmtlciBhbmQgc21hbGwgY29ubmVjdGluIGhhbmRsZVxuICAgKi9cbiAgX2NyZWF0ZVJvdGF0aW9uSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXAgICAgID0gdGhpcy5fbWFwO1xuICAgIHZhciBsYXRsbmdzID0gdGhpcy5fcmVjdC5fbGF0bG5nc1swXTtcblxuICAgIHZhciBib3R0b20gICA9IG5ldyBMLkxhdExuZyhcbiAgICAgIChsYXRsbmdzWzBdLmxhdCArIGxhdGxuZ3NbM10ubGF0KSAvIDIsXG4gICAgICAobGF0bG5nc1swXS5sbmcgKyBsYXRsbmdzWzNdLmxuZykgLyAyKTtcbiAgICAvLyBoZWhlLCB0b3AgaXMgYSByZXNlcnZlZCB3b3JkXG4gICAgdmFyIHRvcFBvaW50ID0gbmV3IEwuTGF0TG5nKFxuICAgICAgKGxhdGxuZ3NbMV0ubGF0ICsgbGF0bG5nc1syXS5sYXQpIC8gMixcbiAgICAgIChsYXRsbmdzWzFdLmxuZyArIGxhdGxuZ3NbMl0ubG5nKSAvIDIpO1xuXG4gICAgdmFyIGhhbmRsZXJQb3NpdGlvbiA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcoXG4gICAgICBMLlBhdGhUcmFuc2Zvcm0ucG9pbnRPbkxpbmUoXG4gICAgICAgIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQoYm90dG9tKSxcbiAgICAgICAgbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0b3BQb2ludCksXG4gICAgICAgIHRoaXMub3B0aW9ucy5oYW5kbGVMZW5ndGgpXG4gICAgKTtcblxuICAgIHRoaXMuX2hhbmRsZUxpbmUgPSBuZXcgTC5Qb2x5bGluZShbdG9wUG9pbnQsIGhhbmRsZXJQb3NpdGlvbl0sXG4gICAgICB0aGlzLm9wdGlvbnMucm90YXRlSGFuZGxlT3B0aW9ucykuYWRkVG8odGhpcy5faGFuZGxlcnNHcm91cCk7XG4gICAgdmFyIFJvdGF0ZUhhbmRsZUNsYXNzID0gdGhpcy5vcHRpb25zLnJvdGF0ZUhhbmRsZUNsYXNzO1xuICAgIHRoaXMuX3JvdGF0aW9uTWFya2VyID0gbmV3IFJvdGF0ZUhhbmRsZUNsYXNzKGhhbmRsZXJQb3NpdGlvbixcbiAgICAgIHRoaXMub3B0aW9ucy5oYW5kbGVyT3B0aW9ucylcbiAgICAgIC5hZGRUbyh0aGlzLl9oYW5kbGVyc0dyb3VwKVxuICAgICAgLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9vblJvdGF0ZVN0YXJ0LCB0aGlzKTtcblxuICAgIHRoaXMuX3JvdGF0aW9uT3JpZ2luID0gbmV3IEwuTGF0TG5nKFxuICAgICAgKHRvcFBvaW50LmxhdCArIGJvdHRvbS5sYXQpIC8gMixcbiAgICAgICh0b3BQb2ludC5sbmcgKyBib3R0b20ubG5nKSAvIDJcbiAgICApO1xuXG4gICAgdGhpcy5faGFuZGxlcnMucHVzaCh0aGlzLl9yb3RhdGlvbk1hcmtlcik7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHJldHVybiB7TC5MYXRMbmd9XG4gICAqL1xuICBfZ2V0Um90YXRpb25PcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXRsbmdzID0gdGhpcy5fcmVjdC5fbGF0bG5nc1swXTtcbiAgICB2YXIgbGIgPSBsYXRsbmdzWzBdO1xuICAgIHZhciBydCA9IGxhdGxuZ3NbMl07XG5cbiAgICByZXR1cm4gbmV3IEwuTGF0TG5nKFxuICAgICAgKGxiLmxhdCArIHJ0LmxhdCkgLyAyLFxuICAgICAgKGxiLmxuZyArIHJ0LmxuZykgLyAyXG4gICAgKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTZWN1cmUgdGhlIHJvdGF0aW9uIG9yaWdpblxuICAgKiBAcGFyYW0gIHtFdmVudH0gZXZ0XG4gICAqL1xuICBfb25Sb3RhdGVTdGFydDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgIG1hcC5kcmFnZ2luZy5kaXNhYmxlKCk7XG5cbiAgICB0aGlzLl9vcmlnaW5NYXJrZXIgICAgID0gbnVsbDtcbiAgICB0aGlzLl9yb3RhdGlvbk9yaWdpblB0ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9nZXRSb3RhdGlvbk9yaWdpbigpKTtcbiAgICB0aGlzLl9yb3RhdGlvblN0YXJ0ICAgID0gZXZ0LmxheWVyUG9pbnQ7XG4gICAgdGhpcy5faW5pdGlhbE1hdHJpeCAgICA9IHRoaXMuX21hdHJpeC5jbG9uZSgpO1xuXG4gICAgdGhpcy5fYW5nbGUgPSAwO1xuICAgIHRoaXMuX3BhdGguX21hcFxuICAgICAgLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vblJvdGF0ZSwgICAgIHRoaXMpXG4gICAgICAub24oJ21vdXNldXAnLCAgIHRoaXMuX29uUm90YXRlRW5kLCB0aGlzKTtcblxuICAgIHRoaXMuX2NhY2hlUG9pbnRzKCk7XG4gICAgdGhpcy5fcGF0aFxuICAgICAgLmZpcmUoJ3RyYW5zZm9ybXN0YXJ0JywgICB7IGxheWVyOiB0aGlzLl9wYXRoIH0pXG4gICAgICAuZmlyZSgncm90YXRlc3RhcnQnLCB7IGxheWVyOiB0aGlzLl9wYXRoLCByb3RhdGlvbjogMCB9KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtFdmVudH0gZXZ0XG4gICAqL1xuICBfb25Sb3RhdGU6IGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciBwb3MgPSBldnQubGF5ZXJQb2ludDtcbiAgICB2YXIgcHJldmlvdXMgPSB0aGlzLl9yb3RhdGlvblN0YXJ0O1xuICAgIHZhciBvcmlnaW4gICA9IHRoaXMuX3JvdGF0aW9uT3JpZ2luUHQ7XG5cbiAgICAvLyByb3RhdGlvbiBzdGVwIGFuZ2xlXG4gICAgdGhpcy5fYW5nbGUgPSBNYXRoLmF0YW4yKHBvcy55IC0gb3JpZ2luLnksIHBvcy54IC0gb3JpZ2luLngpIC1cbiAgICAgICAgICAgICAgICAgIE1hdGguYXRhbjIocHJldmlvdXMueSAtIG9yaWdpbi55LCBwcmV2aW91cy54IC0gb3JpZ2luLngpO1xuXG4gICAgdGhpcy5fbWF0cml4ID0gdGhpcy5faW5pdGlhbE1hdHJpeFxuICAgICAgLmNsb25lKClcbiAgICAgIC5yb3RhdGUodGhpcy5fYW5nbGUsIG9yaWdpbilcbiAgICAgIC5mbGlwKCk7XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB0aGlzLl9wYXRoLmZpcmUoJ3JvdGF0ZScsIHsgbGF5ZXI6IHRoaXMuX3BhdGgsIHJvdGF0aW9uOiB0aGlzLl9hbmdsZSB9KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtFdmVudH0gZXZ0XG4gICAqL1xuICBfb25Sb3RhdGVFbmQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgIHRoaXMuX3BhdGguX21hcFxuICAgICAgLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fb25Sb3RhdGUsIHRoaXMpXG4gICAgICAub2ZmKCdtb3VzZXVwJywgICB0aGlzLl9vblJvdGF0ZUVuZCwgdGhpcyk7XG5cbiAgICB0aGlzLl9hcHBseSgpO1xuICAgIHRoaXMuX3BhdGguZmlyZSgncm90YXRlZW5kJywgeyBsYXllcjogdGhpcy5fcGF0aCwgcm90YXRpb246IHRoaXMuX2FuZ2xlIH0pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0V2ZW50fSBldnRcbiAgICovXG4gIF9vblNjYWxlU3RhcnQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciBtYXJrZXIgPSBldnQudGFyZ2V0O1xuICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICBtYXAuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuXG4gICAgdGhpcy5fYWN0aXZlTWFya2VyID0gbWFya2VyO1xuXG4gICAgdGhpcy5fb3JpZ2luTWFya2VyID0gdGhpcy5faGFuZGxlcnNbKG1hcmtlci5vcHRpb25zLmluZGV4ICsgMikgJSA0XTtcbiAgICB0aGlzLl9zY2FsZU9yaWdpbiAgPSB0aGlzLl9vcmlnaW5NYXJrZXIuZ2V0TGF0TG5nKCk7XG5cbiAgICB0aGlzLl9pbml0aWFsTWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG4gICAgdGhpcy5fY2FjaGVQb2ludHMoKTtcblxuICAgIHRoaXMuX21hcFxuICAgICAgLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vblNjYWxlLCAgICB0aGlzKVxuICAgICAgLm9uKCdtb3VzZXVwJywgICB0aGlzLl9vblNjYWxlRW5kLCB0aGlzKTtcbiAgICB0aGlzLl9pbml0aWFsRGlzdCAgPSB0aGlzLl9vcmlnaW5NYXJrZXIuX3BvaW50LmRpc3RhbmNlVG8odGhpcy5fYWN0aXZlTWFya2VyLl9wb2ludCk7XG4gICAgdGhpcy5faW5pdGlhbERpc3RYID0gdGhpcy5fb3JpZ2luTWFya2VyLl9wb2ludC54IC0gdGhpcy5fYWN0aXZlTWFya2VyLl9wb2ludC54O1xuICAgIHRoaXMuX2luaXRpYWxEaXN0WSA9IHRoaXMuX29yaWdpbk1hcmtlci5fcG9pbnQueSAtIHRoaXMuX2FjdGl2ZU1hcmtlci5fcG9pbnQueTtcblxuICAgIHRoaXMuX3BhdGhcbiAgICAgIC5maXJlKCd0cmFuc2Zvcm1zdGFydCcsIHsgbGF5ZXI6IHRoaXMuX3BhdGggfSlcbiAgICAgIC5maXJlKCdzY2FsZXN0YXJ0JywgeyBsYXllcjogdGhpcy5fcGF0aCwgc2NhbGU6IEwucG9pbnQoMSwgMSkgfSk7XG5cbiAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5faGFuZGxlTGluZSk7XG4gICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX3JvdGF0aW9uTWFya2VyKTtcblxuICAgIC8vdGhpcy5faGFuZGxlTGluZSA9IHRoaXMuX3JvdGF0aW9uTWFya2VyID0gbnVsbDtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtFdmVudH0gZXZ0XG4gICAqL1xuICBfb25TY2FsZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIG9yaWdpblBvaW50ID0gdGhpcy5fb3JpZ2luTWFya2VyLl9wb2ludDtcbiAgICB2YXIgcmF0aW9YLCByYXRpb1k7XG4gICAgaWYgKHRoaXMub3B0aW9ucy51bmlmb3JtU2NhbGluZykge1xuICAgICAgcmF0aW9YID0gb3JpZ2luUG9pbnQuZGlzdGFuY2VUbyhldnQubGF5ZXJQb2ludCkgLyB0aGlzLl9pbml0aWFsRGlzdDtcbiAgICAgIHJhdGlvWSA9IHJhdGlvWDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF0aW9YID0gKG9yaWdpblBvaW50LnggLSBldnQubGF5ZXJQb2ludC54KSAvIHRoaXMuX2luaXRpYWxEaXN0WDtcbiAgICAgIHJhdGlvWSA9IChvcmlnaW5Qb2ludC55IC0gZXZ0LmxheWVyUG9pbnQueSkgLyB0aGlzLl9pbml0aWFsRGlzdFk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2NhbGUgPSBuZXcgTC5Qb2ludChyYXRpb1gsIHJhdGlvWSk7XG5cbiAgICAvLyB1cGRhdGUgbWF0cml4XG4gICAgdGhpcy5fbWF0cml4ID0gdGhpcy5faW5pdGlhbE1hdHJpeFxuICAgICAgLmNsb25lKClcbiAgICAgIC5zY2FsZSh0aGlzLl9zY2FsZSwgb3JpZ2luUG9pbnQpO1xuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgdGhpcy5fcGF0aC5maXJlKCdzY2FsZScsIHtcbiAgICAgIGxheWVyOiB0aGlzLl9wYXRoLCBzY2FsZTogdGhpcy5fc2NhbGUuY2xvbmUoKSB9KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTY2FsaW5nIGNvbXBsZXRlXG4gICAqIEBwYXJhbSAge0V2ZW50fSBldnRcbiAgICovXG4gIF9vblNjYWxlRW5kOiBmdW5jdGlvbihldnQpIHtcbiAgICB0aGlzLl9tYXBcbiAgICAgIC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uU2NhbGUsICAgIHRoaXMpXG4gICAgICAub2ZmKCdtb3VzZXVwJywgICB0aGlzLl9vblNjYWxlRW5kLCB0aGlzKTtcblxuICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl9oYW5kbGVMaW5lKTtcbiAgICB0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fcm90YXRpb25NYXJrZXIpO1xuXG4gICAgdGhpcy5fYXBwbHkoKTtcbiAgICB0aGlzLl9wYXRoLmZpcmUoJ3NjYWxlZW5kJywge1xuICAgICAgbGF5ZXI6IHRoaXMuX3BhdGgsIHNjYWxlOiB0aGlzLl9zY2FsZS5jbG9uZSgpIH0pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIENhY2hlIGN1cnJlbnQgaGFuZGxlcnMgcG9zaXRpb25zXG4gICAqL1xuICBfY2FjaGVQb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hhbmRsZXJzR3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICBsYXllci5icmluZ1RvRnJvbnQoKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcnNbaV07XG4gICAgICBoYW5kbGVyLl9pbml0aWFsUG9pbnQgPSBoYW5kbGVyLl9wb2ludC5jbG9uZSgpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBCb3VuZGluZyBwb2x5Z29uXG4gICAqIEByZXR1cm4ge0wuUG9seWdvbn1cbiAgICovXG4gIF9nZXRCb3VuZGluZ1BvbHlnb246IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9yZWN0U2hhcGUpIHtcbiAgICAgIHJldHVybiBMLkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyKFxuICAgICAgICB0aGlzLl9yZWN0U2hhcGUsIHRoaXMub3B0aW9ucy5ib3VuZHNPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBMLlJlY3RhbmdsZShcbiAgICAgICAgdGhpcy5fcGF0aC5nZXRCb3VuZHMoKSwgdGhpcy5vcHRpb25zLmJvdW5kc09wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBDcmVhdGUgY29ybmVyIG1hcmtlclxuICAgKiBAcGFyYW0gIHtMLkxhdExuZ30gbGF0bG5nXG4gICAqIEBwYXJhbSAge051bWJlcn0gICB0eXBlIG9uZSBvZiBMLkhhbmRsZXIuUGF0aFRyYW5zZm9ybS5IYW5kbGVyVHlwZXNcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIGluZGV4XG4gICAqIEByZXR1cm4ge0wuSGFuZGxlci5QYXRoVHJhbnNmb3JtLkhhbmRsZX1cbiAgICovXG4gIF9jcmVhdGVIYW5kbGVyOiBmdW5jdGlvbihsYXRsbmcsIHR5cGUsIGluZGV4KSB7XG4gICAgdmFyIEhhbmRsZUNsYXNzID0gdGhpcy5vcHRpb25zLmhhbmRsZUNsYXNzO1xuICAgIHZhciBtYXJrZXIgPSBuZXcgSGFuZGxlQ2xhc3MobGF0bG5nLFxuICAgICAgTC5VdGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmhhbmRsZXJPcHRpb25zLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2xlYWZsZXQtZHJhZy10cmFuc2Zvcm0tbWFya2VyIGRyYWctbWFya2VyLS0nICtcbiAgICAgICAgICAgICAgICAgICBpbmRleCArICcgZHJhZy1tYXJrZXItLScgKyB0eXBlLFxuICAgICAgICBpbmRleDogICAgIGluZGV4LFxuICAgICAgICB0eXBlOiAgICAgIHR5cGVcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIG1hcmtlci5vbignbW91c2Vkb3duJywgdGhpcy5fb25TY2FsZVN0YXJ0LCB0aGlzKTtcbiAgICByZXR1cm4gbWFya2VyO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEhpZGUobm90IHJlbW92ZSkgdGhlIGhhbmRsZXJzIGxheWVyXG4gICAqL1xuICBfaGlkZUhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5faGFuZGxlcnNHcm91cCk7XG4gIH0sXG5cblxuICAvKipcbiAgICogSGlkZSBoYW5kbGVycyBhbmQgcmVjdGFuZ2xlXG4gICAqL1xuICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hpZGVIYW5kbGVycygpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIERyYWcgcmVjdGFuZ2xlLCByZS1jcmVhdGUgaGFuZGxlcnNcbiAgICovXG4gIF9vbkRyYWdFbmQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICB2YXIgbWF0cml4ID0gKGV2dC5sYXllciA/IGV2dC5sYXllciA6IHRoaXMuX3BhdGgpLmRyYWdnaW5nLl9tYXRyaXguc2xpY2UoKTtcblxuICAgIGlmICghcmVjdC5kcmFnZ2luZykge1xuICAgICAgcmVjdC5kcmFnZ2luZyA9IG5ldyBMLkhhbmRsZXIuUGF0aERyYWcocmVjdCk7XG4gICAgfVxuICAgIHJlY3QuZHJhZ2dpbmcuZW5hYmxlKCk7XG4gICAgdGhpcy5fbWFwLmFkZExheWVyKHJlY3QpO1xuICAgIHJlY3QuZHJhZ2dpbmcuX3RyYW5zZm9ybVBvaW50cyhtYXRyaXgpO1xuICAgIHJlY3QuX3VwZGF0ZVBhdGgoKTtcbiAgICByZWN0Ll9wcm9qZWN0KCk7XG4gICAgXG4gICAgcmVjdC5kcmFnZ2luZy5kaXNhYmxlKCk7XG5cbiAgICB0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5faGFuZGxlcnNHcm91cCk7XG4gICAgdGhpcy5fdXBkYXRlSGFuZGxlcnMoKTtcblxuICAgIHRoaXMuX3BhdGguZmlyZSgndHJhbnNmb3JtZWQnLCB7XG4gICAgICBzY2FsZTogTC5wb2ludCgxLCAxKSxcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgbWF0cml4OiBMLm1hdHJpeC5hcHBseSh1bmRlZmluZWQsIG1hdHJpeCksXG4gICAgICB0cmFuc2xhdGU6IEwucG9pbnQobWF0cml4WzRdLCBtYXRyaXhbNV0pLFxuICAgICAgbGF5ZXI6IHRoaXMuX3BhdGhcbiAgICB9KTtcbiAgfVxufSk7XG5cblxuTC5QYXRoLmFkZEluaXRIb29rKGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLnRyYW5zZm9ybSkge1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IEwuSGFuZGxlci5QYXRoVHJhbnNmb3JtKHRoaXMsIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0pO1xuICB9XG59KTtcblxuXG5leHBvcnQge0x9OyJdfQ==\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _leaflet = __webpack_require__(0);\n\nvar _leaflet2 = _interopRequireDefault(_leaflet);\n\nvar _vue2Leaflet = __webpack_require__(6);\n\n__webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar props = {\n  latLngs: {\n    type: Array,\n    default: function _default() {\n      return [];\n    }\n  },\n  draggable: {\n    type: Boolean,\n    custom: true,\n    default: true\n  },\n  rotation: {\n    type: Boolean,\n    custom: true,\n    default: true\n  },\n  scaling: {\n    type: Boolean,\n    custom: true,\n    default: true\n  },\n  options: {\n    type: Object,\n    default: function _default() {\n      return {\n        transform: true\n      };\n    }\n  },\n  handlerOptions: {\n    type: Object,\n    default: function _default() {\n      return {};\n    }\n  }\n};\n\nexports.default = {\n  name: 'LPathTransform',\n  props: props,\n  mixins: [_vue2Leaflet.LPolygon],\n  data: function data() {\n    return {\n      ready: false\n    };\n  },\n  beforeMount: function beforeMount() {\n    this.options.draggable = this.draggable;\n  },\n  mounted: function mounted() {\n    this.mapObject.transform.setOptions({\n      rotation: this.rotation,\n      scaling: this.scaling,\n      handlerOptions: this.handlerOptions\n    }).enable();\n  },\n\n  methods: {\n    setDraggable: function setDraggable(newVal, oldVal) {\n      if (this.mapObject.dragging) {\n        newVal ? this.mapObject.dragging.enable() : this.mapObject.dragging.disable();\n      }\n    },\n    setVisible: function setVisible(newVal, oldVal) {\n      if (newVal == oldVal) return;\n      if (this.mapObject) {\n        if (newVal) {\n          this.parentContainer.addLayer(this);\n        } else {\n          this.parentContainer.removeLayer(this);\n        }\n      }\n    },\n    setLatLngs: function setLatLngs(newLatLngs) {\n      if (newLatLngs == null) {\n        return;\n      }\n      if (this.mapObject) {\n        var oldLatLngs = this.mapObject.getLatLngs();\n\n        if (newLatLngs === oldLatLngs) {\n          this.mapObject.setLatLngs(newLatLngs);\n        }\n      }\n    }\n  }\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticStyle: {\n      \"display\": \"none\"\n    }\n  }, [(_vm.ready) ? _vm._t(\"default\") : _vm._e()], 2)\n},staticRenderFns: []}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"vue2-leaflet\");\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// Vue2LeafletPathTransform.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a50f1cfd22f05cf291f4","module.exports = require(\"leaflet\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"leaflet\"\n// module id = 0\n// module chunks = 0","var Component = require(\"!./node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!./node_modules/vue-loader/lib/selector?type=script&index=0!./Vue2LeafletPathTransform.vue\"),\n  /* template */\n  require(\"!!./node_modules/vue-loader/lib/template-compiler?id=data-v-54ea6851!./node_modules/vue-loader/lib/selector?type=template&index=0!./Vue2LeafletPathTransform.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Vue2LeafletPathTransform.vue\n// module id = 1\n// module chunks = 0","import L from 'leaflet';\nL.Util.merge = L.Util.extend;\n/**\n * Leaflet vector features drag functionality\n * @author Alexander Milevski <info@w8r.name>\n * @preserve\n */\n\n/**\n * Matrix transform path for SVG/VML\n * Renderer-independent\n */\nL.Path.include({\n\n\t/**\n\t * Applies matrix transformation to SVG\n\t * @param {Array.<Number>?} matrix\n\t */\n\t_transform: function(matrix) {\n\t\tif (this._renderer) {\n\t\t\tif (matrix) {\n\t\t\t\tthis._renderer.transformPath(this, matrix);\n\t\t\t} else {\n\t\t\t\t// reset transform matrix\n\t\t\t\tthis._renderer._resetTransformPath(this);\n\t\t\t\tthis._update();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * Check if the feature was dragged, that'll supress the click event\n\t * on mouseup. That fixes popups for example\n\t *\n\t * @param  {MouseEvent} e\n\t */\n\t_onMouseClick: function(e) {\n\t\tif ((this.dragging && this.dragging.moved()) ||\n\t\t\t(this._map.dragging && this._map.dragging.moved())) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._fireMouseEvent(e);\n\t}\n\n});\nvar END = {\n  mousedown:     'mouseup',\n  touchstart:    'touchend',\n  pointerdown:   'touchend',\n  MSPointerDown: 'touchend'\n};\n\nvar MOVE = {\n  mousedown:     'mousemove',\n  touchstart:    'touchmove',\n  pointerdown:   'touchmove',\n  MSPointerDown: 'touchmove'\n};\n\nfunction distance(a, b) {\n  var dx = a.x - b.x, dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Drag handler\n * @class L.Path.Drag\n * @extends {L.Handler}\n */\nL.Handler.PathDrag = L.Handler.extend( /** @lends  L.Path.Drag.prototype */ {\n\n  statics: {\n    DRAGGING_CLS: 'leaflet-path-draggable',\n  },\n\n\n  /**\n   * @param  {L.Path} path\n   * @constructor\n   */\n  initialize: function(path) {\n\n    /**\n     * @type {L.Path}\n     */\n    this._path = path;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this._matrix = null;\n\n    /**\n     * @type {L.Point}\n     */\n    this._startPoint = null;\n\n    /**\n     * @type {L.Point}\n     */\n    this._dragStartPoint = null;\n\n    /**\n     * @type {Boolean}\n     */\n    this._mapDraggingWasEnabled = false;\n\n  },\n\n  /**\n   * Enable dragging\n   */\n  addHooks: function() {\n    this._path.on('mousedown', this._onDragStart, this);\n\n    this._path.options.className = this._path.options.className ?\n        (this._path.options.className + ' ' + L.Handler.PathDrag.DRAGGING_CLS) :\n         L.Handler.PathDrag.DRAGGING_CLS;\n\n    if (this._path._path) {\n      L.DomUtil.addClass(this._path._path, L.Handler.PathDrag.DRAGGING_CLS);\n    }\n  },\n\n  /**\n   * Disable dragging\n   */\n  removeHooks: function() {\n    this._path.off('mousedown', this._onDragStart, this);\n\n    this._path.options.className = this._path.options.className\n      .replace(new RegExp('\\\\s+' + L.Handler.PathDrag.DRAGGING_CLS), '');\n    if (this._path._path) {\n      L.DomUtil.removeClass(this._path._path, L.Handler.PathDrag.DRAGGING_CLS);\n    }\n  },\n\n  /**\n   * @return {Boolean}\n   */\n  moved: function() {\n    return this._path._dragMoved;\n  },\n\n  /**\n   * Start drag\n   * @param  {L.MouseEvent} evt\n   */\n  _onDragStart: function(evt) {\n    var eventType = evt.originalEvent._simulated ? 'touchstart' : evt.originalEvent.type;\n\n    this._mapDraggingWasEnabled = false;\n    this._startPoint = evt.containerPoint.clone();\n    this._dragStartPoint = evt.containerPoint.clone();\n    this._matrix = [1, 0, 0, 1, 0, 0];\n    L.DomEvent.stop(evt.originalEvent);\n\n    L.DomUtil.addClass(this._path._renderer._container, 'leaflet-interactive');\n    L.DomEvent\n      .on(document, MOVE[eventType], this._onDrag,    this)\n      .on(document, END[eventType],  this._onDragEnd, this);\n\n    if (this._path._map.dragging.enabled()) {\n      // I guess it's required because mousdown gets simulated with a delay\n      //this._path._map.dragging._draggable._onUp(evt);\n\n      this._path._map.dragging.disable();\n      this._mapDraggingWasEnabled = true;\n    }\n    this._path._dragMoved = false;\n\n    if (this._path._popup) { // that might be a case on touch devices as well\n      this._path._popup._close();\n    }\n\n    this._replaceCoordGetters(evt);\n  },\n\n  /**\n   * Dragging\n   * @param  {L.MouseEvent} evt\n   */\n  _onDrag: function(evt) {\n    L.DomEvent.stop(evt);\n\n    var first = (evt.touches && evt.touches.length >= 1 ? evt.touches[0] : evt);\n    var containerPoint = this._path._map.mouseEventToContainerPoint(first);\n\n    // skip taps\n    if (evt.type === 'touchmove' && !this._path._dragMoved) {\n      var totalMouseDragDistance = this._dragStartPoint.distanceTo(containerPoint);\n      if (totalMouseDragDistance <= this._path._map.options.tapTolerance) {\n        return;\n      }\n    }\n\n    var x = containerPoint.x;\n    var y = containerPoint.y;\n\n    var dx = x - this._startPoint.x;\n    var dy = y - this._startPoint.y;\n\n    // Send events only if point was moved\n    if (dx || dy) {\n      if (!this._path._dragMoved) {\n        this._path._dragMoved = true;\n        this._path.fire('dragstart', evt);\n        // we don't want that to happen on click\n        this._path.bringToFront();\n      }\n\n      this._matrix[4] += dx;\n      this._matrix[5] += dy;\n\n      this._startPoint.x = x;\n      this._startPoint.y = y;\n\n      this._path.fire('predrag', evt);\n      this._path._transform(this._matrix);\n      this._path.fire('drag', evt);\n    }\n  },\n\n  /**\n   * Dragging stopped, apply\n   * @param  {L.MouseEvent} evt\n   */\n  _onDragEnd: function(evt) {\n    var containerPoint = this._path._map.mouseEventToContainerPoint(evt);\n    var moved = this.moved();\n\n    // apply matrix\n    if (moved) {\n      this._transformPoints(this._matrix);\n      this._path._updatePath();\n      this._path._project();\n      this._path._transform(null);\n\n      L.DomEvent.stop(evt);\n    }\n\n\n    L.DomEvent.off(document, 'mousemove touchmove', this._onDrag,    this);\n    L.DomEvent.off(document, 'mouseup touchend',    this._onDragEnd, this);\n\n    this._restoreCoordGetters();\n\n    // consistency\n    if (moved) {\n      this._path.fire('dragend', {\n        distance: distance(this._dragStartPoint, containerPoint)\n      });\n\n      // hack for skipping the click in canvas-rendered layers\n      var contains = this._path._containsPoint;\n      this._path._containsPoint = L.Util.falseFn;\n      L.Util.requestAnimFrame(function() {\n        L.DomEvent.skipped({ type: 'click' });\n        this._path._containsPoint = contains;\n      }, this);\n    }\n\n    this._matrix          = null;\n    this._startPoint      = null;\n    this._dragStartPoint  = null;\n    this._path._dragMoved = false;\n\n    if (this._mapDraggingWasEnabled) {\n      if (moved) L.DomEvent.fakeStop({ type: 'click' });\n      this._path._map.dragging.enable();\n    }\n  },\n\n\n  /**\n   * Applies transformation, does it in one sweep for performance,\n   * so don't be surprised about the code repetition.\n   *\n   * [ x ]   [ a  b  tx ] [ x ]   [ a * x + b * y + tx ]\n   * [ y ] = [ c  d  ty ] [ y ] = [ c * x + d * y + ty ]\n   *\n   * @param {Array.<Number>} matrix\n   */\n  _transformPoints: function(matrix, dest) {\n    var path = this._path;\n    var i, len, latlng;\n\n    var px = L.point(matrix[4], matrix[5]);\n\n    var crs = path._map.options.crs;\n    var transformation = crs.transformation;\n    var scale = crs.scale(path._map.getZoom());\n    var projection = crs.projection;\n\n    var diff = transformation.untransform(px, scale)\n      .subtract(transformation.untransform(L.point(0, 0), scale));\n    var applyTransform = !dest;\n\n    path._bounds = new L.LatLngBounds();\n\n    // console.time('transform');\n    // all shifts are in-place\n    if (path._point) { // L.Circle\n      dest = projection.unproject(\n        projection.project(path._latlng)._add(diff));\n      if (applyTransform) {\n        path._latlng = dest;\n        path._point._add(px);\n      }\n    } else if (path._rings || path._parts) { // everything else\n      var rings   = path._rings || path._parts;\n      var latlngs = path._latlngs;\n      dest = dest || latlngs;\n      if (!L.Util.isArray(latlngs[0])) { // polyline\n        latlngs = [latlngs];\n        dest    = [dest];\n      }\n      for (i = 0, len = rings.length; i < len; i++) {\n        dest[i] = dest[i] || [];\n        for (var j = 0, jj = rings[i].length; j < jj; j++) {\n          latlng     = latlngs[i][j];\n          dest[i][j] = projection\n            .unproject(projection.project(latlng)._add(diff));\n          if (applyTransform) {\n            path._bounds.extend(latlngs[i][j]);\n            rings[i][j]._add(px);\n          }\n        }\n      }\n    }\n    return dest;\n    // console.timeEnd('transform');\n  },\n\n\n\n  /**\n   * If you want to read the latlngs during the drag - your right,\n   * but they have to be transformed\n   */\n  _replaceCoordGetters: function() {\n    if (this._path.getLatLng) { // Circle, CircleMarker\n      this._path.getLatLng_ = this._path.getLatLng;\n      this._path.getLatLng = L.Util.bind(function() {\n        return this.dragging._transformPoints(this.dragging._matrix, {});\n      }, this._path);\n    } else if (this._path.getLatLngs) {\n      this._path.getLatLngs_ = this._path.getLatLngs;\n      this._path.getLatLngs = L.Util.bind(function() {\n        return this.dragging._transformPoints(this.dragging._matrix, []);\n      }, this._path);\n    }\n  },\n\n\n  /**\n   * Put back the getters\n   */\n  _restoreCoordGetters: function() {\n    if (this._path.getLatLng_) {\n      this._path.getLatLng = this._path.getLatLng_;\n      delete this._path.getLatLng_;\n    } else if (this._path.getLatLngs_) {\n      this._path.getLatLngs = this._path.getLatLngs_;\n      delete this._path.getLatLngs_;\n    }\n  }\n\n});\n\n\n/**\n * @param  {L.Path} layer\n * @return {L.Path}\n */\nL.Handler.PathDrag.makeDraggable = function(layer) {\n  layer.dragging = new L.Handler.PathDrag(layer);\n  return layer;\n};\n\n\n/**\n * Also expose as a method\n * @return {L.Path}\n */\nL.Path.prototype.makeDraggable = function() {\n  return L.Handler.PathDrag.makeDraggable(this);\n};\n\n\nL.Path.addInitHook(function() {\n  if (this.options.draggable) {\n    // ensure interactive\n    this.options.interactive = true;\n\n    if (this.dragging) {\n      this.dragging.enable();\n    } else {\n      L.Handler.PathDrag.makeDraggable(this);\n      this.dragging.enable();\n    }\n  } else if (this.dragging) {\n    this.dragging.disable();\n  }\n});\nL.SVG.include({\n\n\t/**\n\t * Reset transform matrix\n\t */\n\t_resetTransformPath: function(layer) {\n\t\tlayer._path.setAttributeNS(null, 'transform', '');\n\t},\n\n\t/**\n\t * Applies matrix transformation to SVG\n\t * @param {L.Path}         layer\n\t * @param {Array.<Number>} matrix\n\t */\n\ttransformPath: function(layer, matrix) {\n\t\tlayer._path.setAttributeNS(null, 'transform',\n\t\t\t'matrix(' + matrix.join(' ') + ')');\n\t}\n\n});\nL.SVG.include(!L.Browser.vml ? {} : {\n\n\t/**\n\t * Reset transform matrix\n\t */\n\t_resetTransformPath: function(layer) {\n\t\tif (layer._skew) {\n\t\t\t// super important! workaround for a 'jumping' glitch:\n\t\t\t// disable transform before removing it\n\t\t\tlayer._skew.on = false;\n\t\t\tlayer._path.removeChild(layer._skew);\n\t\t\tlayer._skew = null;\n\t\t}\n\t},\n\n\t/**\n\t * Applies matrix transformation to VML\n\t * @param {L.Path}         layer\n\t * @param {Array.<Number>} matrix\n\t */\n\ttransformPath: function(layer, matrix) {\n\t\tvar skew = layer._skew;\n\n\t\tif (!skew) {\n\t\t\tskew = L.SVG.create('skew');\n\t\t\tlayer._path.appendChild(skew);\n\t\t\tskew.style.behavior = 'url(#default#VML)';\n\t\t\tlayer._skew = skew;\n\t\t}\n\n\t\t// handle skew/translate separately, cause it's broken\n\t\tvar mt = matrix[0].toFixed(8) + ' ' + matrix[1].toFixed(8) + ' ' +\n\t\t\tmatrix[2].toFixed(8) + ' ' + matrix[3].toFixed(8) + ' 0 0';\n\t\tvar offset = Math.floor(matrix[4]).toFixed() + ', ' +\n\t\t\tMath.floor(matrix[5]).toFixed() + '';\n\n\t\tvar s = this._path.style;\n\t\tvar l = parseFloat(s.left);\n\t\tvar t = parseFloat(s.top);\n\t\tvar w = parseFloat(s.width);\n\t\tvar h = parseFloat(s.height);\n\n\t\tif (isNaN(l))       l = 0;\n\t\tif (isNaN(t))       t = 0;\n\t\tif (isNaN(w) || !w) w = 1;\n\t\tif (isNaN(h) || !h) h = 1;\n\n\t\tvar origin = (-l / w - 0.5).toFixed(8) + ' ' + (-t / h - 0.5).toFixed(8);\n\n\t\tskew.on = 'f';\n\t\tskew.matrix = mt;\n\t\tskew.origin = origin;\n\t\tskew.offset = offset;\n\t\tskew.on = true;\n\t}\n\n});\nfunction TRUE_FN () { return true; }\n\nL.Canvas.include({\n\n  /**\n   * Do nothing\n   * @param  {L.Path} layer\n   */\n  _resetTransformPath: function(layer) {\n    if (!this._containerCopy) return;\n\n    delete this._containerCopy;\n\n    if (layer._containsPoint_) {\n      layer._containsPoint = layer._containsPoint_;\n      delete layer._containsPoint_;\n\n      this._requestRedraw(layer);\n    }\n  },\n\n\n  /**\n   * Algorithm outline:\n   *\n   * 1. pre-transform - clear the path out of the canvas, copy canvas state\n   * 2. at every frame:\n   *    2.1. save\n   *    2.2. redraw the canvas from saved one\n   *    2.3. transform\n   *    2.4. draw path\n   *    2.5. restore\n   * 3. Repeat\n   *\n   * @param  {L.Path}         layer\n   * @param  {Array.<Number>} matrix\n   */\n  transformPath: function(layer, matrix) {\n    var copy   = this._containerCopy;\n    var ctx    = this._ctx, copyCtx;\n    var m      = L.Browser.retina ? 2 : 1;\n    var bounds = this._bounds;\n    var size   = bounds.getSize();\n    var pos    = bounds.min;\n\n    if (!copy) { // get copy of all rendered layers\n      copy = this._containerCopy = document.createElement('canvas');\n      copyCtx = copy.getContext('2d');\n      // document.body.appendChild(copy);\n\n      copy.width  = m * size.x;\n      copy.height = m * size.y;\n\n      this._removePath(layer);\n      this._redraw();\n\n      copyCtx.translate(m * bounds.min.x, m * bounds.min.y);\n      copyCtx.drawImage(this._container, 0, 0);\n      this._initPath(layer);\n\n      // avoid flickering because of the 'mouseover's\n      layer._containsPoint_ = layer._containsPoint;\n      layer._containsPoint  = TRUE_FN;\n    }\n\n    ctx.save();\n    ctx.clearRect(pos.x, pos.y, size.x * m, size.y * m);\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.restore();\n    ctx.save();\n\n    ctx.drawImage(this._containerCopy, 0, 0, size.x, size.y);\n    ctx.transform.apply(ctx, matrix);\n\n    // now draw one layer only\n    this._drawing = true;\n    layer._updatePath();\n    this._drawing = false;\n\n    ctx.restore();\n  }\n\n});\n/**\n * Drag/rotate/resize handler for [leaflet](http://leafletjs.com) vector features.\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n/**\n * @namespace\n * @type {Object}\n */\nL.PathTransform = {};\n\n/**\n * Point on the line segment or its extention\n *\n * @param  {L.Point} start\n * @param  {L.Point} final\n * @param  {Number}  distPx\n * @return {L.Point}\n */\nL.PathTransform.pointOnLine = function(start, final, distPx) {\n  var ratio = 1 + distPx / start.distanceTo(final);\n  return new L.Point(\n    start.x + (final.x - start.x) * ratio,\n    start.y + (final.y - start.y) * ratio\n  );\n};\n\n\n/**\n * Deep merge objects.\n */\nL.PathTransform.merge = function() {\n  var i = 1;\n  var key, val;\n  var obj = arguments[i];\n\n  function isObject(object) {\n    return Object.prototype.toString.call(object) === '[object Object]';\n  }\n\n  // make sure we don't modify source element and it's properties\n  // objects are passed by reference\n  var target = arguments[0];\n\n  while (obj) {\n    obj = arguments[i++];\n    for (key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      val = obj[key];\n\n      if (isObject(val) && isObject(target[key])){\n        target[key] = L.Util.merge(target[key], val);\n      } else {\n        target[key] = val;\n      }\n    }\n  }\n  return target;\n};\n/**\n * @class  L.Matrix\n *\n * @param {Number} a\n * @param {Number} b\n * @param {Number} c\n * @param {Number} d\n * @param {Number} e\n * @param {Number} f\n */\nL.Matrix = function(a, b, c, d, e, f) {\n\n  /**\n   * @type {Array.<Number>}\n   */\n  this._matrix = [a, b, c, d, e, f];\n};\n\n\nL.Matrix.prototype = {\n\n\n  /**\n   * @param  {L.Point} point\n   * @return {L.Point}\n   */\n  transform: function(point) {\n    return this._transform(point.clone());\n  },\n\n\n  /**\n   * Destructive\n   *\n   * [ x ] = [ a  b  tx ] [ x ] = [ a * x + b * y + tx ]\n   * [ y ] = [ c  d  ty ] [ y ] = [ c * x + d * y + ty ]\n   *\n   * @param  {L.Point} point\n   * @return {L.Point}\n   */\n  _transform: function(point) {\n    var matrix = this._matrix;\n    var x = point.x, y = point.y;\n    point.x = matrix[0] * x + matrix[1] * y + matrix[4];\n    point.y = matrix[2] * x + matrix[3] * y + matrix[5];\n    return point;\n  },\n\n\n  /**\n   * @param  {L.Point} point\n   * @return {L.Point}\n   */\n  untransform: function (point) {\n    var matrix = this._matrix;\n    return new L.Point(\n      (point.x / matrix[0] - matrix[4]) / matrix[0],\n      (point.y / matrix[2] - matrix[5]) / matrix[2]\n    );\n  },\n\n\n  /**\n   * @return {L.Matrix}\n   */\n  clone: function() {\n    var matrix = this._matrix;\n    return new L.Matrix(\n      matrix[0], matrix[1], matrix[2],\n      matrix[3], matrix[4], matrix[5]\n    );\n  },\n\n\n  /**\n   * @param {L.Point=|Number=} translate\n   * @return {L.Matrix|L.Point}\n   */\n  translate: function(translate) {\n    if (translate === undefined) {\n      return new L.Point(this._matrix[4], this._matrix[5]);\n    }\n\n    var translateX, translateY;\n    if (typeof translate === 'number') {\n      translateX = translateY = translate;\n    } else {\n      translateX = translate.x;\n      translateY = translate.y;\n    }\n\n    return this._add(1, 0, 0, 1, translateX, translateY);\n  },\n\n\n  /**\n   * @param {L.Point=|Number=} scale\n   * @return {L.Matrix|L.Point}\n   */\n  scale: function(scale, origin) {\n    if (scale === undefined) {\n      return new L.Point(this._matrix[0], this._matrix[3]);\n    }\n\n    var scaleX, scaleY;\n    origin = origin || L.point(0, 0);\n    if (typeof scale === 'number') {\n      scaleX = scaleY = scale;\n    } else {\n      scaleX = scale.x;\n      scaleY = scale.y;\n    }\n\n    return this\n      ._add(scaleX, 0, 0, scaleY, origin.x, origin.y)\n      ._add(1, 0, 0, 1, -origin.x, -origin.y);\n  },\n\n\n  /**\n   * m00  m01  x - m00 * x - m01 * y\n   * m10  m11  y - m10 * x - m11 * y\n   * @param {Number}   angle\n   * @param {L.Point=} origin\n   * @return {L.Matrix}\n   */\n  rotate: function(angle, origin) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n\n    origin = origin || new L.Point(0, 0);\n\n    return this\n      ._add(cos, sin, -sin, cos, origin.x, origin.y)\n      ._add(1, 0, 0, 1, -origin.x, -origin.y);\n  },\n\n\n  /**\n   * Invert rotation\n   * @return {L.Matrix}\n   */\n  flip: function() {\n    this._matrix[1] *= -1;\n    this._matrix[2] *= -1;\n    return this;\n  },\n\n\n  /**\n   * @param {Number|L.Matrix} a\n   * @param {Number} b\n   * @param {Number} c\n   * @param {Number} d\n   * @param {Number} e\n   * @param {Number} f\n   */\n  _add: function(a, b, c, d, e, f) {\n    var result = [[], [], []];\n    var src = this._matrix;\n    var m = [\n      [src[0], src[2], src[4]],\n      [src[1], src[3], src[5]],\n      [     0,      0,     1]\n    ];\n    var other = [\n      [a, c, e],\n      [b, d, f],\n      [0, 0, 1]\n    ], val;\n\n\n    if (a && a instanceof L.Matrix) {\n      src = a._matrix;\n      other = [\n        [src[0], src[2], src[4]],\n        [src[1], src[3], src[5]],\n        [     0,      0,     1]];\n    }\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        val = 0;\n        for (var k = 0; k < 3; k++) {\n          val += m[i][k] * other[k][j];\n        }\n        result[i][j] = val;\n      }\n    }\n\n    this._matrix = [\n      result[0][0], result[1][0], result[0][1],\n      result[1][1], result[0][2], result[1][2]\n    ];\n    return this;\n  }\n\n\n};\n\n\nL.matrix = function(a, b, c, d, e, f) {\n  return new L.Matrix(a, b, c, d, e, f);\n};\n\n\n/**\n * Marker handler\n * @extends {L.CircleMarker}\n */\nL.PathTransform.Handle = L.CircleMarker.extend({\n  options: {\n    className: 'leaflet-path-transform-handler'\n  },\n\n  onAdd: function (map) {\n    L.CircleMarker.prototype.onAdd.call(this, map);\n    if (this._path && this.options.setCursor) { // SVG/VML\n      this._path.style.cursor = L.PathTransform.Handle.CursorsByType[\n        this.options.index\n      ];\n    }\n  }\n});\n\n\n/**\n * @const\n * @type {Array}\n */\nL.PathTransform.Handle.CursorsByType = [\n  'nesw-resize', 'nwse-resize', 'nesw-resize', 'nwse-resize'\n];\n\n\n/**\n * @extends {L.Handler.PathTransform.Handle}\n */\nL.PathTransform.RotateHandle = L.PathTransform.Handle.extend({\n  options: {\n    className: 'leaflet-path-transform-handler transform-handler--rotate'\n  },\n\n  onAdd: function (map) {\n    L.CircleMarker.prototype.onAdd.call(this, map);\n    if (this._path && this.options.setCursor) { // SVG/VML\n      this._path.style.cursor = 'all-scroll';\n    }\n  }\n});\n\nL.Handler.PathTransform = L.Handler.extend({\n\n  options: {\n    rotation: true,\n    scaling:  true,\n    uniformScaling: true,\n    maxZoom:  22,\n\n    // edge handlers\n    handlerOptions: {\n      radius:      5,\n      fillColor:   '#ffffff',\n      color:       '#202020',\n      fillOpacity: 1,\n      weight:      2,\n      opacity:     0.7,\n      setCursor:   true\n    },\n\n    // rectangle\n    boundsOptions: {\n      weight:    1,\n      opacity:   1,\n      dashArray: [3, 3],\n      fill:      false\n    },\n\n    // rotation handler\n    rotateHandleOptions: {\n      weight:    1,\n      opacity:   1,\n      setCursor: true\n    },\n    // rotation handle length\n    handleLength: 20,\n\n    // maybe I'll add skewing in the future\n    edgesCount:   4,\n\n    handleClass:       L.PathTransform.Handle,\n    rotateHandleClass: L.PathTransform.RotateHandle\n  },\n\n\n  /**\n   * @class L.Handler.PathTransform\n   * @constructor\n   * @param  {L.Path} path\n   */\n  initialize: function(path) {\n    // references\n    this._path = path;\n    this._map  = null;\n\n    // handlers\n    this._activeMarker   = null;\n    this._originMarker   = null;\n    this._rotationMarker = null;\n\n    // origins & temporary state\n    this._rotationOrigin   = null;\n    this._scaleOrigin      = null;\n    this._angle            = 0;\n    this._scale            = L.point(1, 1);\n    this._initialDist      = 0;\n    this._initialDistX     = 0;\n    this._initialDistY     = 0;\n    this._rotationStart    = null;\n    this._rotationOriginPt = null;\n\n    // preview and transform matrix\n    this._matrix          = new L.Matrix(1, 0, 0, 1, 0, 0);\n    this._projectedMatrix = new L.Matrix(1, 0, 0, 1, 0, 0);\n\n    // ui elements\n    this._handlersGroup  = null;\n    this._rect           = null;\n    this._handlers       = [];\n    this._handleLine     = null;\n  },\n\n\n  /**\n   * If the polygon is not rendered, you can transform it yourself\n   * in the coordinates, and do it properly.\n   * @param {Object=} options\n   */\n  enable: function(options) {\n    if (this._path._map) {\n      this._map = this._path._map;\n      if (options) {\n        this.setOptions(options);\n      }\n      L.Handler.prototype.enable.call(this);\n    }\n  },\n\n\n  /**\n   * Init interactions and handlers\n   */\n  addHooks: function() {\n    this._createHandlers();\n    this._path\n      .on('dragstart', this._onDragStart, this)\n      .on('dragend',   this._onDragEnd,   this);\n  },\n\n\n  /**\n   * Remove handlers\n   */\n  removeHooks: function() {\n    this._hideHandlers();\n    this._path\n      .off('dragstart', this._onDragStart, this)\n      .off('dragend',   this._onDragEnd,   this);\n    this._handlersGroup = null;\n    this._rect = null;\n    this._handlers = [];\n  },\n\n\n  /**\n   * Change editing options\n   * @param {Object} options\n   */\n  setOptions: function(options) {\n    var enabled = this._enabled;\n    if (enabled) {\n      this.disable();\n    }\n\n    this.options = L.PathTransform.merge({},\n      L.Handler.PathTransform.prototype.options,\n      options);\n\n    if (enabled) {\n      this.enable();\n    }\n\n    return this;\n  },\n\n\n  /**\n   * @param  {Number}   angle\n   * @param  {L.LatLng} origin\n   * @return {L.Handler.PathTransform}\n   */\n  rotate: function(angle, origin) {\n    return this.transform(angle, null, origin);\n  },\n\n\n  /**\n   * @param  {L.Point|Number} scale\n   * @param  {L.LatLng}       origin\n   * @return {L.Handler.PathTransform}\n   */\n  scale: function(scale, origin) {\n    if (typeof scale === 'number') {\n      scale = L.point(scale, scale);\n    }\n    return this.transform(0, scale, null, origin);\n  },\n\n\n  /**\n   * @param  {Number}    angle\n   * @param  {L.Point}   scale\n   * @param  {L.LatLng=} rotationOrigin\n   * @param  {L.LatLng=} scaleOrigin\n   * @return {L.Handler.PathTransform}\n   */\n  transform: function(angle, scale, rotationOrigin, scaleOrigin) {\n    var center     = this._path.getCenter();\n    rotationOrigin = rotationOrigin || center;\n    scaleOrigin    = scaleOrigin    || center;\n    this._map = this._path._map;\n    this._transformPoints(this._path, angle, scale, rotationOrigin, scaleOrigin);\n    return this;\n  },\n\n\n  /**\n   * Update the polygon and handlers preview, no reprojection\n   */\n  _update: function() {\n    var matrix = this._matrix;\n\n    // update handlers\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      if (handler !== this._originMarker) {\n        handler._point = matrix.transform(handler._initialPoint);\n        handler._updatePath();\n      }\n    }\n\n    matrix = matrix.clone().flip();\n\n    this._applyTransform(matrix);\n    this._path.fire('transform', { layer: this._path });\n  },\n\n\n  /**\n   * @param  {L.Matrix} matrix\n   */\n  _applyTransform: function(matrix) {\n    this._path._transform(matrix._matrix);\n    this._rect._transform(matrix._matrix);\n\n    if (this.options.rotation) {\n      this._handleLine._transform(matrix._matrix);\n    }\n  },\n\n\n  /**\n   * Apply final transformation\n   */\n  _apply: function() {\n    //console.group('apply transform');\n    var map = this._map;\n    var matrix = this._matrix.clone();\n    var angle = this._angle;\n    var scale = this._scale.clone();\n\n    this._transformGeometries();\n\n    // update handlers\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      handler._latlng = map.layerPointToLatLng(handler._point);\n      delete handler._initialPoint;\n      handler.redraw();\n    }\n\n    this._matrix = L.matrix(1, 0, 0, 1, 0, 0);\n    this._scale  = L.point(1, 1);\n    this._angle  = 0;\n\n    this._updateHandlers();\n\n    map.dragging.enable();\n    this._path.fire('transformed', {\n      matrix: matrix,\n      scale: scale,\n      rotation: angle,\n      // angle: angle * (180 / Math.PI),\n      layer: this._path\n    });\n    // console.groupEnd('apply transform');\n  },\n\n\n  /**\n   * Use this method to completely reset handlers, if you have changed the\n   * geometry of transformed layer\n   */\n  reset: function() {\n    if (this._enabled) {\n      if (this._rect) {\n        this._handlersGroup.removeLayer(this._rect);\n        this._rect = this._getBoundingPolygon().addTo(this._handlersGroup);\n      }\n      this._updateHandlers();\n    }\n  },\n\n\n  /**\n   * Recalculate rotation handlers position\n   */\n  _updateHandlers: function() {\n    var handlersGroup = this._handlersGroup;\n\n    this._rectShape = this._rect.toGeoJSON();\n\n    if (this._handleLine) {\n      this._handlersGroup.removeLayer(this._handleLine);\n    }\n\n    if (this._rotationMarker) {\n      this._handlersGroup.removeLayer(this._rotationMarker);\n    }\n\n    this._handleLine = this._rotationMarker = null;\n\n    for (var i = this._handlers.length - 1; i >= 0; i--) {\n      handlersGroup.removeLayer(this._handlers[i]);\n    }\n\n    this._createHandlers();\n  },\n\n\n  /**\n   * Transform geometries separately\n   */\n  _transformGeometries: function() {\n    this._path._transform(null);\n    this._rect._transform(null);\n\n    this._transformPoints(this._path);\n    this._transformPoints(this._rect);\n\n    if (this.options.rotation) {\n      this._handleLine._transform(null);\n      this._transformPoints(this._handleLine, this._angle, null, this._origin);\n    }\n  },\n\n\n  /**\n   * @param {Number} angle\n   * @param {Number} scale\n   * @param {L.LatLng=} rotationOrigin\n   * @param {L.LatLng=} scaleOrigin\n   */\n  _getProjectedMatrix: function(angle, scale, rotationOrigin, scaleOrigin) {\n    var map    = this._map;\n    var zoom   = map.getMaxZoom() || this.options.maxZoom;\n    var matrix = L.matrix(1, 0, 0, 1, 0, 0);\n    var origin;\n\n    angle = angle || this._angle || 0;\n    scale = scale || this._scale || L.point(1, 1);\n\n    if (!(scale.x === 1 && scale.y === 1)) {\n      scaleOrigin = scaleOrigin || this._scaleOrigin;\n      origin = map.project(scaleOrigin, zoom);\n      matrix = matrix\n        ._add(L.matrix(1, 0, 0, 1, origin.x, origin.y))\n        ._add(L.matrix(scale.x, 0, 0, scale.y, 0, 0))\n        ._add(L.matrix(1, 0, 0, 1, -origin.x, -origin.y));\n    }\n\n    if (angle) {\n      rotationOrigin = rotationOrigin || this._rotationOrigin;\n      origin = map.project(rotationOrigin, zoom);\n      matrix = matrix.rotate(angle, origin).flip();\n    }\n\n    return matrix;\n  },\n\n\n  /**\n   * @param  {L.LatLng} latlng\n   * @param  {L.Matrix} matrix\n   * @param  {L.Map}    map\n   * @param  {Number}   zoom\n   * @return {L.LatLng}\n   */\n  _transformPoint: function(latlng, matrix, map, zoom) {\n    return map.unproject(matrix.transform(\n      map.project(latlng, zoom)), zoom);\n  },\n\n\n  /**\n   * Applies transformation, does it in one sweep for performance,\n   * so don't be surprised about the code repetition.\n   *\n   * @param {L.Path}    path\n   * @param {Number=}   angle\n   * @param {L.Point=}  scale\n   * @param {L.LatLng=} rotationOrigin\n   * @param {L.LatLng=} scaleOrigin\n   */\n  _transformPoints: function(path, angle, scale, rotationOrigin, scaleOrigin) {\n    var map = path._map;\n    var zoom = map.getMaxZoom() || this.options.maxZoom;\n    var i, len;\n\n    var projectedMatrix = this._projectedMatrix =\n      this._getProjectedMatrix(angle, scale, rotationOrigin, scaleOrigin);\n    // console.time('transform');\n\n    // all shifts are in-place\n    if (path._point) { // L.Circle\n      path._latlng = this._transformPoint(\n        path._latlng, projectedMatrix, map, zoom);\n    } else if (path._rings || path._parts) { // everything else\n      var rings = path._rings;\n      var latlngs = path._latlngs;\n      path._bounds = new L.LatLngBounds();\n\n      if (!L.Util.isArray(latlngs[0])) { // polyline\n        latlngs = [latlngs];\n      }\n      for (i = 0, len = rings.length; i < len; i++) {\n        for (var j = 0, jj = rings[i].length; j < jj; j++) {\n          latlngs[i][j] = this._transformPoint(\n            latlngs[i][j], projectedMatrix, map, zoom);\n          path._bounds.extend(latlngs[i][j]);\n        }\n      }\n    }\n\n    path._reset();\n    //console.timeEnd('transform');\n  },\n\n\n  /**\n   * Creates markers and handles\n   */\n  _createHandlers: function() {\n    var map = this._map;\n    this._handlersGroup = this._handlersGroup ||\n                          new L.LayerGroup().addTo(map);\n    this._rect = this._rect ||\n                 this._getBoundingPolygon().addTo(this._handlersGroup);\n\n    if (this.options.scaling) {\n      this._handlers = [];\n      for (var i = 0; i < this.options.edgesCount; i++) {\n        // TODO: add stretching\n        this._handlers.push(\n          this._createHandler(this._rect._latlngs[0][i], i * 2, i)\n          .addTo(this._handlersGroup));\n      }\n    }\n\n    // add bounds\n    if (this.options.rotation) {\n      //add rotation handler\n      this._createRotationHandlers();\n    }\n  },\n\n\n  /**\n   * Rotation marker and small connectin handle\n   */\n  _createRotationHandlers: function() {\n    var map     = this._map;\n    var latlngs = this._rect._latlngs[0];\n\n    var bottom   = new L.LatLng(\n      (latlngs[0].lat + latlngs[3].lat) / 2,\n      (latlngs[0].lng + latlngs[3].lng) / 2);\n    // hehe, top is a reserved word\n    var topPoint = new L.LatLng(\n      (latlngs[1].lat + latlngs[2].lat) / 2,\n      (latlngs[1].lng + latlngs[2].lng) / 2);\n\n    var handlerPosition = map.layerPointToLatLng(\n      L.PathTransform.pointOnLine(\n        map.latLngToLayerPoint(bottom),\n        map.latLngToLayerPoint(topPoint),\n        this.options.handleLength)\n    );\n\n    this._handleLine = new L.Polyline([topPoint, handlerPosition],\n      this.options.rotateHandleOptions).addTo(this._handlersGroup);\n    var RotateHandleClass = this.options.rotateHandleClass;\n    this._rotationMarker = new RotateHandleClass(handlerPosition,\n      this.options.handlerOptions)\n      .addTo(this._handlersGroup)\n      .on('mousedown', this._onRotateStart, this);\n\n    this._rotationOrigin = new L.LatLng(\n      (topPoint.lat + bottom.lat) / 2,\n      (topPoint.lng + bottom.lng) / 2\n    );\n\n    this._handlers.push(this._rotationMarker);\n  },\n\n\n  /**\n   * @return {L.LatLng}\n   */\n  _getRotationOrigin: function() {\n    var latlngs = this._rect._latlngs[0];\n    var lb = latlngs[0];\n    var rt = latlngs[2];\n\n    return new L.LatLng(\n      (lb.lat + rt.lat) / 2,\n      (lb.lng + rt.lng) / 2\n    );\n  },\n\n\n  /**\n   * Secure the rotation origin\n   * @param  {Event} evt\n   */\n  _onRotateStart: function(evt) {\n    var map = this._map;\n\n    map.dragging.disable();\n\n    this._originMarker     = null;\n    this._rotationOriginPt = map.latLngToLayerPoint(this._getRotationOrigin());\n    this._rotationStart    = evt.layerPoint;\n    this._initialMatrix    = this._matrix.clone();\n\n    this._angle = 0;\n    this._path._map\n      .on('mousemove', this._onRotate,     this)\n      .on('mouseup',   this._onRotateEnd, this);\n\n    this._cachePoints();\n    this._path\n      .fire('transformstart',   { layer: this._path })\n      .fire('rotatestart', { layer: this._path, rotation: 0 });\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onRotate: function(evt) {\n    var pos = evt.layerPoint;\n    var previous = this._rotationStart;\n    var origin   = this._rotationOriginPt;\n\n    // rotation step angle\n    this._angle = Math.atan2(pos.y - origin.y, pos.x - origin.x) -\n                  Math.atan2(previous.y - origin.y, previous.x - origin.x);\n\n    this._matrix = this._initialMatrix\n      .clone()\n      .rotate(this._angle, origin)\n      .flip();\n\n    this._update();\n    this._path.fire('rotate', { layer: this._path, rotation: this._angle });\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onRotateEnd: function(evt) {\n    this._path._map\n      .off('mousemove', this._onRotate, this)\n      .off('mouseup',   this._onRotateEnd, this);\n\n    this._apply();\n    this._path.fire('rotateend', { layer: this._path, rotation: this._angle });\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onScaleStart: function(evt) {\n    var marker = evt.target;\n    var map = this._map;\n\n    map.dragging.disable();\n\n    this._activeMarker = marker;\n\n    this._originMarker = this._handlers[(marker.options.index + 2) % 4];\n    this._scaleOrigin  = this._originMarker.getLatLng();\n\n    this._initialMatrix = this._matrix.clone();\n    this._cachePoints();\n\n    this._map\n      .on('mousemove', this._onScale,    this)\n      .on('mouseup',   this._onScaleEnd, this);\n    this._initialDist  = this._originMarker._point.distanceTo(this._activeMarker._point);\n    this._initialDistX = this._originMarker._point.x - this._activeMarker._point.x;\n    this._initialDistY = this._originMarker._point.y - this._activeMarker._point.y;\n\n    this._path\n      .fire('transformstart', { layer: this._path })\n      .fire('scalestart', { layer: this._path, scale: L.point(1, 1) });\n\n    this._map.removeLayer(this._handleLine);\n    this._map.removeLayer(this._rotationMarker);\n\n    //this._handleLine = this._rotationMarker = null;\n  },\n\n\n  /**\n   * @param  {Event} evt\n   */\n  _onScale: function(evt) {\n    var originPoint = this._originMarker._point;\n    var ratioX, ratioY;\n    if (this.options.uniformScaling) {\n      ratioX = originPoint.distanceTo(evt.layerPoint) / this._initialDist;\n      ratioY = ratioX;\n    } else {\n      ratioX = (originPoint.x - evt.layerPoint.x) / this._initialDistX;\n      ratioY = (originPoint.y - evt.layerPoint.y) / this._initialDistY;\n    }\n\n    this._scale = new L.Point(ratioX, ratioY);\n\n    // update matrix\n    this._matrix = this._initialMatrix\n      .clone()\n      .scale(this._scale, originPoint);\n\n    this._update();\n    this._path.fire('scale', {\n      layer: this._path, scale: this._scale.clone() });\n  },\n\n\n  /**\n   * Scaling complete\n   * @param  {Event} evt\n   */\n  _onScaleEnd: function(evt) {\n    this._map\n      .off('mousemove', this._onScale,    this)\n      .off('mouseup',   this._onScaleEnd, this);\n\n    this._map.addLayer(this._handleLine);\n    this._map.addLayer(this._rotationMarker);\n\n    this._apply();\n    this._path.fire('scaleend', {\n      layer: this._path, scale: this._scale.clone() });\n  },\n\n\n  /**\n   * Cache current handlers positions\n   */\n  _cachePoints: function() {\n    this._handlersGroup.eachLayer(function(layer) {\n      layer.bringToFront();\n    });\n    for (var i = 0, len = this._handlers.length; i < len; i++) {\n      var handler = this._handlers[i];\n      handler._initialPoint = handler._point.clone();\n    }\n  },\n\n\n  /**\n   * Bounding polygon\n   * @return {L.Polygon}\n   */\n  _getBoundingPolygon: function() {\n    if (this._rectShape) {\n      return L.GeoJSON.geometryToLayer(\n        this._rectShape, this.options.boundsOptions);\n    } else {\n      return new L.Rectangle(\n        this._path.getBounds(), this.options.boundsOptions);\n    }\n  },\n\n\n  /**\n   * Create corner marker\n   * @param  {L.LatLng} latlng\n   * @param  {Number}   type one of L.Handler.PathTransform.HandlerTypes\n   * @param  {Number}   index\n   * @return {L.Handler.PathTransform.Handle}\n   */\n  _createHandler: function(latlng, type, index) {\n    var HandleClass = this.options.handleClass;\n    var marker = new HandleClass(latlng,\n      L.Util.extend({}, this.options.handlerOptions, {\n        className: 'leaflet-drag-transform-marker drag-marker--' +\n                   index + ' drag-marker--' + type,\n        index:     index,\n        type:      type\n      })\n    );\n\n    marker.on('mousedown', this._onScaleStart, this);\n    return marker;\n  },\n\n\n  /**\n   * Hide(not remove) the handlers layer\n   */\n  _hideHandlers: function() {\n    this._map.removeLayer(this._handlersGroup);\n  },\n\n\n  /**\n   * Hide handlers and rectangle\n   */\n  _onDragStart: function() {\n    this._hideHandlers();\n  },\n\n\n  /**\n   * Drag rectangle, re-create handlers\n   */\n  _onDragEnd: function(evt) {\n    var rect = this._rect;\n    var matrix = (evt.layer ? evt.layer : this._path).dragging._matrix.slice();\n\n    if (!rect.dragging) {\n      rect.dragging = new L.Handler.PathDrag(rect);\n    }\n    rect.dragging.enable();\n    this._map.addLayer(rect);\n    rect.dragging._transformPoints(matrix);\n    rect._updatePath();\n    rect._project();\n    \n    rect.dragging.disable();\n\n    this._map.addLayer(this._handlersGroup);\n    this._updateHandlers();\n\n    this._path.fire('transformed', {\n      scale: L.point(1, 1),\n      rotation: 0,\n      matrix: L.matrix.apply(undefined, matrix),\n      translate: L.point(matrix[4], matrix[5]),\n      layer: this._path\n    });\n  }\n});\n\n\nL.Path.addInitHook(function() {\n  if (this.options.transform) {\n    this.transform = new L.Handler.PathTransform(this, this.options.transform);\n  }\n});\n\n\nexport {L};\n\n\n// WEBPACK FOOTER //\n// ./L.Path.Transform-src.js","<template>\n  <div style=\"display: none;\">\n    <slot v-if=\"ready\"></slot>\n  </div>\n</template>\n\n<script>\n\nimport L from 'leaflet'\nimport { propsBinder,findRealParent, LPolygon } from 'vue2-leaflet'\nimport './L.Path.Transform-src.js'\n\nconst props = {\n  latLngs: {\n    type: Array,\n    default: () => []\n  },\n  draggable: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  rotation: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  scaling: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  options: {\n    type: Object,\n    default: () => ({\n      transform:true\n    }),\n  },\n  handlerOptions: {\n    type: Object,\n    default: () => ({}),\n  },\n};\n\n\nexport default {\n  name: 'LPathTransform',\n  props: props,\n  mixins: [LPolygon],\n  data() {\n    return {\n      ready: false,\n    }\n  },\n  beforeMount() {\n    this.options.draggable = this.draggable;\n  },\n  mounted() {\n    this.mapObject.transform.setOptions({\n      rotation:this.rotation,\n      scaling:this.scaling,\n      handlerOptions: this.handlerOptions\n    }).enable();\n\n  },\n  methods: {\n    setDraggable(newVal, oldVal) {\n      if (this.mapObject.dragging) {\n        newVal ? this.mapObject.dragging.enable() : this.mapObject.dragging.disable();\n      }\n    },\n    setVisible(newVal, oldVal) {\n      if (newVal == oldVal) return;\n      if (this.mapObject) {\n        if (newVal) {\n          this.parentContainer.addLayer(this);\n        } else {\n          this.parentContainer.removeLayer(this);\n        }\n      }\n    },\n    setLatLngs(newLatLngs) {\n      if (newLatLngs == null) {\n        return;\n      }\n      if (this.mapObject) {\n        let oldLatLngs = this.mapObject.getLatLngs();\n\n        if (newLatLngs === oldLatLngs) {\n          this.mapObject.setLatLngs(newLatLngs);\n        }\n      }\n    }\n  }\n};\n\n</script>\n\n\n\n// WEBPACK FOOTER //\n// Vue2LeafletPathTransform.vue?7a0d0e99","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 4\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticStyle: {\n      \"display\": \"none\"\n    }\n  }, [(_vm.ready) ? _vm._t(\"default\") : _vm._e()], 2)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-54ea6851!./~/vue-loader/lib/selector.js?type=template&index=0!./Vue2LeafletPathTransform.vue\n// module id = 5\n// module chunks = 0","module.exports = require(\"vue2-leaflet\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"vue2-leaflet\"\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}